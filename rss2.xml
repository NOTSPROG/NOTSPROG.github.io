<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>NX の 博客</title>
    <link>https://www.nickxu.top/</link>
    
    <image>
      <url>https://www.nickxu.top/static/favicon.jpg</url>
      <title>NX の 博客</title>
      <link>https://www.nickxu.top/</link>
    </image>
    
    <atom:link href="https://www.nickxu.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>这家伙真勤奋，什么都留下了</description>
    <pubDate>Mon, 06 Mar 2023 13:14:19 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>雅思英语考试基本介绍</title>
      <link>https://www.nickxu.top/2023/03/06/%E9%9B%85%E6%80%9D%E8%8B%B1%E8%AF%AD%E8%80%83%E8%AF%95%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</link>
      <guid>https://www.nickxu.top/2023/03/06/%E9%9B%85%E6%80%9D%E8%8B%B1%E8%AF%AD%E8%80%83%E8%AF%95%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</guid>
      <pubDate>Mon, 06 Mar 2023 13:13:08 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;这是本人课上记的笔记，不代表我会去考（&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;考试分类&quot;&gt;考试分类&lt;/h2&gt;
&lt;p&gt;两大类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A类 学术类 Acadmic ☑️&lt;/li&gt;
&lt;li&gt;G类 培训类/移民类 （简单很</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>这是本人课上记的笔记，不代表我会去考（</p></blockquote><h2 id="考试分类">考试分类</h2><p>两大类</p><ul><li>A类 学术类 Acadmic ☑️</li><li>G类 培训类/移民类 （简单很多</li></ul><p>听力口语部分两个是一样的，阅读写作G类简单</p><p>（其实还有一种生活技能类，和我们关系不大，很多小孩子考</p><p>A类中的分类</p><ul><li><p>普通雅思</p><p>成绩只作为英语水平能力证明</p></li><li><p>UKVI雅思</p><p>成绩除了证明能力之外，还可以帮助你申请英国的签证</p></li></ul><p>如果绝对有把握能过就考普通雅思，不然就UKVI（会多一点钱，题目一样，但是学校会告诉你可以申请签证，提前几个月去当地的语言班，之后再考一遍</p><h2 id="考试信息">考试信息</h2><p>IELTS</p><p>2小时45分钟，包含听说读写，换算后总分9分</p><ul><li>听 30min</li><li>读 60min</li><li>写 60min</li><li>说 11-14min</li></ul><p>同类的考试还有托福</p><ul><li>都是标准化考试，难度差不多体型不一样</li><li>雅思主办方两个英国，一个澳大利亚，所以要熟悉一下英式和澳大利亚方言口音</li><li>托福是美国办的</li><li>托福全机考，雅思有人面对面</li><li>雅思作文难些，托福阅读难些</li><li>雅思托福大多数时候是通用的</li></ul><p>口语考试</p><ul><li><p>和托福不一样，雅思考两天，口语（说）单独安排在考试那周的周一到周五（提前完成）</p><p>其他的在礼拜六的上午</p></li><li><p>雅思口语题库一年换4次（一个季度），建议先让其他人考一下，参考一下其他人的题目</p></li><li><p>考场在学校，其实可以在11教门口待着，下来一个问一个</p></li><li><p>老师变数很大，有很和蔼的，有很严的，但是不要被影响，态度好的也不一定打高分</p></li></ul><p>分数水平</p><ul><li>全国分数最多是在 5.5-6 分（但是各种各样的人存在，导致分数比较低</li><li>杭电的努力一下 6.5-7 分</li><li>阅读和听力提升较快</li></ul><h2 id="考试流程">考试流程</h2><h3 id="听力">听力</h3><ul><li><p>30 min 4 sections 40 questions（每题1分</p></li><li><p>难度递增</p><p>策略：简单题一定要保证正确</p></li><li><p>60%以上英式英语，夹杂美式甚至是印度（</p></li></ul><p>四部分内容</p><ol><li>二人日常社交情景对话（一问一答</li><li>日常社交单人独白</li><li>四人教育/训练对话场景</li><li>单人学术类型独白</li></ol><h3 id="阅读">阅读</h3><ul><li><p>60min 3 passages 40 questions</p></li><li><p>test are taken from books, magazines, journals and newspaper</p></li><li><p>有些人会遇到加试（雅思托福都有，很常见</p><p>别人都在写作文了你还在阅读，别紧张</p><p>加一篇测试的新题目（不计分，随机挑人测试一下新题目难度，但是你不知道是哪一题，时间也会增加</p></li><li><p>托福和雅思有个不一样是阅读的最后一题可能是两分或者三分</p></li></ul><h3 id="写作">写作</h3><ul><li><p>60min 2tasks</p></li><li><p>task1 20min 小作文 150字 三分之一的分</p><p>图表类，描述</p></li><li><p>task2 40min 大作文 250字 三分之二的分</p><p>议论文（AB选一个说明理由，某件事已经发生了怎么解决）</p></li><li><p>不是字越多越好，不超过正负10%最好</p></li><li><p>内容重要</p></li><li><p>托福大小作文分数一样，小作文先看文章，再听，再写</p></li></ul><h3 id="口语">口语</h3><ul><li><p>it is not what you say, it is how you say it!</p></li><li><p>要学会扯</p></li><li><p>4-5min 自我介绍和采访，一问一答</p></li><li><p>3-4min 个人长独白 给你一张题卡，有一分钟时间准备，两分钟时间演讲，有草稿纸铅笔</p></li><li><p>4-5min 结合第二部分的题目交互式谈话</p></li></ul>]]></content:encoded>
      
      
      
      
      <comments>https://www.nickxu.top/2023/03/06/%E9%9B%85%E6%80%9D%E8%8B%B1%E8%AF%AD%E8%80%83%E8%AF%95%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ChatGPT对话记录（四）：手动递归下载依赖的麻烦</title>
      <link>https://www.nickxu.top/2023/03/05/ChatGPT%E5%AF%B9%E8%AF%9D%E8%AE%B0%E5%BD%95%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%89%8B%E5%8A%A8%E9%80%92%E5%BD%92%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96%E7%9A%84%E9%BA%BB%E7%83%A6/</link>
      <guid>https://www.nickxu.top/2023/03/05/ChatGPT%E5%AF%B9%E8%AF%9D%E8%AE%B0%E5%BD%95%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%89%8B%E5%8A%A8%E9%80%92%E5%BD%92%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96%E7%9A%84%E9%BA%BB%E7%83%A6/</guid>
      <pubDate>Sun, 05 Mar 2023 14:23:18 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;我在pkgs.org下包的时候总是要手动递归下载依赖，真的好麻烦&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;是的，手动递归下载依赖的确很麻烦，尤其是在安装大型软件包时。幸运的是，有些包管理器提供了自动递归下载依赖的功能，这可以大大简化安装</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>我在pkgs.org下包的时候总是要手动递归下载依赖，真的好麻烦</p></blockquote><hr><p>是的，手动递归下载依赖的确很麻烦，尤其是在安装大型软件包时。幸运的是，有些包管理器提供了自动递归下载依赖的功能，这可以大大简化安装过程。</p><p>例如，如果你正在使用Ubuntu或Debian发行版，可以使用APT包管理器来自动下载软件包及其依赖项。只需运行以下命令即可安装软件包并自动下载其所有依赖项：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install <span class="keyword">package</span>-name</span><br></pre></td></tr></table></figure><p>对于其他发行版，也可能有类似的包管理器可用，你可以参考对应的文档了解如何使用它们来自动下载依赖项。</p><p>如果你使用的包管理器不支持自动递归下载依赖，那么你可以考虑使用类似于&quot;apt-rdepends&quot;的第三方工具，该工具可以帮助你自动递归下载依赖项。使用这种工具可能需要一些命令行技能，但可以大大减少手动递归依赖的麻烦。</p><p>最后，有些软件包可能会提供单独的安装程序或安装脚本，可以自动下载并安装所有依赖项。在下载软件包之前，建议先查看软件包的文档，以确定是否提供了这种安装方法。</p><hr><blockquote><p>我是说我要在一个离线的服务器上安装软件，然后我找到了包，但是有一堆依赖，一个一个下太麻烦了</p></blockquote><hr><p>我明白了你的问题，如果你需要在一个离线的服务器上安装软件包及其依赖项，而又不想一个一个手动下载它们，可以考虑使用类似于&quot;apt-offline&quot;的工具。</p><p>&quot;apt-offline&quot;是一个命令行工具，它可以帮助你在一个在线的计算机上生成一个安装程序，该程序包含了软件包及其所有依赖项的下载链接。然后，你可以将该安装程序复制到离线的服务器上，使用该程序在离线服务器上安装软件包及其依赖项。</p><p>以下是使用&quot;apt-offline&quot;的基本步骤：</p><ol><li><p>在在线计算机上安装&quot;apt-offline&quot;工具：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install apt-offline</span><br></pre></td></tr></table></figure></li><li><p>在在线计算机上生成安装程序，该程序包含软件包及其依赖项的下载链接。假设要安装的软件包是&quot;package-name&quot;，可以运行以下命令：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-offline <span class="keyword">set</span> offline.sig --install-packages <span class="keyword">package</span>-name</span><br></pre></td></tr></table></figure><p>这将在当前目录中生成一个名为&quot;offline.sig&quot;的签名文件，其中包含了软件包及其所有依赖项的下载链接。</p></li><li><p>将签名文件复制到离线服务器上。</p></li><li><p>在离线服务器上使用&quot;apt-offline&quot;安装程序来安装软件包及其依赖项。运行以下命令：</p><p><code>sudo apt-offline install offline.sig</code></p><p>这将自动下载软件包及其所有依赖项，并将它们安装在离线服务器上。</p></li></ol><p>请注意，&quot;apt-offline&quot;只能下载安装软件包及其依赖项，而不能下载更新。如果你需要在离线服务器上更新软件包及其依赖项，请考虑使用其他工具或方法。</p><hr><blockquote><p>有没有适用于centos的</p></blockquote><hr><p>是的，对于CentOS或其他基于Red Hat的发行版，可以使用类似于&quot;yumdownloader&quot;或&quot;reposync&quot;的工具来下载软件包及其依赖项。</p><p>&quot;yumdownloader&quot;是一个命令行工具，可以帮助你下载指定软件包及其依赖项的RPM包。以下是使用&quot;yumdownloader&quot;下载软件包及其依赖项的基本步骤：</p><ol><li><p>在在线计算机上安装&quot;yum-utils&quot;软件包，该软件包包含了&quot;yumdownloader&quot;工具：</p><p><code>sudo yum install yum-utils</code></p></li><li><p>在在线计算机上使用&quot;yumdownloader&quot;下载软件包及其依赖项。假设要下载的软件包是&quot;package-name&quot;，可以运行以下命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yumdownloader --resolve <span class="keyword">package</span>-name</span><br></pre></td></tr></table></figure><p>这将下载软件包及其所有依赖项的RPM包，并将它们保存在当前目录中。</p></li><li><p>将RPM包复制到离线服务器上，并使用&quot;rpm&quot;命令进行安装。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -ivh <span class="keyword">package</span>-name.rpm</span><br></pre></td></tr></table></figure><p>这将安装软件包及其依赖项。</p></li></ol><p>&quot;reposync&quot;是另一个基于&quot;yum&quot;的工具，它可以帮助你下载整个软件仓库中的软件包及其依赖项。以下是使用&quot;reposync&quot;下载软件包及其依赖项的基本步骤：</p><ol><li><p>在在线计算机上安装&quot;yum-utils&quot;软件包，该软件包包含了&quot;reposync&quot;工具：</p><p><code>sudo yum install yum-utils</code></p></li><li><p>在在线计算机上使用&quot;reposync&quot;下载软件包及其依赖项。假设要下载的软件包来自于名为&quot;repo-name&quot;的软件仓库，可以运行以下命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reposync -r repo-name <span class="attr">--download-metadata</span> <span class="attr">--download-path</span>=/path/<span class="selector-tag">to</span>/save/packages</span><br></pre></td></tr></table></figure><p>这将下载&quot;repo-name&quot;仓库中的所有软件包及其依赖项，并将它们保存在指定的目录中。</p></li><li><p>将下载的RPM包复制到离线服务器上，并使用&quot;rpm&quot;命令进行安装。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -ivh <span class="keyword">package</span>-name.rpm</span><br></pre></td></tr></table></figure><p>这将安装软件包及其依赖项。</p></li></ol><p>请注意，下载整个软件仓库的方法可能需要较长时间和较大的存储空间，因此请确保你有足够的磁盘空间和时间。同时，请注意下载的软件包及其依赖项可能会有版本冲突等问题，请确保在离线服务器上使用的软件包版本与在线计算机上的一致。</p>]]></content:encoded>
      
      
      <category domain="https://www.nickxu.top/categories/ChatGPT-%E5%AF%B9%E8%AF%9D%E8%AE%B0%E5%BD%95/">ChatGPT 对话记录</category>
      
      
      <category domain="https://www.nickxu.top/tags/ChatGPT/">ChatGPT</category>
      
      <category domain="https://www.nickxu.top/tags/Linux/">Linux</category>
      
      
      <comments>https://www.nickxu.top/2023/03/05/ChatGPT%E5%AF%B9%E8%AF%9D%E8%AE%B0%E5%BD%95%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%89%8B%E5%8A%A8%E9%80%92%E5%BD%92%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96%E7%9A%84%E9%BA%BB%E7%83%A6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>服务器离线安装Docker</title>
      <link>https://www.nickxu.top/2023/03/05/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85Docker/</link>
      <guid>https://www.nickxu.top/2023/03/05/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85Docker/</guid>
      <pubDate>Sun, 05 Mar 2023 03:45:23 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;奶奶的昨天在学校的服务器上离线安装docker，折腾了一天都没搞定（&lt;/p&gt;
&lt;p&gt;你要下包吧，一堆递归依赖要手动递归下载🙄&lt;/p&gt;
&lt;p&gt;然后现在docker也没有源码编译了&lt;/p&gt;
&lt;p&gt;我在官方文档找哇，找到了个直接下二进制文件的&lt;/p&gt;
&lt;p&gt;然后搞定了&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p>奶奶的昨天在学校的服务器上离线安装docker，折腾了一天都没搞定（</p><p>你要下包吧，一堆递归依赖要手动递归下载🙄</p><p>然后现在docker也没有源码编译了</p><p>我在官方文档找哇，找到了个直接下二进制文件的</p><p>然后搞定了</p><p><a href="https://docs.docker.com/engine/install/binaries/#install-daemon-and-client-binaries-on-linux">https://docs.docker.com/engine/install/binaries/#install-daemon-and-client-binaries-on-linux</a></p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202303052235444.png" alt="image-20230305223522937"></p>]]></content:encoded>
      
      
      
      
      <comments>https://www.nickxu.top/2023/03/05/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85Docker/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>写在大二下开学之初</title>
      <link>https://www.nickxu.top/2023/03/01/%E5%86%99%E5%9C%A8%E5%A4%A7%E4%BA%8C%E5%BC%80%E5%AD%A6%E4%B9%8B%E5%88%9D/</link>
      <guid>https://www.nickxu.top/2023/03/01/%E5%86%99%E5%9C%A8%E5%A4%A7%E4%BA%8C%E5%BC%80%E5%AD%A6%E4%B9%8B%E5%88%9D/</guid>
      <pubDate>Wed, 01 Mar 2023 13:30:14 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;如你所见，我已经两个多月没有更新博客了，现在开学了，总得恢复更新节奏吧（&lt;/p&gt;
&lt;p&gt;最近很乱，就随便写写寒假到现在发生的事吧，想到哪里写到哪里&lt;/p&gt;
&lt;h2 id=&quot;手搓学习通&quot;&gt;手搓学习通&lt;/h2&gt;
&lt;p&gt;如果你要问我我寒假这两个月干什么去了，我会和你说，我一个人折</description>
        
      
      
      
      <content:encoded><![CDATA[<p>如你所见，我已经两个多月没有更新博客了，现在开学了，总得恢复更新节奏吧（</p><p>最近很乱，就随便写写寒假到现在发生的事吧，想到哪里写到哪里</p><h2 id="手搓学习通">手搓学习通</h2><p>如果你要问我我寒假这两个月干什么去了，我会和你说，我一个人折腾完了两个项目</p><p>一个是文艺数法学院的一个产品包装教学系统的后端，一个是青训营的项目，先说第一个</p><p>这个项目是上个学期杭助群里看见的，缺后端的人，然后我就进了</p><p>进了之后发现两个前端，就我一个后端（乐</p><p>我为什么想参加呢？第一个自然是有💰（三个人分了大几千块），第二个是想熟悉一下 <code>go-zero</code> 框架，第三个也是想丰富一下简历</p><p>对后端来说，我需要完成以下功能：班级系统，然后可以布置作业，学生相互批改作业，有班级云盘放资料，有教学视频给学生看…</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202303012225538.png" alt="image-20230301222502268"></p><blockquote><p><s>乐！这不就是学习通嘛（</s></p></blockquote><hr><h2 id="夜之城度假">夜之城度假</h2><p>我很快冲完了班级和云盘两个服务，剩一个作业的系统没写，毕竟有点累了，就想摆一下</p><p>然后正好 2077 打半价，这游戏缝缝补补了两年，我看了一下测评，现在可以入手了</p><p>讲真，我感觉现在这质量已经勉强能配得上发售的宣传了，我认为其实还不错，最后给了个好评</p><p>一开始我还没搞懂各种机制，第一个档被各种虐，去看攻略才熟悉，其实你偷芯片的时候上到天台拿到三郎的武士刀觉，后面就很舒服了</p><p>然后第二个档我打算尝试一下<a href="https://www.bilibili.com/video/BV1bV4y1T784/?share_source=copy_web&amp;vd_source=5ca30838bf3c8b357bddca1ff2565902">刀剑流</a>，跟着教程走很舒服，那几天我真的沉迷其中，基本上就是住在夜之城了</p><p>我已经很久没有遇到这么让我惊艳的作品了，上一次还是大表哥2</p><p>可惜的是，这东西剧情太短了，大概40小时就干完主线了，让然后我又去看各种攻略，尝试各种流派</p><p>然后我第三个档尝试的是<a href="https://www.bilibili.com/video/BV14V4y1p7Wn/?share_source=copy_web&amp;vd_source=5ca30838bf3c8b357bddca1ff2565902">黑客流</a>，这玩到后期是真的爽，拿着网监5基本上是瞪谁谁死，拿着应龙单挑荒坂塔那都不是事</p><p>而且我玩的是女V，这配音也是一流的，和原子之心的冰箱是一个人哦！</p><details class="toggle" ><summary class="toggle-button" style="">玩女V必看（不用感谢我😎</summary><div class="toggle-content"><p>捏脸：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">皮肤4</span><br><span class="line">发型12</span><br><span class="line">眼睛11</span><br><span class="line">眉毛7</span><br><span class="line">鼻子5</span><br><span class="line">嘴巴6</span><br><span class="line">下巴4</span><br><span class="line">耳朵14</span><br></pre></td></tr></table></figure><p>完美身材：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">版本：1.6，不上图了，就单纯敲字，请自行实验</span><br><span class="line">1.前期准备</span><br><span class="line">在衣柜里面设置3套衣服，第1套是正常的（就是什么都穿的），第2套什么都不穿，第3套准备一套特殊穿搭（全身连体的衣服）</span><br><span class="line">装备里面，全身上下除了一条正常的裤子以外，什么都不要有（武器可以保留）</span><br><span class="line">2.操作方法</span><br><span class="line">一、装备里面只穿裤子（已经穿了就不用管）和第3套特殊穿搭</span><br><span class="line">二、换成第1套有衣服的正常着装</span><br><span class="line">三、脱内裤</span><br><span class="line">四、穿第2套没衣服的着装</span><br><span class="line">3.最终结果</span><br><span class="line">不管读盘、退出，还是穿脱各种装备，始终都能保持完美身材</span><br></pre></td></tr></table></figure></div></details><p>最后我大概玩了 170 个小时吧，把所有的结局和所有的支线都玩过一遍了，感觉支线比主线的东西多多了，而且很多东西都是很用心的，同时也无不对阉割的内容感到遗憾，比如说冰箱里的神迹后面本来还有一串任务的，但是都被砍了</p><p>玩完游戏本体我又去把边缘行者找来看了一遍，毕竟在夜之城住了好久了，动画的带入感真是极强（里面的地方都认得在什么地方</p><p>看完之后后劲也是很大的，又回去把重锤锤了几遍（乐</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202303012256100.png" alt="image-20230301225612064"></p><blockquote><p>结束在夜之城的度假之后，我找了张 V 的公寓的桌面壁纸，真的是挺好看的</p></blockquote><hr><h2 id="青训营破防">青训营破防</h2><p>然后就是青训营开营了，第五届字节跳动青训营其实和第三届差不多，后端的课相差不大，项目居然也是一模一样的（写一个精简版的抖音后端）</p><p>因为这次我想带一个大一的一起做项目，所以我选的是基础班，然后带了几个大一的和yeebing一起做项目</p><p>为了和第三届的项目（单体gin）拉开点差距，我上了微服务，然后自然是go-zero框架</p><p>这样以来对新人的压力也不会很大，业务代码可以参考第三届的项目，微服务架构可以参考我的项目</p><p>也可以让评委看看我这一套怎么样，毕竟相同的架构的项目是要上生产环境的，面试系统也是用的是go-zero</p><p>项目公布的那一晚，我就拉着他们开会，各种分析，各种讲解，各种手把手，BB了好几个小时</p><p><a href="/2023/01/13/%E7%AC%AC%E4%BA%94%E5%B1%8A%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%92%E8%AE%AD%E8%90%A5%E9%A1%B9%E7%9B%AE%E4%BC%9A%E8%AE%AE%E7%BA%AA%E8%A6%81/">第五届字节跳动青训营项目会议纪要</a></p><p>然后我把架子搭起来写了一些东西，就把大部分东西想留给他们锻炼锻炼</p><p>然后呢？啥动静都没有（</p><p>平时基本也就我一个人在群里面说话，真的是破大防</p><p>但是有个大一的其实还行，学的很快，一上来就搞定了三个接口，也就这位比较让我满意</p><p>原定是过年前要把所有功能都冲完，结果等到初十还没搞完</p><p>然后这时候我一边要把另一个项目补完，一边还要给这个项目擦屁股，我真的是服了，这帮人基本是啥都帮不了</p><p>真的是让人心寒，基本变成单人项目了（幸好yeebing也在帮忙，不然我真的得累死</p><p>这时还有个负责消息相关的态度还不错，勉勉强强地完成了相关接口，但是其他的我根本就不想评价，还有直接说自己啥都不懂的，我那天讲那么久都白讲了？</p><p>这绝对不是能力问题，而是态度，即使你说你啥都不会写，那你打下手总行吧？我写完了接口需要有人测试，完成了所有接口需要有人用app测试，结果呢？根本没人理我</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202303012353313.png" alt="image-20230301235341289"></p><blockquote><p>我发誓我以后再也不带生人做项目了</p></blockquote><p>这些还不完全是陌生人，是上个学期面试招进来的，每个人我都是亲自面过的，就这种素质，我第三届的时候其实也是啥都不懂，gorm的语句都是依葫芦画瓢+copilot帮我写的，但是我前前后后commit数也有个两位数，也积极配合测试，甚至当时还买了个二手的荣耀Magic2来做测试机</p><p>最后还是我来擦屁股，把各种bug修了，把各个接口完成了，但是我还得上缓存和消息队列做各种优化</p><p>然后返校前我还得去把科目四给考了，事情真的不少，那段时间真的是忙</p><hr><h2 id="第一次装机">第一次装机</h2><p>来点过年的小插曲，缓和一点气氛</p><p>过年的时候我爸的办公室要更新几台机子，我看了一下情况，从一些老古董里面挑了两台勉强还能用的，可以升级一下配置，然后还得再装一台新机</p><p>虽然我初中就开始折腾硬件了，但是我家都是笔记本，也就是换个内存硬盘之类的，但是台式机还没折腾过</p><p>我就趁这个机会学习一下，然后我就在B上看硬件茶谈的装机教程，感觉我也行了，就去买了一堆硬件</p><table><thead><tr><th>类型</th><th>名称&amp;链接</th><th>价格</th></tr></thead><tbody><tr><td>机箱</td><td><a href="https://item.taobao.com/item.htm?spm=a1z0d.6639537/tb.0.0.78f17484jRRuQt&amp;id=591613843038">傻瓜超人 K88</a></td><td>159</td></tr><tr><td>主板</td><td><a href="https://item.taobao.com/item.htm?spm=a1z0d.6639537/tb.0.0.78f17484jRRuQt&amp;id=679885751158">昂达B660-VH-B</a></td><td>379</td></tr><tr><td>CPU</td><td><a href="https://item.taobao.com/item.htm?spm=a1z0d.7625083.0.0.5c5f4e69Go4Mnh&amp;id=667946031150">I3-12100</a></td><td>685</td></tr><tr><td>内存</td><td><a href="https://item.jd.com/100014056864.html#none">金百达 8GB*2 DDR4 3200</a></td><td>249</td></tr><tr><td>硬盘</td><td><a href="https://item.jd.com/100011216263.html#none">京东京造 5系 512GB M.2 PCIe3.0</a></td><td>229</td></tr><tr><td>电源</td><td><a href="https://mobile.yangkeduo.com/goods1.html?_wvx=10&amp;refer_share_uin=CG7CTRXRWNP5BMMEAQADLBCQTQ_GEXDA&amp;refer_share_id=mTe407rsWBayLY7YtvMIwpKXYT4GUoRC&amp;share_uin=CG7CTRXRWNP5BMMEAQADLBCQTQ_GEXDA&amp;page_from=101&amp;_oak_share_snap_num=21800&amp;_oak_share_detail_id=0&amp;_wv=41729&amp;refer_share_channel=copy_link&amp;pxq_secret_key=VC2CGZFS4SW275VHIN3PXW7ZJ74WJXMHULVMFXQBMLTJSKVMNBHA&amp;goods_id=275474400230">技嘉 GP-P450B</a></td><td>179</td></tr><tr><td>散热</td><td><a href="https://mobile.yangkeduo.com/goods1.html?_wvx=10&amp;refer_share_uin=CG7CTRXRWNP5BMMEAQADLBCQTQ_GEXDA&amp;refer_share_id=hZoF0YrdP8oFmpXWgVawTndGpklYjDTb&amp;share_uin=CG7CTRXRWNP5BMMEAQADLBCQTQ_GEXDA&amp;page_from=101&amp;_oak_share_snap_num=4150&amp;_oak_share_detail_id=0&amp;_wv=41729&amp;refer_share_channel=copy_link&amp;pxq_secret_key=VC2CGZFS4SW275VHIN3PXW7ZJ6NTFUQ4FZVVEV65G2YIIOTB7KSA&amp;goods_id=186518396784">乔思伯CR1400</a></td><td>60</td></tr></tbody></table><div class="fj-gallery"><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202303022227112.jpeg" alt="45A34C3F-7970-45F6-994C-8BFFA542164A_1_105_c"></p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202303022229536.jpeg" alt="52B834D4-3717-41B9-AD06-3E5B0E1F577F_1_105_c"></p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202303022230382.png" alt="image-20230302223013352"></p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202303022230309.png" alt="image-20230302223026273"></p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202303022236262.jpeg" alt="15395619-4734-4365-8DF8-450639F9A6D8_1_105_c"></p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202303022236946.jpeg" alt="5038140C-3966-4297-A4EC-59719D8C5C78_1_105_c"></p>          </div><p>然后我就开装了，等我按照教程在机箱里面装好了之后，才发现点不亮（悲</p><p>然后我就被迫拆出来重新折腾（早知道就先测试好了再装进去了</p><p>排查一圈感觉是主板的问题，我就去找店家理论，店家指导一通也搞不定，只能退货</p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202303022238768.png" alt="5DCA0CE9-5492-4CA2-84FC-20DE063847D6" style="zoom:50%;" /><blockquote><p>真是中彩票了，以后再也不买昂达的主板了（</p></blockquote><p>但是这个时候我要回家了，所以我得把机箱搬回去再折腾</p><p>等过了几天我收到新主板了之后，我终于点亮了</p><p>但是很奇怪，我一进PE就蓝屏，没办法，只能通过官方镜像安装了</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202303022241678.jpeg" alt="57291E8C-2002-43D2-ACA5-832971258317_1_105_c"></p><blockquote><p>办公嘛，用什么Windows11，直接Windows10 LTSC 就够了</p></blockquote><p>但是呢，这个非模组电源的线也太丑了吧（</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202303022242543.jpeg" alt="3A6117B2-EF7B-4B99-B0A6-92D6960A3844_1_105_c"></p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202303022242185.jpeg" alt="A6464FB8-58CE-4D09-87AE-6E05EE69478D_1_105_c"></p><p>这个我感觉理线好麻烦哇，算了就这样吧，反正不是我用（bushi</p><p>以后要是自己装机的话大概了会用全模组电源了</p><p>这次装机也算是学了很多吧，什么主板显卡之类的之前也没了解多少，这次算是入了DIY的门了，关注了一堆UP，我以后如果要搞一台台式肯定会是自己组了</p><hr><h2 id="开学考挂科">开学考挂科</h2><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202303012350735.png" alt="image-20230301235053699" style="zoom:50%;" /><blockquote><p>大物和离散要是能隔个一天就好了</p></blockquote><p>返校了，第二天就考了习概，然后有点空档，我就一直在折腾青训营的项目，折腾各种优化，redis、消息队列、异步、定时任务等等</p><p>然后离散的考试和提交项目的时间重合了，所以我还得早点搞完这个项目，还得写个<a href="https://hdu-help.feishu.cn/docx/KuGidErAIogvWDxcn2VcTrfUntb">汇报文档</a></p><p>结果就是，我折腾到大物的前两天才开始全力复习大物，而离散是一点都没看（毕竟大物比离散难得多</p><p>考完大物我基本就是个废人了，毕竟已经连续工作十几天了，感觉是真的累，期间也没放松过（我就带了个MacBook，也玩不了游戏</p><p>而第二天早上就要考离散，留给我缓冲的时间不多，只能说浅浅复习一波</p><p>到了第二天，我能记得的真的不多，基本上昨天复习的全忘记了，也就图树这类高中竞赛的时候学过的有点把握</p><p>更要命的是，我做到最后十分钟的时候，才发现试卷还有一面，有两道大题，我自己倒吸一口凉气</p><p>人麻了，这怕不是第一次要补考</p><p>然后前几天结果出来了，大物最终成绩61分飘过，离散56分不及格</p><hr><h2 id="前路在何方">前路在何方</h2><p>挂科了心情总是有些不爽的，毕竟我读书这么多年从来也没有遇到考试不及格的情况</p><p>但是谁知道呢？可能要发生点好事就必须要有一些前置条件吧，好事多磨应该就是也个道理</p><p>然后目前在等青训营初评，前不久不是gsoc的组织公布了嘛，<a href="https://summerofcode.withgoogle.com/programs/2023/organizations">我就去看了一下</a></p><p>结果呢？没几个项目是用golang的</p><p>看来看去，感觉也就个keploy的重构客户端的还有点能力完成，但是肯定也一堆人</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202303022257833.png" alt="image-20230302225744796"></p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202303022308720.png" alt="image-20230302230849672"></p><blockquote><p>然后iyear提醒了一手这个项目的 maintainer ，奶奶的，居然全是阿三（</p></blockquote><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202303022301658.png" alt="image-20230302230119617"></p><p>要知道，印度人在海外可是很抱团的，选上的肯定会是印度人，这项目怕不是用来从Google手上骗经费的（bushi</p><p>为什么就没有国人的项目包容一下华人呢？</p><p>看来看去我感觉还是准备开源之夏吧，ospp比gsoc简单不少，gsoc还要各种攀关系，混脸熟，人情世故真的是在世界各地都有</p><p>So？前路在何方？</p><p>我也不知道，走一步算一步吧，这个学期想把k8s学一学，然后书架上还有一堆书可以看一看，总不能一直放着吃灰吧</p><p>暑假大概率还要参加亚运会志愿者的培训，这学期还是挺忙的</p><p>前几天产品包装系统的甲方又提了些修改意见，还有一堆事情等着我呢</p><p>边走边看吧！</p>]]></content:encoded>
      
      
      <category domain="https://www.nickxu.top/categories/%E9%9A%8F%E7%AC%94%E4%B8%8E%E6%80%BB%E7%BB%93/">随笔与总结</category>
      
      
      <category domain="https://www.nickxu.top/tags/%E9%9A%8F%E7%AC%94/">随笔</category>
      
      
      <comments>https://www.nickxu.top/2023/03/01/%E5%86%99%E5%9C%A8%E5%A4%A7%E4%BA%8C%E5%BC%80%E5%AD%A6%E4%B9%8B%E5%88%9D/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ChatGPT对话记录（三）：GORM的行级锁</title>
      <link>https://www.nickxu.top/2023/02/19/ChatGPT%E5%AF%B9%E8%AF%9D%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AGORM%E7%9A%84%E8%A1%8C%E7%BA%A7%E9%94%81/</link>
      <guid>https://www.nickxu.top/2023/02/19/ChatGPT%E5%AF%B9%E8%AF%9D%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AGORM%E7%9A%84%E8%A1%8C%E7%BA%A7%E9%94%81/</guid>
      <pubDate>Sat, 18 Feb 2023 16:14:50 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;你知不知道gorm的Clauses方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;是的，我知道gorm的Clauses方法。在GORM中，Clauses方法是用于在查询语句中添加子句的函数。它允许您使用原始的SQL语句或GORM的构建器函</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>你知不知道gorm的Clauses方法</p></blockquote><hr><p>是的，我知道gorm的Clauses方法。在GORM中，Clauses方法是用于在查询语句中添加子句的函数。它允许您使用原始的SQL语句或GORM的构建器函数来添加子句。</p><p>Clauses方法返回的是*DB对象，您可以在此对象上继续调用其他GORM函数，例如Where、Order、Limit等，以构建完整的查询语句。Clauses方法的语法如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.Clauses</span>(clauseBuilder...)</span><br></pre></td></tr></table></figure><p>其中，clauseBuilder可以是一个字符串表示的原始SQL语句，也可以是一个GORM构建器函数，例如Select、Where、Order、Limit等。</p><p>例如，以下代码使用Clauses方法添加了一个子句，然后使用Where和Find函数来执行查询操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Clauses(<span class="string">&quot;SELECT * FROM users WHERE age &gt; ?&quot;</span>, 18).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;John&quot;</span>).Find(&amp;<span class="built_in">users</span>)</span><br></pre></td></tr></table></figure><hr><blockquote><p>里面有个clause.Locking，能解释一下嘛</p></blockquote><hr><p>是的，<code>clause.Locking</code>是GORM中的一个子句，用于为查询语句添加<code>FOR UPDATE</code>或<code>FOR SHARE</code>语句，以实现数据库中的行级锁。</p><p>在GORM中，您可以通过在<code>Clauses</code>函数中传递<code>clause.Locking</code>子句来为查询语句添加行级锁。具体语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_ invoke__">Clauses</span>(clause.Locking&#123;<span class="attr">Strength</span>: <span class="string">&quot;UPDATE&quot;</span>, <span class="attr">Tables</span>: []<span class="keyword">string</span>&#123;<span class="string">&quot;table1&quot;</span>&#125;&#125;).<span class="title function_ invoke__">Find</span>(&amp;result)</span><br></pre></td></tr></table></figure><p>上面的代码将在<code>table1</code>表上添加<code>FOR UPDATE</code>行级锁，并使用<code>Find</code>函数执行查询操作。如果您想使用<code>FOR SHARE</code>语句，则可以将<code>Strength</code>属性设置为<code>&quot;SHARE&quot;</code>。</p><p>请注意，<code>clause.Locking</code>子句只对支持行级锁的数据库有效，例如PostgreSQL、MySQL等。在不支持行级锁的数据库中，此子句将不起作用。此外，行级锁是一种悲观锁，它会对查询的行进行加锁，因此在高并发的情况下，使用行级锁可能会导致性能问题，需要谨慎使用。</p><hr><blockquote><p>type Locking struct { Strength string Table Table Options string } 它的原始定义包含3个值，分别是什么意思？</p></blockquote><hr><p><code>Locking</code>结构体的原始定义包含三个字段，它们分别是<code>Strength</code>、<code>Table</code>和<code>Options</code>。</p><ol><li><p><code>Strength</code>字段用于指定锁的类型，可以是<code>&quot;UPDATE&quot;</code>或<code>&quot;SHARE&quot;</code>。<code>&quot;UPDATE&quot;</code>表示添加<code>FOR UPDATE</code>行级锁，它可以用于查询时对返回的记录进行排他性锁定，以避免并发问题。<code>&quot;SHARE&quot;</code>表示添加<code>FOR SHARE</code>行级锁，它用于查询时对返回的记录进行共享锁定，以确保多个事务可以同时读取记录。</p></li><li><p><code>Table</code>字段用于指定要加锁的表，它可以是字符串类型的表名，也可以是一个<code>Table</code>结构体类型。<code>Table</code>结构体通常用于自定义表的别名、引用和转义。</p></li><li><p><code>Options</code>字段用于指定锁的其他选项，它是一个字符串类型的选项列表，可以包含任何其他锁定选项，例如<code>NOWAIT</code>、<code>SKIP LOCKED</code>等。默认情况下，该字段为<code>&quot;&quot;</code>，即不指定其他选项。</p></li></ol><p>总之，<code>Locking</code>结构体提供了一种简便的方式来指定查询语句中的行级锁类型、加锁表和其他选项，从而帮助开发者更方便地控制数据的并发访问。</p><hr><blockquote><p>如果我不指定table会怎样</p></blockquote><hr><p>如果在使用<code>clause.Locking</code>时不指定表名，GORM会使用默认的表名来添加行级锁。默认情况下，GORM使用查询的主表作为行级锁的表，即如果您使用<code>Model</code>函数指定了模型对象，则主表是该模型对象对应的数据库表。</p><p>例如，以下代码使用<code>clause.Locking</code>在默认表上添加<code>FOR UPDATE</code>锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Model(<span class="operator">&amp;</span><span class="keyword">User</span>&#123;&#125;).<span class="keyword">Where</span>(&quot;id = ?&quot;, <span class="number">1</span>).Clauses(clause.Locking&#123;Strength: &quot;UPDATE&quot;&#125;).<span class="keyword">Update</span>(&quot;name&quot;, &quot;new_name&quot;)</span><br></pre></td></tr></table></figure><p>上面的代码将在<code>users</code>表上添加<code>FOR UPDATE</code>锁，因为<code>User</code>模型对应的数据库表是<code>users</code>表。</p><p>如果您不希望使用默认表名，可以通过在<code>Locking</code>子句中指定<code>Table</code>字段来自定义表名，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Model(<span class="operator">&amp;</span><span class="keyword">User</span>&#123;&#125;).<span class="keyword">Where</span>(&quot;id = ?&quot;, <span class="number">1</span>).Clauses(clause.Locking&#123;Strength: &quot;UPDATE&quot;, <span class="keyword">Table</span>: clause.Table&#123;Name: &quot;user_lock&quot;&#125;&#125;).<span class="keyword">Update</span>(&quot;name&quot;, &quot;new_name&quot;)</span><br></pre></td></tr></table></figure><p>上面的代码将在<code>user_lock</code>表上添加<code>FOR UPDATE</code>锁，而不是默认的<code>users</code>表。</p><p>总之，如果您没有指定表名，则GORM会使用默认表名添加行级锁，但是如果您想自定义表名，则可以通过在<code>Locking</code>子句中指定<code>Table</code>字段来实现。</p>]]></content:encoded>
      
      
      <category domain="https://www.nickxu.top/categories/ChatGPT-%E5%AF%B9%E8%AF%9D%E8%AE%B0%E5%BD%95/">ChatGPT 对话记录</category>
      
      
      <category domain="https://www.nickxu.top/tags/ChatGPT/">ChatGPT</category>
      
      <category domain="https://www.nickxu.top/tags/GORM/">GORM</category>
      
      <category domain="https://www.nickxu.top/tags/Go/">Go</category>
      
      
      <comments>https://www.nickxu.top/2023/02/19/ChatGPT%E5%AF%B9%E8%AF%9D%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AGORM%E7%9A%84%E8%A1%8C%E7%BA%A7%E9%94%81/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ChatGPT对话记录（二）：使用apt完全删除软件包</title>
      <link>https://www.nickxu.top/2023/02/17/ChatGPT%E5%AF%B9%E8%AF%9D%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8apt%E5%AE%8C%E5%85%A8%E5%88%A0%E9%99%A4%E8%BD%AF%E4%BB%B6%E5%8C%85/</link>
      <guid>https://www.nickxu.top/2023/02/17/ChatGPT%E5%AF%B9%E8%AF%9D%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8apt%E5%AE%8C%E5%85%A8%E5%88%A0%E9%99%A4%E8%BD%AF%E4%BB%B6%E5%8C%85/</guid>
      <pubDate>Fri, 17 Feb 2023 11:21:50 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;我如何使用apt完全删除软件包，连配置文件也一起删的那种&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;要使用apt命令完全删除软件包以及其相关的配置文件，可以使用&lt;code&gt;purge&lt;/code&gt;选项。以下是具体的步骤：&lt;/p&gt;
&lt;ol&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>我如何使用apt完全删除软件包，连配置文件也一起删的那种</p></blockquote><hr><p>要使用apt命令完全删除软件包以及其相关的配置文件，可以使用<code>purge</code>选项。以下是具体的步骤：</p><ol><li><p>打开终端，使用root权限或sudo权限登录。</p></li><li><p>运行以下命令以卸载软件包及其配置文件：</p><p><code>sudo apt purge 软件包名称</code></p><p>将<code>软件包名称</code>替换为要删除的软件包的名称。</p></li><li><p>在确认提示中，输入<code>Y</code>以确认卸载操作。</p></li><li><p>如果您还想删除软件包相关的依赖项，可以使用<code>autoremove</code>命令。运行以下命令：</p><p><code>sudo apt autoremove</code></p><p>这将删除已经没有用的软件包及其依赖项。</p></li></ol><p>请注意，在卸载软件包及其配置文件之前，请确保您已经备份了任何重要的配置文件和数据。</p><hr>]]></content:encoded>
      
      
      <category domain="https://www.nickxu.top/categories/ChatGPT-%E5%AF%B9%E8%AF%9D%E8%AE%B0%E5%BD%95/">ChatGPT 对话记录</category>
      
      
      <category domain="https://www.nickxu.top/tags/ChatGPT/">ChatGPT</category>
      
      <category domain="https://www.nickxu.top/tags/Linux/">Linux</category>
      
      
      <comments>https://www.nickxu.top/2023/02/17/ChatGPT%E5%AF%B9%E8%AF%9D%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8apt%E5%AE%8C%E5%85%A8%E5%88%A0%E9%99%A4%E8%BD%AF%E4%BB%B6%E5%8C%85/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ChatGPT对话记录（一）：通过SSH密钥进行身份验证</title>
      <link>https://www.nickxu.top/2023/02/17/ChatGPT%E5%AF%B9%E8%AF%9D%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%80%9A%E8%BF%87SSH%E5%AF%86%E9%92%A5%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/</link>
      <guid>https://www.nickxu.top/2023/02/17/ChatGPT%E5%AF%B9%E8%AF%9D%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%80%9A%E8%BF%87SSH%E5%AF%86%E9%92%A5%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/</guid>
      <pubDate>Thu, 16 Feb 2023 16:54:10 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;如何将公钥添加到 ~/.ssh/authorized_keys 中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;要将公钥添加到&lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt;文件中，可以按照以下步骤操作：&lt;/p&gt;
&lt;o</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>如何将公钥添加到 ~/.ssh/authorized_keys 中</p></blockquote><hr><p>要将公钥添加到<code>~/.ssh/authorized_keys</code>文件中，可以按照以下步骤操作：</p><ol><li><p>将公钥复制到本地计算机的剪贴板中。可以使用以下命令从远程计算机获取公钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@remote_host <span class="string">&quot;cat ~/.ssh/id_rsa.pub&quot;</span></span><br></pre></td></tr></table></figure><p>请确保将<code>user</code>和<code>remote_host</code>替换为您要连接的远程计算机的用户名和主机名。</p></li><li><p>在本地计算机上打开终端窗口并使用以下命令将公钥添加到<code>~/.ssh/authorized_keys</code>文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></li><li><p>将公钥粘贴到终端窗口中，然后按<code>Ctrl-D</code>保存文件并退出终端。</p></li></ol><p>现在，您应该能够使用SSH密钥连接到远程计算机，而无需输入密码。请确保将公钥添加到正确的用户的<code>~/.ssh/authorized_keys</code>文件中，否则您可能无法成功连接。</p><p>（本人PS：这里应该是说反了，应该是把自己的公钥放到远程的 <code>authorized_keys</code>  ）</p><hr><blockquote><p>我已经添加了公钥，但提示 <a href="mailto:root@1.15.112.229">root@1.15.112.229</a>: Permission denied (password).</p></blockquote><hr><p>如果您已经将公钥添加到远程主机的<code>~/.ssh/authorized_keys</code>文件中，但仍然收到密码验证失败的错误消息，则可能存在以下问题：</p><ol><li><p>您在连接时使用了错误的用户名：请确保您在连接时使用了正确的用户名，这是指您添加公钥时使用的用户名。</p></li><li><p>权限问题：请确保您的<code>~/.ssh</code>目录和<code>~/.ssh/authorized_keys</code>文件的权限设置正确。这两个文件应该只有您本人可以读写，而不是其他人。可以使用以下命令修复权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 700 ~/.ssh</span><br><span class="line"><span class="built_in">chmod</span> 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></li><li><p>SELinux或防火墙问题：如果您的远程主机启用了SELinux或防火墙，请确保它们不会阻止您的SSH连接。您可以通过临时禁用SELinux或防火墙来测试它们是否是问题的根本原因。</p></li><li><p>SSH服务器配置问题：最后，您可能需要检查远程主机上的SSH服务器配置文件以确保它已正确配置以允许公钥身份验证。如果您无法解决问题，请尝试联系远程主机管理员或系统管理员以获取更多帮助。</p></li></ol><hr><blockquote><p>Load key “/Users/nx/.ssh/id_rsa.pub”: invalid forma</p></blockquote><hr><p>这个错误通常出现在您正在尝试使用错误的文件来加载SSH密钥。</p><p><code>.pub</code>文件是SSH密钥对中的公钥，而不是私钥。请确保您正在使用私钥文件（默认为<code>id_rsa</code>）而不是公钥文件来加载SSH密钥。</p><p>请使用以下命令来加载私钥文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add /path/to/private/key</span><br></pre></td></tr></table></figure><p>请将<code>/path/to/private/key</code>替换为您的私钥文件的实际路径。如果您不确定私钥文件的位置，可以使用以下命令查找：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al ~/.ssh</span><br></pre></td></tr></table></figure><p>上述命令将列出您<code>.ssh</code>目录中的所有文件和目录，包括您的SSH密钥对。在此列表中查找包含<code>id_rsa</code>的文件，这将是您的私钥文件。</p><p>请注意，私钥文件的权限也非常重要。在加载SSH密钥之前，请确保私钥文件的权限设置为只有您自己可以读写，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 /path/to/private/key</span><br></pre></td></tr></table></figure><p>如果上述方法不起作用，请检查您的私钥文件是否已被损坏。您可以尝试创建一个新的SSH密钥对，并将公钥添加到您想要连接的远程主机上。</p><hr><blockquote><p>我怀疑是远程服务器没有开启公钥登录</p></blockquote><hr><p>如果您已经确保本地计算机上的SSH密钥和远程计算机上的<code>~/.ssh/authorized_keys</code>文件都正确设置，但仍然无法使用SSH密钥进行身份验证，则可能是因为远程计算机上的SSH服务器没有正确配置以允许SSH密钥身份验证。</p><p>首先，请确保远程计算机上的SSH服务器已启用公钥身份验证。在远程计算机上打开<code>/etc/ssh/sshd_config</code>文件，并检查以下设置是否正确设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PubkeyAuthentication <span class="built_in">yes</span></span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>如果这些设置未正确设置，您需要将它们更改为上述值，保存文件并重新启动SSH服务器。</p><p>如果仍然无法使用SSH密钥进行身份验证，请检查远程计算机上的SSH服务器日志以获取更多详细信息。在大多数Linux系统上，SSH服务器日志文件位于<code>/var/log/auth.log</code>或<code>/var/log/secure</code>中。检查日志文件是否包含有关SSH连接和身份验证失败的任何错误消息。</p><p>如果您仍然无法解决问题，请尝试联系远程计算机的管理员或系统管理员以获取更多帮助。</p>]]></content:encoded>
      
      
      <category domain="https://www.nickxu.top/categories/ChatGPT-%E5%AF%B9%E8%AF%9D%E8%AE%B0%E5%BD%95/">ChatGPT 对话记录</category>
      
      
      <category domain="https://www.nickxu.top/tags/ChatGPT/">ChatGPT</category>
      
      <category domain="https://www.nickxu.top/tags/Linux/">Linux</category>
      
      <category domain="https://www.nickxu.top/tags/SSH/">SSH</category>
      
      
      <comments>https://www.nickxu.top/2023/02/17/ChatGPT%E5%AF%B9%E8%AF%9D%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%80%9A%E8%BF%87SSH%E5%AF%86%E9%92%A5%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>第五届字节跳动青训营项目会议纪要</title>
      <link>https://www.nickxu.top/2023/01/13/%E7%AC%AC%E4%BA%94%E5%B1%8A%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%92%E8%AE%AD%E8%90%A5%E9%A1%B9%E7%9B%AE%E4%BC%9A%E8%AE%AE%E7%BA%AA%E8%A6%81/</link>
      <guid>https://www.nickxu.top/2023/01/13/%E7%AC%AC%E4%BA%94%E5%B1%8A%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%92%E8%AE%AD%E8%90%A5%E9%A1%B9%E7%9B%AE%E4%BC%9A%E8%AE%AE%E7%BA%AA%E8%A6%81/</guid>
      <pubDate>Fri, 13 Jan 2023 11:55:35 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;明确目标&quot;&gt;明确目标&lt;/h1&gt;
&lt;h2 id=&quot;项目质量&quot;&gt;项目质量&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202301131955844.png&quot; alt=&quot;image</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="明确目标">明确目标</h1><h2 id="项目质量">项目质量</h2><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202301131955844.png" alt="image-20230113125129881"></p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202301131955948.png" alt="image-20230113130844275"  /><blockquote><p>我们的目标是一等奖，重振h68u荣光</p></blockquote><p>有第三届的项目可供参考：<a href="https://github.com/h68u/h68u-tiktok-app">https://github.com/h68u/h68u-tiktok-app</a></p><h2 id="DDL">DDL</h2><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202301131955142.png" alt="1280X1280"></p><blockquote><p>约寒假结束，但肯定要提前完成</p></blockquote><h2 id="个人要求">个人要求</h2><blockquote><p>不要当死人</p></blockquote><p>当你遇到问题时：</p><ul><li>自己折腾</li><li>搜索引擎</li><li>B站</li><li>copilot</li><li>ChatGPT</li><li>群里问</li></ul><p>必备技能：</p><ul><li>gorm</li><li>redis</li><li>熟悉 go-zero</li></ul><hr><h1 id="项目规划">项目规划</h1><h2 id="框架">框架</h2><p>go-zero</p><h3 id="原因-优点">原因/优点</h3><ul><li>有现成模板，鄙人的项目：<a href="https://github.com/hdu-packaging-design/hdu-packaging-design-be">https://github.com/hdu-packaging-design/hdu-packaging-design-be</a></li><li>微服务</li><li>及其清晰的项目结构</li><li>方便结合 docker、k8s 部署</li><li>易于搭配各种监控组件</li><li>日后参加面试系统开发</li></ul><h2 id="时间规划">时间规划</h2><p>最晚过年前冲出功能完善的demo，再继续改进</p><h2 id="可改进问题">可改进问题</h2><h3 id="缓存一致性">缓存一致性</h3><p>暂时先更新数据库后删除缓存值，后面再考虑要不要上消息队列等</p><p>可参考资料：</p><ul><li><a href="https://juejin.cn/post/7156237969202872350">聊一聊缓存和数据库不一致性问题的产生及主流解决方案以及扩展的思考</a></li><li><a href="https://juejin.cn/post/7168291215753314311">万字图文讲透数据库缓存一致性问题</a></li></ul><h3 id="热点数据">热点数据</h3><p>分库分表</p><p>可参考资料：</p><p><a href="https://juejin.cn/post/7155784807702593572">好好的系统，为什么要分库分表？</a></p><p><a href="https://juejin.cn/post/7146016771936354312">Mysql大数据表处理方案</a></p><p>B站也有相关的视频</p><p>其他解决方法后面再思考</p><h3 id="监控组件">监控组件</h3><ul><li>prometheus+grafan 服务监控</li><li>jaeger 链路追踪</li><li>kafka+Elasticsearch 日志分析</li></ul><p><a href="https://www.waterflow.link/articles/1661696351405">https://www.waterflow.link/articles/1661696351405</a> 连着3篇</p><p>B 站 go-zero官方视频也有这方面内容</p><h2 id="团队分工">团队分工</h2><p>自由分工</p>]]></content:encoded>
      
      
      
      
      <comments>https://www.nickxu.top/2023/01/13/%E7%AC%AC%E4%BA%94%E5%B1%8A%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%92%E8%AE%AD%E8%90%A5%E9%A1%B9%E7%9B%AE%E4%BC%9A%E8%AE%AE%E7%BA%AA%E8%A6%81/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>『CI/CD』使用Webhook通知服务器</title>
      <link>https://www.nickxu.top/2022/12/19/%E3%80%8ECI-CD%E3%80%8F%E4%BD%BF%E7%94%A8Webhook%E9%80%9A%E7%9F%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <guid>https://www.nickxu.top/2022/12/19/%E3%80%8ECI-CD%E3%80%8F%E4%BD%BF%E7%94%A8Webhook%E9%80%9A%E7%9F%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <pubDate>Mon, 19 Dec 2022 13:50:41 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;在前面的 Github Actions 工作流中，我们最后都是直接使用 SSH 连接在服务器上执行命令，但是这样很不优雅，而且会被认为是服务器被异常登录&lt;/p&gt;
&lt;p&gt;所以可以尝试使用 webhook&lt;/p&gt;
&lt;p&gt;简单地说，就是先在服务器准备一个部署脚本，然后一直运行一个</description>
        
      
      
      
      <content:encoded><![CDATA[<p>在前面的 Github Actions 工作流中，我们最后都是直接使用 SSH 连接在服务器上执行命令，但是这样很不优雅，而且会被认为是服务器被异常登录</p><p>所以可以尝试使用 webhook</p><p>简单地说，就是先在服务器准备一个部署脚本，然后一直运行一个守护进程监听请求，触发 GitHub Actions 时发送请求，守护进程被收到后自动执行部署脚本</p><h1 id="准备部署脚本">准备部署脚本</h1><p>准备 <code>redeploy.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">sudo docker login --username=***** registry.cn-hangzhou.aliyuncs.com --password <span class="string">&quot;******&quot;</span></span><br><span class="line"></span><br><span class="line">sudo docker-compose pull</span><br><span class="line"></span><br><span class="line">sudo docker-compose up -d</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个很容易理解，在写完之后记得测试一下能不能成功运行</p><h1 id="编写-webhook">编写 webhook</h1><p>这里为了方便，就直接使用一个库：<a href="https://github.com/adnanh/webhook">https://github.com/adnanh/webhook</a></p><p>这东西看文档直接 apt 就能安装了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install webhook</span><br></pre></td></tr></table></figure><p>使用方法就是编写配置文件，然后运行时带上配置文件，就能根据规则监听请求</p><p>新建一个 <code>webhook.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webhook&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;execute-command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/admin/projects/github-actions-test/redeploy.sh&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command-working-directory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/admin/projects/github-actions-test&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;trigger-rule&quot;</span><span class="punctuation">:</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;parameter&quot;</span><span class="punctuation">:</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;url&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;token&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>简单地说就是规定了执行的脚本，还有触发条件：url 中有 <code>token</code> 参数并且值为 <code>1234567</code> 时就触发</p><p>这东西还有很多高级用法，比如传参数给脚本，具体可以看文档，这里就不演示了</p><p>先测试一下运行效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webhook -hooks webhook.json -verbose</span><br></pre></td></tr></table></figure><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202301041903842.png" alt="image-20230104190325333"></p><p>然后手动请求一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">&quot;http://www.nickxu.top:9000/hooks/webhook?token=1234567&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202301041906287.png" alt="image-20230104190615260"></p><p>看来成功执行了脚本</p><p>现在就用 <a href="/2022/02/15/%E3%80%8ELinux%E3%80%8Fscreen-%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95/">screen</a> 或者其他方法让这东西跑在后台就行</p><h1 id="修改-GitHub-Actions-脚本">修改 GitHub Actions 脚本</h1><p>接下来的过程就显而易见了，在 GitHub Actions 脚本中加上这个请求就行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Webhook</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">curl</span> <span class="string">--location</span> <span class="string">--request</span> <span class="string">GET</span> <span class="string">&#x27;$<span class="template-variable">&#123;&#123; secrets.WEBHOOK_URL &#125;&#125;</span>&#x27;</span> </span><br></pre></td></tr></table></figure><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202301041922078.png" alt="image-20230104192204053"></p>]]></content:encoded>
      
      
      <category domain="https://www.nickxu.top/categories/%E8%BF%90%E7%BB%B4/">运维</category>
      
      <category domain="https://www.nickxu.top/categories/%E8%BF%90%E7%BB%B4/CICD/">CICD</category>
      
      
      <category domain="https://www.nickxu.top/tags/GitHub-Actions/">GitHub Actions</category>
      
      <category domain="https://www.nickxu.top/tags/CICD/">CICD</category>
      
      <category domain="https://www.nickxu.top/tags/Webhook/">Webhook</category>
      
      
      <comments>https://www.nickxu.top/2022/12/19/%E3%80%8ECI-CD%E3%80%8F%E4%BD%BF%E7%94%A8Webhook%E9%80%9A%E7%9F%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>『CI/CD』结合GitHub Actions+Docker实现自动化部署</title>
      <link>https://www.nickxu.top/2022/12/14/%E3%80%8ECI-CD%E3%80%8F%E7%BB%93%E5%90%88GitHub-Actions-Docker%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</link>
      <guid>https://www.nickxu.top/2022/12/14/%E3%80%8ECI-CD%E3%80%8F%E7%BB%93%E5%90%88GitHub-Actions-Docker%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</guid>
      <pubDate>Wed, 14 Dec 2022 07:42:48 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;上一篇 &lt;a href=&quot;/2022/12/09/%E4%BD%BF%E7%94%A8GitHub-Actions%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A</description>
        
      
      
      
      <content:encoded><![CDATA[<p>上一篇 <a href="/2022/12/09/%E4%BD%BF%E7%94%A8GitHub-Actions%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/">『CI/CD』使用GitHub Actions实现简单的自动化部署 </a> 中实现了简单的自动化部署，本篇来介绍一下使用 docker 的做法 （NX 整整折腾了两天呢）</p><hr><h1 id="基本流程">基本流程</h1><p>首先要明确一下最终的运行流程，一共有4个步骤</p><ol><li>更新代码，提交至GitHub</li><li>GitHub 触发 Actions，自动 build 镜像，并推送至镜像仓库</li><li>服务器拉取最新镜像</li><li>重新启动容器</li></ol><p>因为今天时间有点紧我就不画图了（明天赶回家，要收拾东西）</p><hr><h1 id="本地原生运行测试">本地原生运行测试</h1><p>首先第一步要介绍一下我们的项目，还是上次的仓库：<a href="https://github.com/NX-Official/github-actions-test">https://github.com/NX-Official/github-actions-test</a> ，当然啦，现在是 <code>v3</code> 分支</p><p>为了方便我本次使用一个 go-zero 的 demo，<a href="https://go-zero.dev/cn/docs/goctl/other">因为它来生成 Dockerfile 比较方便</a></p><p>首先和文档一样创建一个 hello 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goctl api new hello</span><br></pre></td></tr></table></figure><p>为了模拟可能的业务场景，我现在给这个 demo 增加两个要求：</p><ul><li>我这个项目需要使用 mysql 和 redis 等服务，但是 docker 中的 mysql 会对性能造成影响，我可能需要直接使用宿主机上的端口与服务</li><li>本地测试环境和实际环境有不同，我希望到时候能从宿主机的某个目录读取配置文件，而不是打包在一起</li></ul><p>所以我在这个 dome 中连接了 <code>127.0.0.1</code> 的 mysql 和 redis 服务，并从文件中读取配置，你可以在项目中看见</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141618888.png" alt="image-20221214161805856"></p><p>现在，我在 <code>hello</code> 目录下原生运行本项目，没有问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run hello.go</span><br></pre></td></tr></table></figure><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141619878.png" alt="image-20221214161946849"></p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141620396.png" alt="image-20221214162038371"></p><h1 id="本地打包-运行测试">本地打包&amp;运行测试</h1><p>接下来，用 docker 打包试试</p><p>使用 go-zero 的 goctl 工具可以方便地将当前项目打包（如果你不是 go-zero 你就得自己写 <code>Dockerfile</code> 了，有关教程烂大街，不属于本节内容）</p><ul><li>在 <code>hello</code> 目录下一键生成 <code>Dockerfile</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goctl docker -go hello.go</span><br></pre></td></tr></table></figure><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141630594.png" alt="image-20221214163025558"></p><p>为了方便与整洁，我选择使用 docker-compose 来构建运行，而不是在命令行手动折腾一堆参数</p><p>在项目根目录新建 <code>docker-compose.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.5&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">hello-api:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">hello/Dockerfile</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8888:8888&quot;</span></span><br><span class="line">    <span class="attr">stdin_open:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后运行，你就会发现</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141632654.png" alt="image-20221214163247625"></p><p>在容器里是不能使用 <code>127.0.0.1</code> 来访问宿主机的本地服务的</p><p>这个问题可以看我的另一篇 <a href="/2022/12/13/%E3%80%8EDocker%E3%80%8FDocker%E5%86%85%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%AB%AF%E5%8F%A3/">『Docker』Docker内程序如何访问宿主机的端口</a> ，结论就是要把 <code>127.0.0.1</code> 换成 <code>host.docker.internal</code></p><p>但是观察自动生成的 Dockerfile ，他是直接把配置文件打包进去了</p><p>所以要改一下，把那两行注释一下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:alpine AS builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> stage=gobuilder</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> CGO_ENABLED <span class="number">0</span></span><br><span class="line"><span class="keyword">ENV</span> GOPROXY https://goproxy.cn,direct</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27;</span> /etc/apk/repositories</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk update --no-cache &amp;&amp; apk add --no-cache tzdata</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /build</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> go.mod .</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> go.sum .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go mod download</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="comment"># COPY hello/etc /app/etc</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -ldflags=<span class="string">&quot;-s -w&quot;</span> -o /app/hello hello/hello.go</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /usr/share/zoneinfo/Asia/Shanghai /usr/share/zoneinfo/Asia/Shanghai</span></span><br><span class="line"><span class="keyword">ENV</span> TZ Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /app/hello /app/hello</span></span><br><span class="line"><span class="comment"># COPY --from=builder /app/etc /app/etc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./hello&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;etc/hello-api.yaml&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>然后运行时挂一下自己的配置文件，在根目录新建一个 <code>etc</code> 目录，在里面也弄一个 <code>hello-api.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Name:</span> <span class="string">hello-api</span></span><br><span class="line"><span class="attr">Host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">Port:</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">DBList:</span></span><br><span class="line">  <span class="attr">Mysql:</span></span><br><span class="line">    <span class="attr">Address:</span> <span class="string">host.docker.internal:3306</span></span><br><span class="line">    <span class="attr">Username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">Password:</span> <span class="string">&quot;12345678&quot;</span></span><br><span class="line">    <span class="attr">DBName:</span> <span class="string">&quot;test&quot;</span></span><br><span class="line">  <span class="attr">Redis:</span></span><br><span class="line">    <span class="attr">Address:</span> <span class="string">host.docker.internal:6379</span></span><br><span class="line">    <span class="attr">Password:</span></span><br></pre></td></tr></table></figure><p>然后修改 <code>docker-compose.yml</code> ，加上两行，把目录映射进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  - ./etc:/app/etc</span><br></pre></td></tr></table></figure><p>再运行，没有问题</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141647802.png" alt="image-20221214164728750"></p><hr><h1 id="打包上传-本机重新拉取测试">打包上传&amp;本机重新拉取测试</h1><p>现在尝试一下将这个 image 上传到托管仓库，再在服务器拉取看看能不能跑</p><p>综合考虑，打算使用阿里云的容器镜像服务</p><p>前往 <a href="https://cr.console.aliyun.com/cn-hangzhou/instances">https://cr.console.aliyun.com/cn-hangzhou/instances</a> 创建一个个人实例</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141701559.png" alt="image-20221214170130504"></p><p>然后随便创个命名空间</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141702139.png" alt="image-20221214170209112"></p><p>再在这个空间里创一个仓库</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141702223.png" alt="image-20221214170259201"></p><p>进入仓库可以看见一些提示</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141211895.png" alt="image-20221214121126876"></p><p>我们现在需要将镜像推送至阿里云，所以需要按照下面的步骤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker login --username=***** registry.cn-hangzhou.aliyuncs.com</span><br><span class="line">$ docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/****/github-actions-test:[镜像版本号]</span><br><span class="line">$ docker push registry.cn-hangzhou.aliyuncs.com/*****/github-actions-test:[镜像版本号]</span><br></pre></td></tr></table></figure><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141208170.png" alt="image-20221214120857147"></p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141210874.png" alt="image-20221214121036852"></p><p>然后我在这个测试项目中新建一个 <code>assume_server_dir</code> 目录，假设这里就是服务器上的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nx@NXsMacBook-Pro assume_server_dir % tree .</span><br><span class="line">.</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">└── etc</span><br><span class="line">    └── hello-api.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的 <code>docker-compose.yml</code> 就不能这样写了，因为这里不是构建，而是拉取，所以指定镜像地址即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.5&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">hello-api:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/****/github-actions-test:latest</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./etc:/app/etc</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8888:8888&quot;</span></span><br><span class="line">    <span class="attr">stdin_open:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>之后把本地的容器、镜像全删掉，再运行这个 docker-compose</p><p>发现可以正常拉取镜像并运行</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141733904.png" alt="image-20221214173331865"></p><hr><h1 id="服务器拉取测试">服务器拉取测试</h1><p>好了，下一步就是在服务器上拉取并测试了</p><p>但是有个问题，我用的 M1 的 MacBook ，虽然 docker 是跨平台的，但是我这里构建的镜像是 arm 架构的，服务器上拿到运行会这样</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141530706.png" alt="image-20221214153056667"></p><p>所以我需要使用 <code>docker buildx</code> 重新编译并推送（<a href="https://cloud.tencent.com/developer/article/1543689?fileGuid=0l3NVKX0BgflYN3R">参考文章：跨平台构建 Docker 镜像新姿势，x86、arm 一把梭</a> ）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker buildx create --use --name mybuilder</span><br><span class="line">docker buildx inspect mybuilder --bootstrap</span><br><span class="line">docker buildx ls</span><br><span class="line">docker buildx build -t registry.cn-hangzhou.aliyuncs.com/*****/github-actions-test:latest -f hello/Dockerfile --platform=linux/amd64 . --push</span><br></pre></td></tr></table></figure><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141758756.png" alt="image-20221214175803681"></p><p>然后再在服务器拉取运行，但是又遇到了新的问题</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141811962.png" alt="image-20221214181100918"></p><p>然后我去谷歌，算是解决了问题</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141814740.png" alt="image-20221214181431705"></p><p>现在终于跑起来了</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141828018.png" alt="image-20221214182811973"></p><h1 id="GitHub-Actions打包-服务器拉取运行">GitHub Actions打包&amp;服务器拉取运行</h1><p>好了，现在手动把环境都打通了，轮到使用 GitHub Actions 来自动化了</p><p>先来一个只推送到阿里云的版本，测试一下效果</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branch:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">v3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Docker</span> <span class="string">meta</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">meta</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">docker/metadata-action@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="comment"># list of Docker images to use as base name for tags</span></span><br><span class="line">          <span class="attr">images:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.IMAGE_URL</span> <span class="string">&#125;&#125;</span> <span class="comment"># registry.cn-hangzhou.aliyuncs.com/xxxxx/xxxxx</span></span><br><span class="line">          <span class="comment"># generate Docker tags based on the following events/attributes</span></span><br><span class="line">          <span class="attr">tags:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            type=schedule</span></span><br><span class="line"><span class="string">            type=ref,event=branch</span></span><br><span class="line"><span class="string">            type=ref,event=pr</span></span><br><span class="line"><span class="string">            type=semver,pattern=&#123;&#123;version&#125;&#125;</span></span><br><span class="line"><span class="string">            type=semver,pattern=&#123;&#123;major&#125;&#125;.&#123;&#123;minor&#125;&#125;</span></span><br><span class="line"><span class="string">            type=semver,pattern=&#123;&#123;major&#125;&#125;</span></span><br><span class="line"><span class="string">            type=sha</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">QEMU</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">docker/setup-qemu-action@v1</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Docker</span> <span class="string">Buildx</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">docker/setup-buildx-action@v1</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Login</span> <span class="string">to</span> <span class="string">Aliyun</span> <span class="string">Registry</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">docker/login-action@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">registry:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ALIYUN_REGISTRY_USERNAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ALIYUN_REGISTRY_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">push</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">docker/build-push-action@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">          <span class="attr">file:</span> <span class="string">hello/Dockerfile</span></span><br><span class="line">          <span class="attr">push:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">tags:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.meta.outputs.tags</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212161437895.png" alt="image-20221216143739869"></p><p>可以看见已经成功推送，就是 tag 打的不是 latest，这个随便了，我们在服务器也改成 v3 的版本就可以了</p><p>现在随便改动一下项目</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *HelloLogic)</span></span> Hello(req *types.Request) (resp *types.Response, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;types.Response&#123;</span><br><span class="line">Message: <span class="string">&quot;If you can see this message, it means that the service is running successfully.&quot;</span>,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后增加重启的命令</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Pull</span> <span class="string">and</span> <span class="string">run</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">appleboy/ssh-action@master</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_USER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_SECRET</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSH_PORT</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">script:</span> <span class="string">sudo</span> <span class="string">docker</span> <span class="string">login</span> <span class="string">--username=$&#123;&#123;</span> <span class="string">secrets.ALIYUN_REGISTRY_USERNAME</span> <span class="string">&#125;&#125;</span> <span class="string">-p</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ALIYUN_REGISTRY_PASSWORD</span> <span class="string">&#125;&#125;</span> <span class="string">registry.cn-hangzhou.aliyuncs.com</span> <span class="string">&amp;&amp;</span> <span class="string">cd</span> <span class="string">/home/admin/projects/github-actions-test</span> <span class="string">&amp;&amp;</span> <span class="string">docker-compose</span> <span class="string">pull</span> <span class="string">&amp;&amp;</span> <span class="string">docker-compose</span> <span class="string">up</span> <span class="string">-d</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212161515422.png" alt="image-20221216151529383"></p><p>当然啦，除了直接执行命令之外，你还可以使用 <a href="/2022/12/19/%E3%80%8ECI-CD%E3%80%8F%E4%BD%BF%E7%94%A8Webhook%E9%80%9A%E7%9F%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/">webhook</a> 来通知服务器拉取最新镜像</p><p>至此，完成自动化部署</p>]]></content:encoded>
      
      
      <category domain="https://www.nickxu.top/categories/%E8%BF%90%E7%BB%B4/">运维</category>
      
      <category domain="https://www.nickxu.top/categories/%E8%BF%90%E7%BB%B4/CICD/">CICD</category>
      
      
      <category domain="https://www.nickxu.top/tags/GitHub-Actions/">GitHub Actions</category>
      
      <category domain="https://www.nickxu.top/tags/CICD/">CICD</category>
      
      <category domain="https://www.nickxu.top/tags/Docker/">Docker</category>
      
      
      <comments>https://www.nickxu.top/2022/12/14/%E3%80%8ECI-CD%E3%80%8F%E7%BB%93%E5%90%88GitHub-Actions-Docker%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>『Docker』Docker内程序如何访问宿主机的端口</title>
      <link>https://www.nickxu.top/2022/12/13/%E3%80%8EDocker%E3%80%8FDocker%E5%86%85%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%AB%AF%E5%8F%A3/</link>
      <guid>https://www.nickxu.top/2022/12/13/%E3%80%8EDocker%E3%80%8FDocker%E5%86%85%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%AB%AF%E5%8F%A3/</guid>
      <pubDate>Tue, 13 Dec 2022 15:50:20 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;好家伙，折腾了这个问题折腾了一天，刚才终于搞定了，简直不要太高兴&lt;/p&gt;
&lt;p&gt;事情是这样的，我现在要折腾基于 Docker 的自动化部署，然后我的项目已经打包好了，但是运行起来有问题，一直说连不上 mysql&lt;/p&gt;
&lt;p&gt;然后呢？ &lt;s&gt;就递归折腾（不是）&lt;/s&gt; 我就</description>
        
      
      
      
      <content:encoded><![CDATA[<p>好家伙，折腾了这个问题折腾了一天，刚才终于搞定了，简直不要太高兴</p><p>事情是这样的，我现在要折腾基于 Docker 的自动化部署，然后我的项目已经打包好了，但是运行起来有问题，一直说连不上 mysql</p><p>然后呢？ <s>就递归折腾（不是）</s> 我就感觉肯定是网络的事情</p><p>然后就想是不是要折腾容器间通信，但是把 mysql 跑在 docker 里面肯定有不少损耗吧，问了下助手里面的大佬，结论也是这样</p><p>那么，现在的问题就是，<strong>如何让 Docker内程序如何访问宿主机的端口</strong></p><p>然后我就去搜哇，看各种文章博客去各种平台，还看了些项目，看他们是怎么解决的</p><p>但是助手的项目自然都是读服务器上的配置文件，我也看不见</p><p>去看 docker 相关的教程，但都感觉好像没遇见这个问题一样，提都不提</p><p>去网上查这个问题，有的说就 docker 启动的时候有个网卡，然后直接连它的 ip 就行，但是我没搞定</p><p>有的说启动的时候指定 host 模式，这个在 Linux 上的确可以（当然是后面发现的），但是我在 Mac 上不行，也没报错，就这样又折腾了好久</p><p>然后去翻官方文档这是个什么玩意，然后我就看见了</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212140026968.png" alt="c3ef83a8de294fa7f758b48cf8d399d0"></p><p>没事了，人麻了</p><p>然后我在服务器上尝试，的确这个 host 是可以的，但是我不相信 Windows和Mac就没有好的方法</p><p>最后去谷歌一趟，奶奶的，一分钟搞定</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212132356228.png" alt="image-20221213235613721"></p><p>如图所示，简直不要太简单，直接用 <code>host.docker.internal</code> 即可</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212132357177.png" alt="image-20221213235716153"></p><p>然后看见访问的实际是 <code>192.168.65.2</code> ，我就想到了这篇</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212140033951.png" alt="image-20221214003307913"></p><p>的确，貌似和我的 <code>192.168.65.0 </code>  一个网段，但是并不和它说的一样</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212140034333.png" alt="image-20221214003410287"></p><p>国内什么垃圾互联网啊🤔（迫真</p><blockquote><p>PS：如果遇到这种情况</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212141811962.png" alt="image-20221214181100918"></p><p>请在你的 <code>docker-compose.yml</code> 的服务中加上</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extra_hosts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;host.docker.internal:host-gateway&quot;</span></span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.5&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">hello-api:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">hello/Dockerfile</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./etc:/app/etc</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8888:8888&quot;</span></span><br><span class="line">    <span class="attr">stdin_open:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">extra_hosts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;host.docker.internal:host-gateway&quot;</span></span><br></pre></td></tr></table></figure><p>来源：<a href="https://stackoverflow.com/questions/70505750/lookup-host-docker-internal-no-such-host">https://stackoverflow.com/questions/70505750/lookup-host-docker-internal-no-such-host</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://www.nickxu.top/categories/%E8%BF%90%E7%BB%B4/">运维</category>
      
      <category domain="https://www.nickxu.top/categories/%E8%BF%90%E7%BB%B4/Docker/">Docker</category>
      
      
      <category domain="https://www.nickxu.top/tags/Docker/">Docker</category>
      
      
      <comments>https://www.nickxu.top/2022/12/13/%E3%80%8EDocker%E3%80%8FDocker%E5%86%85%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%AB%AF%E5%8F%A3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>设置在使用 SSH key 时不用再输入密码</title>
      <link>https://www.nickxu.top/2022/12/10/%E8%AE%BE%E7%BD%AE%E5%9C%A8%E4%BD%BF%E7%94%A8-SSH-key-%E6%97%B6%E4%B8%8D%E7%94%A8%E5%86%8D%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81/</link>
      <guid>https://www.nickxu.top/2022/12/10/%E8%AE%BE%E7%BD%AE%E5%9C%A8%E4%BD%BF%E7%94%A8-SSH-key-%E6%97%B6%E4%B8%8D%E7%94%A8%E5%86%8D%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81/</guid>
      <pubDate>Sat, 10 Dec 2022 03:35:29 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;今早发生了非常尴尬的事情，我在群里抱怨怎样才能在 git ssh 的时候不用密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212101156880.png&quot; alt=&quot;cb48d</description>
        
      
      
      
      <content:encoded><![CDATA[<p>今早发生了非常尴尬的事情，我在群里抱怨怎样才能在 git ssh 的时候不用密码</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212101156880.png" alt="cb48d73493389516ba5283292da021da"></p><p>然后群u们居然告诉我：你在生成的时候不输密码就可以了！</p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212101150420.png" alt="E49300B6C2DA5315E198DB90B63517A7" style="zoom:50%;" /><p>好家伙，这么多年每天多输了这么多密码（</p><p>那要怎样重置密码为空呢？使用下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -p -f ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212101155703.png" alt="37a866d23e9e29bac4f0996a31bbe0b3"></p>]]></content:encoded>
      
      
      <category domain="https://www.nickxu.top/categories/%E6%96%B0%E6%8A%80%E8%83%BD-Got/">新技能 Got</category>
      
      
      <category domain="https://www.nickxu.top/tags/SSH/">SSH</category>
      
      
      <comments>https://www.nickxu.top/2022/12/10/%E8%AE%BE%E7%BD%AE%E5%9C%A8%E4%BD%BF%E7%94%A8-SSH-key-%E6%97%B6%E4%B8%8D%E7%94%A8%E5%86%8D%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>『CI/CD』使用GitHub Actions实现简单的自动化部署</title>
      <link>https://www.nickxu.top/2022/12/09/%E4%BD%BF%E7%94%A8GitHub-Actions%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</link>
      <guid>https://www.nickxu.top/2022/12/09/%E4%BD%BF%E7%94%A8GitHub-Actions%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</guid>
      <pubDate>Fri, 09 Dec 2022 12:17:58 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;本篇是一个 GitHub Actions 使用示例，实现在每次提交代码时自动更新你的远端服务器正在运行的项目&lt;/p&gt;
&lt;p&gt;但是我并不会从头开始向你介绍 GitHub Actions 是什么，而要求你事先对它有所了解&lt;/p&gt;
&lt;p&gt;你可以去看官方文档，去 B 站找视频看，网</description>
        
      
      
      
      <content:encoded><![CDATA[<p>本篇是一个 GitHub Actions 使用示例，实现在每次提交代码时自动更新你的远端服务器正在运行的项目</p><p>但是我并不会从头开始向你介绍 GitHub Actions 是什么，而要求你事先对它有所了解</p><p>你可以去看官方文档，去 B 站找视频看，网上有很多高质量的参考资料</p><p>简单地说就是 GitHub 可以在你更新代码或合并分支的时候开一个虚拟机帮你完成一些事情</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212092139233.jpg" alt="a054159e939a43e3ab5ff2406081ed6d"></p><blockquote><p>又或者，你也可以去问 ChatGPT，哈哈😄</p></blockquote><p>那为什么说是“简单的”呢？因为本篇只会举一个很简单的例子，不会涉及 docker ，也没有 k3s 集群</p><p>本篇的例子可以在我的仓库找到：<a href="https://github.com/NX-Official/github-actions-test">https://github.com/NX-Official/github-actions-test</a></p><p>为了将重点放在部署上，我以下面的 <code>main.go</code> 为例，它只显示一个简单的 <code>hello world</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   r := gin.Default()</span><br><span class="line"></span><br><span class="line">   r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">      c.String(<span class="number">200</span>, <span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前的项目结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">└── main.go</span><br></pre></td></tr></table></figure><hr><h1 id="我该如何部署？">我该如何部署？</h1><p>现在来思考一个问题，我该部署到远程服务器</p><p>看了一圈助手里面的项目，大概有两种方案：</p><ol><li>不在虚拟机上编译，直接 ssh 连接服务器，执行命令或一个脚本文件来自动拉取最新代码，编译文件并完成替换</li><li>直接在 GitHub 的虚拟机上完成编译，得到二进制文件，然后把文件送到我们的服务器上（直接转送可能很慢，我看有的项目是先放到 OSS 上，然后用一个 webhook 通知守护进程，去拉取文件并完成替换）</li></ol><p>我两种都会演示一下，先来第一种，使用 ssh 直接连接服务器，并执行下面的步骤：</p><ul><li><p>使用 <code>git pull</code> 拉取最新代码</p></li><li><p>运行一个自动编译与重新启动的脚本</p></li></ul><hr><h1 id="服务器端的准备">服务器端的准备</h1><p>现在来动手实践，首先我们先将项目克隆下来（这里当然是我自己的项目）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/NX-Official/github-actions-test.git</span><br></pre></td></tr></table></figure><p>然后尝试编译并执行（当然啦，你要先安装 golang）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> github-actions-test</span><br><span class="line">go mod tidy</span><br><span class="line">go build main.go</span><br><span class="line">./main</span><br></pre></td></tr></table></figure><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212092207341.png" alt=""></p><p>看来是没问题的</p><p>现在，为了更方便地运行项目，我们可以将我们的程序注册为一个服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/systemd/system/</span><br><span class="line">nano github-actions-test.service</span><br></pre></td></tr></table></figure><p>然后写入下面的代码（你需要根据自己的项目来修改名称与路径）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=github-actions-test</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/root/github-actions-test/main</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后使用下面的命令运行与查询状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start github-actions-test</span><br><span class="line">systemctl status github-actions-tes</span><br></pre></td></tr></table></figure><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212092224357.png" alt="image-20221209222401325"></p><p>没有问题，继续下面的步骤</p><hr><h1 id="定义-Actions-secrets">定义 Actions secrets</h1><p>要连接到服务器，必定需要用户名和密码（当然你也可以使用私钥之类的，但这里为了简单我就使用密码）</p><p>但是密码这种东西你肯定不能直接写在 <code>build.yml</code> 中，你肯定不想让别人翻你的项目的时候翻到你服务器的密码吧～</p><p>所以 GitHub 就有了 Actions secrets 这个东西，你可以在这里定义运行时的环境变量，并只有项目参与者才能修改</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212092241016.png" alt="image-20221209224126982"></p><p>在这里定义好三个变量，就可以在下面的脚本中使用了</p><hr><h1 id="编写脚本">编写脚本</h1><p>为了方便，现在来为这个项目写一个重启服务的脚本，保存为 <code>run.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">serviceName=<span class="string">&quot;github-actions-test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">systemctl stop <span class="variable">$serviceName</span></span><br><span class="line"><span class="built_in">rm</span> main -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新编译</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/go/bin</span><br><span class="line">go mod tidy</span><br><span class="line">go build main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl start <span class="variable">$serviceName</span></span><br><span class="line">systemctl status <span class="variable">$serviceName</span></span><br></pre></td></tr></table></figure><p>现在在项目中创建 <code>.github/workflow</code> 目录 ，再在里面建一个 <code>build.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">直接在服务器执行命令</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">appleboy/ssh-action@master</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_USER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_SECRET</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">script:</span> <span class="string">cd</span> <span class="string">~/github-actions-test</span> <span class="string">&amp;&amp;</span> <span class="string">git</span> <span class="string">pull</span> <span class="string">&amp;&amp;</span> <span class="string">bash</span> <span class="string">run.sh</span></span><br></pre></td></tr></table></figure><p>这意味着将在 <code>push</code> 到 <code>main</code> 分支的时候，自动连接服务器并执行最下面的命令</p><p>现在来对 <code>main.go</code> 做一些修改，测试一下自动化部署对效果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.String(<span class="number">200</span>, <span class="string">&quot;Hello World, I&#x27;m a Gin server&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后提交并推送，观察发现脚本已经成功运行</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212092308844.png" alt="image-20221209230812804"></p><p>刷新页面，看见已经成功重新编译并启动服务</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212092308742.png" alt="image-20221209230856708"></p><hr><h1 id="另一种方案">另一种方案</h1><p>下面来试一下另一种方案，为了区分开来，我新建了一个 <code>v2</code> 分支</p><p>然后修改脚本</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branch:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">v2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Golang</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-go@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">go-version:</span> <span class="string">&#x27;1.19&#x27;</span></span><br><span class="line">          <span class="attr">cache:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">go</span> <span class="string">build</span> <span class="string">main.go</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">SSH_USERNAME:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_USER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">SSH_PASSWORD:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_SECRET</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">SSH_PORT:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSH_PORT</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">DEPLOY_HOST:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">DEPLOY_PATH:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_PATH</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          # Stop the service</span></span><br><span class="line"><span class="string">          sshpass -p $SSH_PASSWORD ssh -o StrictHostKeyChecking=no $SSH_USERNAME@$DEPLOY_HOST -p $SSH_PORT &quot;systemctl stop github-actions-test &amp;&amp; rm -rf $DEPLOY_PATH/main&quot;</span></span><br><span class="line"><span class="string"></span>          </span><br><span class="line">          <span class="comment"># Copy the binary to the remote server</span></span><br><span class="line">          <span class="string">sshpass</span> <span class="string">-p</span> <span class="string">$SSH_PASSWORD</span> <span class="string">scp</span> <span class="string">-r</span> <span class="string">-o</span> <span class="string">StrictHostKeyChecking=no</span> <span class="string">-P</span> <span class="number">47</span> <span class="string">main</span> <span class="string">root@www.nickxu.top:/root/github-actions-test</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment"># Restart the service on the remote server</span></span><br><span class="line">          <span class="string">sshpass</span> <span class="string">-p</span> <span class="string">$SSH_PASSWORD</span> <span class="string">ssh</span> <span class="string">-o</span> <span class="string">StrictHostKeyChecking=no</span> <span class="string">$SSH_USERNAME@$DEPLOY_HOST</span> <span class="string">-p</span> <span class="string">$SSH_PORT</span> <span class="string">&quot;systemctl start github-actions-test&quot;</span></span><br></pre></td></tr></table></figure><p><code>Checkout</code> 指的是拉取你的代码，然后后面设置 go 版本，编译，部署</p><p>同时修改一下 <code>main.go</code> ，这样可以对比出不同</p><p>然后提交，看看结果</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212102317802.png" alt="image-20221210231722735"></p><p>十分顺利</p><p>这里我的例子是将编译和部署写在一个文件中的，其实你可以拆分成两个，这样更加规整，这个就留给你来折腾了😄</p>]]></content:encoded>
      
      
      <category domain="https://www.nickxu.top/categories/%E8%BF%90%E7%BB%B4/">运维</category>
      
      <category domain="https://www.nickxu.top/categories/%E8%BF%90%E7%BB%B4/CICD/">CICD</category>
      
      
      <category domain="https://www.nickxu.top/tags/GitHub-Actions/">GitHub Actions</category>
      
      <category domain="https://www.nickxu.top/tags/CICD/">CICD</category>
      
      
      <comments>https://www.nickxu.top/2022/12/09/%E4%BD%BF%E7%94%A8GitHub-Actions%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>『C/C++』一文初识Makefile与CMake</title>
      <link>https://www.nickxu.top/2022/12/01/%E3%80%8EC-C-%E3%80%8F%E4%B8%80%E6%96%87%E5%88%9D%E8%AF%86Makefile%E4%B8%8ECMake/</link>
      <guid>https://www.nickxu.top/2022/12/01/%E3%80%8EC-C-%E3%80%8F%E4%B8%80%E6%96%87%E5%88%9D%E8%AF%86Makefile%E4%B8%8ECMake/</guid>
      <pubDate>Thu, 01 Dec 2022 02:12:51 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;本文来源于 B 站视频，鄙人只是跟着做一下笔记：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV188411L7d2/?spm_id_from=333.1007.top_right_b</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>本文来源于 B 站视频，鄙人只是跟着做一下笔记：</p><ul><li><a href="https://www.bilibili.com/video/BV188411L7d2/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&amp;vd_source=e2613baf768b2432fcb2b9edd79c0c68">Makefile 20分钟入门，简简单单，展示如何使用Makefile管理和编译C++代码</a></li><li><a href="https://www.bilibili.com/video/BV1bg411p7oS/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=e2613baf768b2432fcb2b9edd79c0c68">CMake 6分钟入门，不用再写复杂的Makefile</a></li></ul><p>感觉这个老师讲的真的好 <s>，要是杭电也都是这样的的老师就好了（</s></p></blockquote><hr><h1 id="编译链接的预备知识">编译链接的预备知识</h1><p>在手动编译一些 C/C++ 项目时，你会经常遇到下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>这两个都是用来管理和编译 C/C++ 项目的工具，本文将浅浅地介绍这两个工具的使用</p><p>首先引出一个小项目作为例子，项目结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./</span><br><span class="line">├── factorial.cpp</span><br><span class="line">├── function.h</span><br><span class="line">├── main.cpp</span><br><span class="line">└── printhello.cpp</span><br></pre></td></tr></table></figure><p>目前共有 4 个文件，首先来看 <code>printhello.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printhello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个很简单的文件，仅有一个 <code>printhello()</code> 函数，功能也很简单</p><p>但请记住这个定义了但没使用 <code>i</code> 变量，后面会出场</p><p>接着看 <code>factorial.cpp</code> ，它包含一个简单的递归函数，用于求阶乘</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看 <code>function.h</code> ，它将上面两个函数注册其中，供下面的主函数调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FUNCTIONS_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _FUNCTIONS_H_</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printhello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>最后来看 <code>main.cpp</code> ，它通过引用头文件，调用了最开始的两个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printhello</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is main:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The factorial of 5 is :&quot;</span> &lt;&lt; <span class="built_in">factorial</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，我们现在有两个函数分别定义在不同的文件中，并且在主函数中调用了他们</p><p>所有的函数定义都写在头文件中，<code>main.cpp</code> 引用了该头文件，就能调用那两个函数</p><p>那么现在要编译这个项目，一个最偷懒的方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp factorial.cpp printhello.cpp -o main</span><br></pre></td></tr></table></figure><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212080917831.png" alt=""></p><p>那这样的确可以成功运行，但如果源文件很多的话怎么办？文件一多，如果每次都要一起编译，就很浪费时间</p><p>一种省时间的方式是不一起来编译，而是分别编译，生成目标文件，最后再手动链接在一起</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ -c main.cpp </span><br><span class="line">g++ -c factorial.cpp</span><br><span class="line">g++ -c printhello.cpp</span><br><span class="line">g++ *.o -o main</span><br></pre></td></tr></table></figure><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212080917363.png" alt="image-20221201111659502"></p><p>也就是说，在源文件很多的时候，可以只单独编译修改了的文件，然后再链接在一起，这样就可以省下其他文件的编译时间</p><p>那现在又有一个问题了，在文件很多的情况下，每次都手动输入这些命令是不是很麻烦</p><p>那这个过程其实完全可以写在一个脚本文件里面，一种通用的格式就叫 <code>Makefile</code></p><hr><h1 id="Makefile">Makefile</h1><p>首先在当前目录新建一个 <code>Makefile</code> 文件（就叫这个名字），在里面编写脚本</p><p>下面来看看几个脚本版本，由浅入深地理解</p><h2 id="VERSION-1">VERSION 1</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## VERSION 1</span></span><br><span class="line"><span class="section">hello: main.cpp printhello.cpp factorial.cpp</span></span><br><span class="line">g++ -o hello main.cpp printhello.cpp factorial.cpp</span><br></pre></td></tr></table></figure><p>这是一个最基本最简单的 <code>Makefile</code> ，<code>hello</code> 指生成的可执行文件叫 hello ，冒号后面的内容是依赖，也就是说 hello 依赖于后面的几个 cpp 文件</p><p>而下面一行，首先是一个 Tab（不能是空格） ，然后是生成目标的命令 <code>g++ -o hello main.cpp printhello.cpp factorial.cpp</code></p><p>也就是说</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## VERSION 1</span></span><br><span class="line"><span class="section">hello: hello 的依赖</span></span><br><span class="line">hello 的生成命令</span><br></pre></td></tr></table></figure><p>那写了 <code>Makefile</code> 之后怎么编译呢？先把之前临时文件都清除，然后使用 <code>make</code> 命令</p><p><code>make</code> 会自动在当前目录下找 Makefile 文件，当然你也可以使用 <code>-f</code> 参数手动指定文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -f Makefile</span><br></pre></td></tr></table></figure><p>这样就能自动编译文件了</p><p>而如果你再运行一次，你就会发现它会返回下面的内容</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212080917839.png" alt="image-20221201113637495"></p><p>这是因为 <code>make</code> 发现 <code>hello</code> 的修改日期比它的依赖都新，也就没有重新生成的必要了</p><p>这时给 <code>main.cpp</code> 加个空格修改一下，那么它的修改时间就比 <code>hello</code> 更新了，就需要重新生成，这个命令就会智能地重新运行</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212080917757.png" alt="image-20221201114037810"></p><p>这是第一个版本，这个版本的缺点也很明显，就是如果我每多一个文件，就要修改一次 <code>Makefile</code> ，文件一多也不好管理，而且它的生成命令也是最原始最偷懒的版本，所有文件一起编译</p><p>下面来看第二个版本</p><h2 id="VERSION-2">VERSION 2</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## VERSION 2</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">OBJ = main.o printhello.o factorial.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line"><span class="variable">$(CXX)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJ)</span></span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.cpp</span></span><br><span class="line"><span class="variable">$(CXX)</span> -c main.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">printhello.o: printhello.cpp</span></span><br><span class="line"><span class="variable">$(CXX)</span> -c printhello.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">factorial.o: factorial.cpp</span></span><br><span class="line"><span class="variable">$(CXX)</span> -c factorial.cpp</span><br></pre></td></tr></table></figure><p>VERSION 2 看上去就更加地专业</p><p>首先定义了三个变量 <code>CXX</code>、<code>TARGET</code> 和 <code>OBJ </code>，其中 <code>OBJ</code> 包括3个元素</p><p>然后是 <code>TARGET</code> 依赖于 <code>OBJ</code> ，被依赖的文件如果没有生成，就会向下查找它依赖的文件，以及是怎么生成的，基本是个递归的过程，最终把每个目标都生成出来</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212080917897.png" alt="image-20221201120949016"></p><p>现在把 <code>main.cpp</code> 做一点修改，再调用 <code>make</code> 命令</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212080917062.png" alt="image-20221201121127034"></p><p>会发现只会编译你修改的文件，然后就去链接了，节省编译的时间</p><p>接下来是第3个版本，又升级了一下</p><h2 id="VERSION-3">VERSION 3</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## VERSION 3</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">OBJ = main.o printhello.o factorial.o</span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall <span class="comment">#显示警告信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $@表示目标文件，$^表示所有的依赖文件</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line"><span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># $&lt;表示第一个依赖文件，$@表示目标文件</span></span><br><span class="line"><span class="section">%.o: %.cpp </span></span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span> </span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean # 伪目标，不是文件名</span></span><br><span class="line"><span class="section">clean:  # 清除所有的.o文件</span></span><br><span class="line">rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>其中，<code>$@</code> 就是 <code>TARGET</code> ，就是冒号前面的东西；<code>$^</code> 就是依赖，就是冒号后面的内容，也就是 OBJ ，也就是少写了一些变量；<code>%&lt;</code> 指的是依赖的第一个，但是这里其实也只有一个，也无所谓（</p><p>现在来运行一下，发现出现了警告，这是 <code>-Wall</code>  参数的作用，将所有的编译参数放在一起，可以方便日后修改</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212080917755.png" alt="image-20221207230448335"></p><p>而下面的</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean # 伪目标，不是文件名</span></span><br><span class="line"><span class="section">clean:  # 清除所有的.o文件</span></span><br><span class="line">rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>是为了实现一个 <code>make clean</code> 的功能，也就是清空所有非源码文件</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212080917407.png" alt="image-20221207230644017"></p><p>可以这样来理解：我现在有一个 <code>clean</code> 目标，当我 <code>make clean</code> 的时候就会去执行对应的生成指令</p><p>当然啦，并没有什么 <code>clean</code> 文件，只是去骗它来执行 <code>rm -f *.o $(TARGET)</code> 这条命令罢了哈哈哈</p><p>然后为什么要有一行 <code>.PHONY: clean</code> 捏，这是因为如果当前目录正好有一个 <code>clean</code> 文件，那就不会被骗去执行生成命令了</p><p>而又有一个 <code>.PHONY</code> 目标依赖于 <code>clean</code> ，即使当前有一个 <code>clean</code> ，<code>.PHONY</code> 还是不存在的（其实这东西永远也不会存在），那么还是会去调用 <code>clean</code> 的生成命令，也就被骗去执行了那条指令</p><p>现在，如果又要加新文件，只要在 <code>OBJ</code> 变量后面加文件名就好了，但是这样还不是最方便的，最方便的应当是自动编译目录下的所有文件</p><h2 id="VERSION-4">VERSION 4</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## VERSION 4</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span> <span class="comment"># 所有的.cpp文件</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(SRC)</span>)</span> <span class="comment"># 所有的.o文件，</span></span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall <span class="comment">#显示警告信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $@表示目标文件，$^表示所有的依赖文件</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line"><span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># $&lt;表示第一个依赖文件，$@表示目标文件</span></span><br><span class="line"><span class="section">%.o: %.cpp </span></span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span> </span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean # 伪目标，不是文件名</span></span><br><span class="line"><span class="section">clean:  # 清除所有的.o文件</span></span><br><span class="line">rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>这个版本只变动了一个地方，也就是 <code>SRC</code> 和 <code>OBJ</code> 两个变量那里</p><p>首先使用 <code>wildcard</code> 函数来找到当前目录下所有的 <code>.cpp</code> 文件</p><p>然后下面使用 <code>patsubst</code> 函数，也就是 pattern substitution</p><p>后面跟 3 个参数：要替换的模式，替换的内容，要替换的文本</p><p>也就是吧 <code>SRC</code> 中的 <code>.cpp</code> 全部换成 <code>.o</code> ，那么也就是对应的目标文件的路径</p><p>这样一来，就能实现上面说的功能了</p><hr><h1 id="CMake">CMake</h1><p><code>Makefile</code> 有一个致命的问题，就是与当前的开发环境强相关，比如到其他系统可能会出现编译器不同、路径不同等等各种问题</p><p><code>CMake</code> 就是解决这种问题的工具（当然也还有很多同类型的工具），让你能够跨平台地生成自动生成 <code>Makefile</code> 文件</p><p>还是上面的例子，我们来用 CMake ，先创建一个 <code>CMakeLists.txt</code> 文件</p><p>然后很简单，只用三行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(hello)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(hello main.cpp factorial.cpp printhello.cpp)</span><br></pre></td></tr></table></figure><p>首先指定最低版本，然后说现在有一个 <code>project</code> 叫 <code>hello</code> ，再加上可执行程序 <code>hello</code> ，并且加上依赖的 <code>cpp</code> 就好了</p><p>然后使用 <code>cmake .</code> 来自动生成</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212080917482.png" alt="image-20221207235620692"></p><p>可以看见生成了不少东西，有一些缓存文件，还有个目录，当然还有个 <code>Makefile</code></p><p>如果你去看这个文件，你会发现非常之长</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212080917573.png" alt="image-20221207235853644"></p><p>非常长，不管了，现在来用一下看看</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202212080917075.png" alt="image-20221208000015566"></p><p>可以的，现在可以实现我们的目标了：跨平台地编译</p><p>然后现在发现多了很多相关的文件，如果都需要手动清理，就很麻烦</p><p>于是，就有了下面这种操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build </span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>这样，所有生成的文件就只在这个 <code>build</code> 目录里面，删起来就很方便</p><p>这也就是很多软件在 <code>cmake</code> 之前会创建一个目录的原因</p>]]></content:encoded>
      
      
      <category domain="https://www.nickxu.top/categories/Golang/">Golang</category>
      
      <category domain="https://www.nickxu.top/categories/Golang/%E8%AF%AD%E6%B3%95%E9%80%9F%E9%80%9A/">语法速通</category>
      
      
      <category domain="https://www.nickxu.top/tags/C-C/">C/C++</category>
      
      <category domain="https://www.nickxu.top/tags/Makefile/">Makefile</category>
      
      <category domain="https://www.nickxu.top/tags/CMake/">CMake</category>
      
      
      <comments>https://www.nickxu.top/2022/12/01/%E3%80%8EC-C-%E3%80%8F%E4%B8%80%E6%96%87%E5%88%9D%E8%AF%86Makefile%E4%B8%8ECMake/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang 语法速通指南（十）函数之进阶使用</title>
      <link>https://www.nickxu.top/2022/11/23/Golang-%E8%AF%AD%E6%B3%95%E9%80%9F%E9%80%9A%E6%8C%87%E5%8D%97%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%BD%E6%95%B0%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/</link>
      <guid>https://www.nickxu.top/2022/11/23/Golang-%E8%AF%AD%E6%B3%95%E9%80%9F%E9%80%9A%E6%8C%87%E5%8D%97%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%BD%E6%95%B0%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/</guid>
      <pubDate>Wed, 23 Nov 2022 08:17:58 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;函数进阶一点的使用，就是将函数当作一个变量&lt;/p&gt;
&lt;h2 id=&quot;函数类型&quot;&gt;函数类型&lt;/h2&gt;
&lt;p&gt;若要将函数作为变量，那自然是有类型的&lt;/p&gt;
&lt;p&gt;那函数的类型是怎样的呢？一个函数的类型就是它的签名（名称、入参列表、出参列表）&lt;/p&gt;
&lt;p&gt;签名一样的函数，类型就</description>
        
      
      
      
      <content:encoded><![CDATA[<p>函数进阶一点的使用，就是将函数当作一个变量</p><h2 id="函数类型">函数类型</h2><p>若要将函数作为变量，那自然是有类型的</p><p>那函数的类型是怎样的呢？一个函数的类型就是它的签名（名称、入参列表、出参列表）</p><p>签名一样的函数，类型就一样</p><p>例如定义一个 add 函数，然后打印它的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T&quot;</span>, add) <span class="comment">// func(int, int) int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然函数也是一种变量，那么肯定是可以相互赋值的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br><span class="line">   <span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">   f = add</span><br><span class="line">   fmt.Println(f(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然了，你也可以给函数类型起别名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFuncType <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> f MyFuncType</span><br><span class="line">   f = add</span><br><span class="line">   fmt.Println(f(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数类型的零值是 <code>nil</code> ，你可以将函数变量与 <code>nil</code> 比较，但函数变量之间是不能比较的</p><h2 id="函数作为参数或返回值">函数作为参数或返回值</h2><p>当你知道了函数也可以作为变量之后，你就能理解将函数作为参数或者返回值的做法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> x - y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="type">int</span>, op MyFuncType)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> op(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="built_in">println</span>(calc(<span class="number">1</span>, <span class="number">2</span>, add))</span><br><span class="line">   <span class="built_in">println</span>(calc(<span class="number">1</span>, <span class="number">2</span>, sub))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名函数">匿名函数</h2><p>众所周知函数内部是不能再定义函数的，但匿名函数例外</p><p>匿名，顾名思义也就是没有名字，下面是一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   f() <span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你也可以定义出来就直接运行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">   &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包">闭包</h2><p>闭包的本质是一个函数和与其相关的引用环境组合的一个整体（实体）</p><p>闭包的引用环境包括了：闭包函数内部的非全局变量、常量、函数等</p><p>请看下面的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closure</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      x++</span><br><span class="line">      <span class="built_in">println</span>(x)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   f := closure()</span><br><span class="line">   f() <span class="comment">// 1</span></span><br><span class="line">   f() <span class="comment">// 2</span></span><br><span class="line">   f() <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>closure()</code> 中的匿名函数尝试使用 <code>x</code> 变量的时候，在本身找不到，就会向外找，访问到外层的变量并进行修改</p><p>这样每次调用 <code>closure()</code> 都会改变 <code>x</code> 的值，所以输出的结果是 1、2、3</p><h2 id="延迟调用">延迟调用</h2><p>当执行到 defer 语句时，函数和参数表达式将得到计算，但会留在本函数退出时再执行</p><p>并且遵从栈式结构顺序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer 1&quot;</span>)</span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer 2&quot;</span>)</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="comment">// defer 2</span></span><br><span class="line"><span class="comment">// defer 1</span></span><br></pre></td></tr></table></figure><p>更多的细节可以看这篇</p><p><a href="https://blog.csdn.net/m0_46251547/article/details/123762669">https://blog.csdn.net/m0_46251547/article/details/123762669</a></p>]]></content:encoded>
      
      
      <category domain="https://www.nickxu.top/categories/Golang/">Golang</category>
      
      <category domain="https://www.nickxu.top/categories/Golang/%E8%AF%AD%E6%B3%95%E9%80%9F%E9%80%9A/">语法速通</category>
      
      
      <category domain="https://www.nickxu.top/tags/Go/">Go</category>
      
      
      <comments>https://www.nickxu.top/2022/11/23/Golang-%E8%AF%AD%E6%B3%95%E9%80%9F%E9%80%9A%E6%8C%87%E5%8D%97%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%BD%E6%95%B0%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>『Go』使用 grpc 时传递错误的一种方法</title>
      <link>https://www.nickxu.top/2022/11/20/%E3%80%8EGo%E3%80%8F%E4%BD%BF%E7%94%A8-grpc-%E6%97%B6%E4%BC%A0%E9%80%92%E9%94%99%E8%AF%AF%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95/</link>
      <guid>https://www.nickxu.top/2022/11/20/%E3%80%8EGo%E3%80%8F%E4%BD%BF%E7%94%A8-grpc-%E6%97%B6%E4%BC%A0%E9%80%92%E9%94%99%E8%AF%AF%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95/</guid>
      <pubDate>Sun, 20 Nov 2022 04:03:46 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;折腾了一天，算是找到了一种解决方法&lt;/p&gt;
&lt;p&gt;就是我现在需要在调用 rpc 时传递全局错误，我定义的全局错误如下&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas</description>
        
      
      
      
      <content:encoded><![CDATA[<p>折腾了一天，算是找到了一种解决方法</p><p>就是我现在需要在调用 rpc 时传递全局错误，我定义的全局错误如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rpcError</span><br><span class="line"></span><br><span class="line"><span class="comment">// RpcError rpc 错误，参考了 https://junedayday.github.io/2021/05/07/go-tip/go-tip-3/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Code <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">ErrPersonNotExistCode Code = <span class="literal">iota</span> + <span class="number">1000</span></span><br><span class="line">ErrPersonCreateFailedCode</span><br><span class="line">ErrPersonUpdateFailedCode</span><br><span class="line">ErrPersonDeleteFailedCode</span><br><span class="line"></span><br><span class="line">ErrClassNotExistCode Code = <span class="literal">iota</span> + <span class="number">2000</span></span><br><span class="line">ErrClassCreateFailedCode</span><br><span class="line">ErrClassUpdateFailedCode</span><br><span class="line">ErrClassDeleteFailedCode</span><br><span class="line">ErrClassGetListFailedCode</span><br><span class="line"></span><br><span class="line">ErrRedisSetFailedCode Code = <span class="literal">iota</span> + <span class="number">3000</span></span><br><span class="line">ErrRedisGetFailedCode</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> errCodeMap = <span class="keyword">map</span>[Code]<span class="type">string</span>&#123;</span><br><span class="line">ErrPersonNotExistCode:     <span class="string">&quot;用户不存在&quot;</span>,</span><br><span class="line">ErrPersonCreateFailedCode: <span class="string">&quot;用户创建失败&quot;</span>,</span><br><span class="line">ErrPersonUpdateFailedCode: <span class="string">&quot;用户更新失败&quot;</span>,</span><br><span class="line">ErrPersonDeleteFailedCode: <span class="string">&quot;用户删除失败&quot;</span>,</span><br><span class="line"></span><br><span class="line">ErrClassNotExistCode:      <span class="string">&quot;班级不存在&quot;</span>,</span><br><span class="line">ErrClassCreateFailedCode:  <span class="string">&quot;班级创建失败&quot;</span>,</span><br><span class="line">ErrClassUpdateFailedCode:  <span class="string">&quot;班级更新失败&quot;</span>,</span><br><span class="line">ErrClassDeleteFailedCode:  <span class="string">&quot;班级删除失败&quot;</span>,</span><br><span class="line">ErrClassGetListFailedCode: <span class="string">&quot;班级列表获取失败&quot;</span>,</span><br><span class="line"></span><br><span class="line">ErrRedisSetFailedCode: <span class="string">&quot;redis缓存失败&quot;</span>,</span><br><span class="line">ErrRedisGetFailedCode: <span class="string">&quot;redis获取失败&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ErrPersonNotExist     = NewRpcError(ErrPersonNotExistCode)</span><br><span class="line">ErrPersonCreateFailed = NewRpcError(ErrPersonCreateFailedCode)</span><br><span class="line">ErrPersonUpdateFailed = NewRpcError(ErrPersonUpdateFailedCode)</span><br><span class="line">ErrPersonDeleteFailed = NewRpcError(ErrPersonDeleteFailedCode)</span><br><span class="line"></span><br><span class="line">ErrClassNotExist      = NewRpcError(ErrClassNotExistCode)</span><br><span class="line">ErrClassCreateFailed  = NewRpcError(ErrClassCreateFailedCode)</span><br><span class="line">ErrClassUpdateFailed  = NewRpcError(ErrClassUpdateFailedCode)</span><br><span class="line">ErrClassDeleteFailed  = NewRpcError(ErrClassDeleteFailedCode)</span><br><span class="line">ErrClassGetListFailed = NewRpcError(ErrClassGetListFailedCode)</span><br><span class="line"></span><br><span class="line">ErrRedisSetFailed = NewRpcError(ErrRedisSetFailedCode)</span><br><span class="line">ErrRedisGetFailed = NewRpcError(ErrRedisGetFailedCode)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RpcError <span class="keyword">struct</span> &#123;</span><br><span class="line">Code    Code   <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">Message <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRpcError</span><span class="params">(code Code)</span></span> *RpcError &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;RpcError&#123;</span><br><span class="line">Code:    code,</span><br><span class="line">Message: errCodeMap[code],</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *RpcError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是，rpc 传递过去之后，grpc给他又封装了一层，就不能用 <code>errors.Is()</code> 来判断了</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202211201212367.png" alt="image-20221120121236228"></p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202211201212623.png" alt="image-20221120121241421"></p><p>然后折腾了好久，最后经人指点可以使用 gppc 的 state 来传递错误码（</p><p>先把全局错误码改成  <code>codes.Code</code> 类型，然后自己写一个函数用来比较</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RpcError <span class="keyword">struct</span> &#123;</span><br><span class="line">   Code    codes.Code <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">   Message <span class="type">string</span>     <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err <span class="type">error</span>, target *RpcError)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   s, _ := status.FromError(err)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> s.Code() == target.Code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 rpc 层和 api 层这样使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc </span></span><br><span class="line">err = l.svcCtx.DBList.Mysql.First(&amp;classModel).Error</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;class.GetPersonReply&#123;&#125;, status.Error(rpcError.ErrClassNotExist.Code, err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// api</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过学号查询用户信息</span></span><br><span class="line">GetPersonResult, err := l.svcCtx.ClassRpc.GetPerson(l.ctx, &amp;class.GetPersonRequest&#123;</span><br><span class="line">   Id: <span class="type">int32</span>(studentId),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123; <span class="comment">// 如果没有错误，说明用户已经存在</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> rpcError.Is(err, rpcError.ErrPersonNotExist) &#123; <span class="comment">// 如果用户不存在，就创建一个</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(<span class="string">&quot;get user info failed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我还是不能理解官方文档是怎么直接比较的</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202211201215315.png" alt="image-20221120121540210"></p>]]></content:encoded>
      
      
      <category domain="https://www.nickxu.top/categories/Golang/">Golang</category>
      
      <category domain="https://www.nickxu.top/categories/Golang/go-zero-%E6%A1%86%E6%9E%B6/">go-zero 框架</category>
      
      
      <category domain="https://www.nickxu.top/tags/Go/">Go</category>
      
      <category domain="https://www.nickxu.top/tags/grpc/">grpc</category>
      
      <category domain="https://www.nickxu.top/tags/go-zero/">go-zero</category>
      
      
      <comments>https://www.nickxu.top/2022/11/20/%E3%80%8EGo%E3%80%8F%E4%BD%BF%E7%94%A8-grpc-%E6%97%B6%E4%BC%A0%E9%80%92%E9%94%99%E8%AF%AF%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>『k8s』创建dashboard访问token</title>
      <link>https://www.nickxu.top/2022/11/18/%E3%80%8Ek8s%E3%80%8F%E5%88%9B%E5%BB%BAdashboard%E8%AE%BF%E9%97%AEtoken/</link>
      <guid>https://www.nickxu.top/2022/11/18/%E3%80%8Ek8s%E3%80%8F%E5%88%9B%E5%BB%BAdashboard%E8%AE%BF%E9%97%AEtoken/</guid>
      <pubDate>Fri, 18 Nov 2022 12:36:13 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;前几天老王八蛋给了我杭助服务器的权限，让我一睹部署的细节&lt;/p&gt;
&lt;p&gt;然后本菜鸡还没接触 k8s ，先把生成 dashboard token 的命令记一下（&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu</description>
        
      
      
      
      <content:encoded><![CDATA[<p>前几天老王八蛋给了我杭助服务器的权限，让我一睹部署的细节</p><p>然后本菜鸡还没接触 k8s ，先把生成 dashboard token 的命令记一下（</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k3s kubectl -n kubernetes-dashboard create token admin-user</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://www.nickxu.top/tags/k8s/">k8s</category>
      
      
      <comments>https://www.nickxu.top/2022/11/18/%E3%80%8Ek8s%E3%80%8F%E5%88%9B%E5%BB%BAdashboard%E8%AE%BF%E9%97%AEtoken/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang 语法速通指南（九）函数之基础使用</title>
      <link>https://www.nickxu.top/2022/11/14/Golang-%E8%AF%AD%E6%B3%95%E9%80%9F%E9%80%9A%E6%8C%87%E5%8D%97%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%BD%E6%95%B0/</link>
      <guid>https://www.nickxu.top/2022/11/14/Golang-%E8%AF%AD%E6%B3%95%E9%80%9F%E9%80%9A%E6%8C%87%E5%8D%97%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%BD%E6%95%B0/</guid>
      <pubDate>Mon, 14 Nov 2022 12:15:33 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Go 中的函数基本可分为普通函数、匿名函数和方法，方法可视为绑定在结构体上的函数，将在之后单独讲解&lt;/p&gt;
&lt;h1 id=&quot;普通函数的声明&quot;&gt;普通函数的声明&lt;/h1&gt;
&lt;p&gt;函数声明包括函数名，参数（入参，形参，随你怎么叫）列表，返回值（出参）列表以及函数体&lt;/p&gt;
&lt;fi</description>
        
      
      
      
      <content:encoded><![CDATA[<p>Go 中的函数基本可分为普通函数、匿名函数和方法，方法可视为绑定在结构体上的函数，将在之后单独讲解</p><h1 id="普通函数的声明">普通函数的声明</h1><p>函数声明包括函数名，参数（入参，形参，随你怎么叫）列表，返回值（出参）列表以及函数体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">([入参列表])</span></span> [返回值列表] &#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数返回值">函数返回值</h1><p>一个函数可以有返回值，也可以没有返回值，甚至可以有多个返回值</p><p>下面是一个简单的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在返回值列表就把返回的变量给定义好，这样可以 return 的时候会自动返回对应的变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="type">int</span>)</span></span> (c <span class="type">int</span>) &#123; <span class="comment">// 这种写法以及多返回值都要加括号</span></span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多返回值的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divi</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a / b, a % b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数参数">函数参数</h1><h2 id="值传递还是引用传递">值传递还是引用传递</h2><p>在 C++ 中，函数一般是值传递，也就是传递的是实参的拷贝，在函数中修改形参不会影响实参</p><p>在 Go 中也是如此，基本类型是值传递，但引用类型（如指针，slice、map、function、channel 等类型）传过去的可以看作是指针，实参会因为引用关系而修改</p><p>也就是说，基本类型是值传递，引用类型可以看作引用传递</p><h2 id="可变参数">可变参数</h2><p>Go 的可变参数是在 [C/C++ 的版本](C/C++  的版本) 上改进的，它解决了一些痛点，让使用更加方便</p><p>还是经典的求和函数，因为使用了可变参数，它可以接受任意个 <code>int</code> 类型的参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(vals ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> vals &#123;</span><br><span class="line">        total += val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数体中，<code>vals</code> 可以被看作是 <code>int</code> 类型的切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(sum())           <span class="comment">// &quot;0&quot;</span></span><br><span class="line">fmt.Println(sum(<span class="number">3</span>))          <span class="comment">// &quot;3&quot;</span></span><br><span class="line">fmt.Println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)) <span class="comment">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure><p>但在外部，该函数的参数（ <code>...int</code> ）不能认为是一个 <code>int</code> 类型的切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(...<span class="type">int</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">([]<span class="type">int</span>)</span></span> &#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, f) <span class="comment">// &quot;func(...int)&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, g) <span class="comment">// &quot;func([]int)&quot;</span></span><br></pre></td></tr></table></figure><p>那现在我想传入一个切片怎么办？可以使用下面的方式将切片拆成参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">values := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(sum(values...)) <span class="comment">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://www.nickxu.top/categories/Golang/">Golang</category>
      
      <category domain="https://www.nickxu.top/categories/Golang/%E8%AF%AD%E6%B3%95%E9%80%9F%E9%80%9A/">语法速通</category>
      
      
      <category domain="https://www.nickxu.top/tags/Go/">Go</category>
      
      
      <comments>https://www.nickxu.top/2022/11/14/Golang-%E8%AF%AD%E6%B3%95%E9%80%9F%E9%80%9A%E6%8C%87%E5%8D%97%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%BD%E6%95%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>『Go』记录一种处理大文件上传的可行方案：tus 协议</title>
      <link>https://www.nickxu.top/2022/11/11/%E3%80%8EGo%E3%80%8F%E5%88%86%E4%BA%AB%E4%B8%80%E7%A7%8D%E5%A4%84%E7%90%86%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%8F%AF%E8%A1%8C%E6%96%B9%E6%A1%88/</link>
      <guid>https://www.nickxu.top/2022/11/11/%E3%80%8EGo%E3%80%8F%E5%88%86%E4%BA%AB%E4%B8%80%E7%A7%8D%E5%A4%84%E7%90%86%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%8F%AF%E8%A1%8C%E6%96%B9%E6%A1%88/</guid>
      <pubDate>Fri, 11 Nov 2022 04:11:41 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;由于项目业务需要，我需要处理一些大文件的上传（比如说几百MB的视频）&lt;/p&gt;
&lt;p&gt;然后在网上搜了一通之后是，发现都是一些零散的实现&lt;/p&gt;
&lt;p&gt;但是我感觉这种东西一定是有人造过轮子的，于是我就到 GitHub 上搜索相关的包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https</description>
        
      
      
      
      <content:encoded><![CDATA[<p>由于项目业务需要，我需要处理一些大文件的上传（比如说几百MB的视频）</p><p>然后在网上搜了一通之后是，发现都是一些零散的实现</p><p>但是我感觉这种东西一定是有人造过轮子的，于是我就到 GitHub 上搜索相关的包</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202211112154678.png" alt="image-20221111215420536"></p><p>然后就发现了 <code>tus</code> 这个项目</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202211112156068.png" alt="image-20221111215604945"></p><p>打开官网，我发现这是一个基于 HTTP 的开源协议（有 <a href="https://tus.io/demo.html">在线 Demo</a> ，感觉挺不错的），还有官方的 Go 实现 <code>tusd</code> ，简直不要太爽</p><p>来看在 Go 项目中如何使用 tusd 包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/tus/tusd/pkg/filestore&quot;</span></span><br><span class="line">tusd <span class="string">&quot;github.com/tus/tusd/pkg/handler&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Create a new FileStore instance which is responsible for</span></span><br><span class="line"><span class="comment">// storing the uploaded file on disk in the specified directory.</span></span><br><span class="line"><span class="comment">// This path _must_ exist before tusd will store uploads in it.</span></span><br><span class="line"><span class="comment">// If you want to save them on a different medium, for example</span></span><br><span class="line"><span class="comment">// a remote FTP server, you can implement your own storage backend</span></span><br><span class="line"><span class="comment">// by implementing the tusd.DataStore interface.</span></span><br><span class="line">store := filestore.FileStore&#123;</span><br><span class="line">Path: <span class="string">&quot;./uploads&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A storage backend for tusd may consist of multiple different parts which</span></span><br><span class="line"><span class="comment">// handle upload creation, locking, termination and so on. The composer is a</span></span><br><span class="line"><span class="comment">// place where all those separated pieces are joined together. In this example</span></span><br><span class="line"><span class="comment">// we only use the file store but you may plug in multiple.</span></span><br><span class="line">composer := tusd.NewStoreComposer()</span><br><span class="line">store.UseIn(composer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new HTTP handler for the tusd server by providing a configuration.</span></span><br><span class="line"><span class="comment">// The StoreComposer property must be set to allow the handler to function.</span></span><br><span class="line">handler, err := tusd.NewHandler(tusd.Config&#123;</span><br><span class="line">BasePath:              <span class="string">&quot;/files/&quot;</span>,</span><br><span class="line">StoreComposer:         composer,</span><br><span class="line">NotifyCompleteUploads: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;Unable to create handler: %s&quot;</span>, err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start another goroutine for receiving events from the handler whenever</span></span><br><span class="line"><span class="comment">// an upload is completed. The event will contains details about the upload</span></span><br><span class="line"><span class="comment">// itself and the relevant HTTP request.</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">event := &lt;-handler.CompleteUploads</span><br><span class="line">fmt.Printf(<span class="string">&quot;Upload %s finished\n&quot;</span>, event.Upload.ID)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Right now, nothing has happened since we need to start the HTTP server on</span></span><br><span class="line"><span class="comment">// our own. In the end, tusd will start listening on and accept request at</span></span><br><span class="line"><span class="comment">// http://localhost:8080/files</span></span><br><span class="line">http.Handle(<span class="string">&quot;/files/&quot;</span>, http.StripPrefix(<span class="string">&quot;/files/&quot;</span>, handler))</span><br><span class="line">err = http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;Unable to listen: %s&quot;</span>, err))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉也不复杂，但是在我把这个后端准备好之后，找不到一个前端实现</p><p>然后谷歌了一下，找到了一个：<a href="http://fpcloud.ricorean.net/plugin/tus-js-client-master/demo/">http://fpcloud.ricorean.net/plugin/tus-js-client-master/demo/</a></p><p>下面是效果演示</p><div class="video"><video controls preload><source src='https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202211120053540.mp4' type='video/mp4'>Your browser does not support the video tag.</video></div><p>并且这东西支持断点续传，可随意暂停，刷新网页后可同步进度接着上传</p><p>但是官方貌似更倾向于把它作为一个独立的服务，而不是嵌入在项目中，然后使用钩子与项目沟通</p><p>而且我也无法将 tusd 嵌入在 go-zero 中，因为 go-zero 已经预设好每个路由的方法了，而 tusd 是同时在一个路由使用多种方法的</p><p>另外一个不足之处就是我遇到了无法上传的问题，而在访客模式中可以正常工作，最后我发现这种情况需要清一下浏览器的缓存</p><p><img src="https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202211121032497.png" alt="image-20221112103155367"></p>]]></content:encoded>
      
      
      <category domain="https://www.nickxu.top/categories/Go/">Go</category>
      
      
      <category domain="https://www.nickxu.top/tags/tus/">tus</category>
      
      
      <comments>https://www.nickxu.top/2022/11/11/%E3%80%8EGo%E3%80%8F%E5%88%86%E4%BA%AB%E4%B8%80%E7%A7%8D%E5%A4%84%E7%90%86%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%8F%AF%E8%A1%8C%E6%96%B9%E6%A1%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>新人如何参加面试系统后端讲解留档</title>
      <link>https://www.nickxu.top/2022/11/09/%E6%96%B0%E4%BA%BA%E5%A6%82%E4%BD%95%E5%8F%82%E5%8A%A0%E9%9D%A2%E8%AF%95%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%AB%AF%E8%AE%B2%E8%A7%A3%E7%95%99%E6%A1%A3/</link>
      <guid>https://www.nickxu.top/2022/11/09/%E6%96%B0%E4%BA%BA%E5%A6%82%E4%BD%95%E5%8F%82%E5%8A%A0%E9%9D%A2%E8%AF%95%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%AB%AF%E8%AE%B2%E8%A7%A3%E7%95%99%E6%A1%A3/</guid>
      <pubDate>Wed, 09 Nov 2022 02:16:13 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;前几天讲的，BB了一个小时&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hdu-help.feishu.cn/docx/NVHqdjh00o53KIxzv9ict5AxnVh&quot;&gt;https://hdu-help.feishu.cn/docx/NVHqdjh00o53KI</description>
        
      
      
      
      <content:encoded><![CDATA[<p>前几天讲的，BB了一个小时</p><p><a href="https://hdu-help.feishu.cn/docx/NVHqdjh00o53KIxzv9ict5AxnVh">https://hdu-help.feishu.cn/docx/NVHqdjh00o53KIxzv9ict5AxnVh</a></p><p><s>如有不好的地方请大力敲打我</s></p>]]></content:encoded>
      
      
      
      
      <comments>https://www.nickxu.top/2022/11/09/%E6%96%B0%E4%BA%BA%E5%A6%82%E4%BD%95%E5%8F%82%E5%8A%A0%E9%9D%A2%E8%AF%95%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%AB%AF%E8%AE%B2%E8%A7%A3%E7%95%99%E6%A1%A3/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
