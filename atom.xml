<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NX の 博客</title>
  <icon>https://nickxu.me/static/favicon.jpg</icon>
  
  <link href="https://nickxu.me/atom.xml" rel="self"/>
  
  <link href="https://nickxu.me/"/>
  <updated>2023-10-12T17:20:59.012Z</updated>
  <id>https://nickxu.me/</id>
  
  <author>
    <name>Nick Xu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你还惦记着你那二面呢｜Allow Everything to Happen</title>
    <link href="https://nickxu.me/post/allow-everything-to-happen.html"/>
    <id>https://nickxu.me/post/allow-everything-to-happen.html</id>
    <published>2023-10-12T16:56:14.000Z</published>
    <updated>2023-10-12T17:20:59.012Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://image.nickxu.me/202310130057300.png" alt="f6d2c2d5852e153218a05493c7948488"></p><blockquote><p>「你还惦记着你那二面呢」</p></blockquote><p>我真的好累，今天还吐了，感觉病了</p><p>我消失了很长一段时间，本来我想写一篇长文，记录我从 8 月 22 号返校到现在发生的所有事情</p><p>但是我真的好累，简单地说，就是诸事不顺，面试、亚运、学业…我不想写</p><p>我总是想在最后来一波升华，但是我其实并没有走出来，架构不出，我写不出来</p><p>我太想成功了，但这正是我没法成功的原因</p><p>就像你找东西，你越找就越找不到，经常是后面不经意的时候突然就冒出来了</p><p>就我现在这个状态，我想留一句话，与君共勉吧</p><blockquote><p>Allow everything to happen｜允许所有事情发生</p></blockquote><p>最后，我还想说</p><p>爸爸妈妈，我永远爱你们❤️</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1979375472&auto=1&height=66"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.nickxu.me/202310130057300.png&quot; alt=&quot;f6d2c2d5852e153218a05493c7948488&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「你还惦记着你那二面呢」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我真的好累，今天还吐了，感觉病了&lt;/p&gt;
&lt;p&gt;我消失了很长一段时间，本来我想写一篇长文，记录我从 8 月 22 号返校到现在发生的所有事情&lt;/p&gt;
&lt;p&gt;但是我真的好累，简单地说，就是诸事不顺，面试、亚运、学业…我不想写&lt;/p&gt;
&lt;p&gt;我总是想在最后来一波升华，但是我其实并没有走出来，架构不出，我写不出来&lt;/p&gt;
&lt;p&gt;我太想成功了，但这正是我没法成功的原因&lt;/p&gt;
&lt;p&gt;就像你找东西，你越找就越找不到，经常是后面不经意的时候突然就冒出来了&lt;/p&gt;
&lt;p&gt;就我现在这个状态，我想留一句话，与君共勉吧&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Allow everything to happen｜允许所有事情发生&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，我还想说&lt;/p&gt;
&lt;p&gt;爸爸妈</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>浅析 JWT Refresh Token</title>
    <link href="https://nickxu.me/post/jwt-refresh-token.html"/>
    <id>https://nickxu.me/post/jwt-refresh-token.html</id>
    <published>2023-10-10T03:31:24.000Z</published>
    <updated>2023-10-11T04:40:27.865Z</updated>
    
    <content type="html"><![CDATA[<p>最近<a href="https://www.v2ex.com/t/979326">逛 V 站</a>又看见有人在讨论 JWT，感觉很多人讲的很乱，我想简单记录下我印象中的理解</p><h2 id="Session">Session</h2><p>最开始应该是 session 方案，就是用户登陆后服务器返回客户端一个存根（token）来标识当前的会话</p><p>服务器在缓存中保存这个 token，用户请求时需要传递这个 token（不管你是使用 cookie header 还是 query）</p><p>每次请求服务器都在缓存中查找这个 token，并且找到当前会话的相关信息（比如说是哪个用户）</p><p>使用这种方案的优点：</p><ul><li>强控制性：可以手动过期，如果想让某个用户下线就直接在缓存删除对应的键值对就行</li><li>可观察性：可以很清楚地看见当前的在线用户数量</li></ul><p>使用这种方案的缺点：</p><ul><li>性能需求高：因为每次请求都要查缓存，如果用户规模越大的问题越明显</li><li>对分布式不友好：他是有状态的，你必须共用一个缓存空间来存储数据</li></ul><h2 id="原始-JWT">原始 JWT</h2><p>为了克服上面的缺点， JWT 出现了</p><p>JWT (JSON Web Token ) 使用的是一种很巧妙的方法，他本身也是一个 string token，分为三部分</p><p><code>Header.Payload.Signature</code></p><ol><li>Header，标识加密算法</li><li>Payload，你要存储的数据，比如说用户 ID 、权限 Level 与过期时间等，请注意这是外部可读的</li><li>Signature，加密算法签名</li></ol><p>你需要注意的是，Payload 是前后端都可读的，但是可以使用 Signature 保证这个 Payload 是未更改的</p><p>工作流程是这样的：</p><p>用户登陆后服务器通过本地密钥计算并返回 JWT 给用户，用户请求时需要传递这个 JWT（不管你是使用 cookie header 还是 query）</p><p>服务器解析 JWT，通过本地密钥 + Signature 验证是否是当初颁发的 JWT，如果是的话就完全相信 Payload 的内容（你是谁，你的权限是什么等等）</p><p>到这里你应该能看出一些问题了，但暂时按下不表，先谈优点</p><p>使用这种方案的优点：</p><ul><li>性能要求低：不需要查缓存或者查库，如果收到的是有效的 JWT，就直接信赖 Payload 的内容</li><li>无状态&amp;分布式友好：如果你有两个毫不相干的服务 A 和 B，那么只需要你的本地密钥是相同的，那么生成的 JWT 看上去就是从一个服务生成的（也就是说能够相互承认）</li></ul><p>使用这种方案的优点：</p><p>不安全哇！即使你的 JWT 可以过期，那么在过期前用户权限更改或者用户注销了怎么办？它是无法撤销的</p><ul><li><p>如果你选择完全相信 Payload 的内容</p><p>当权限更改时（严重点用户注销时）过期之前 JWT 仍然有效，这时用户仍然可以使用之前的身份活动（严重点你可以看见注销的用户在活动）</p></li><li><p>如果你选择每次查库验证</p><p>你选择每次接收请求时都查一遍用户的权限，或者这个用户存不存在</p><p>但是这样就违背了 JWT 的初衷了，你还是倒退回「每次请求都要查一遍缓存」，JWT 就退化成类似  Session 的模型了</p></li></ul><h2 id="长短令牌的-JWT">长短令牌的 JWT</h2><p>为了缓解这个问题，就有了长短 JWT</p><ul><li><p>短期 JWT（Access Token）：用于日常访问，但是有效期短（比如 10-30min）</p><p>这样，即使权限更改或者用户注销，或者令牌被盗，也只能在短时间能使用</p></li><li><p>长期 JWT（Refresh Token）：用于在短 JWT 过期时查库并生成新的短 JWT，不能用于日常请求，有效期很长</p></li></ul><p>这种策略能很好的缓解上面的问题，比如长 JWT 只有用户 ID，每次刷新都会查库确认用户存在并拿到当前权限</p><p>即使用户身份更改了，旧身份的有效期也只有短 JWT 的长度（实际上前端应该立即销毁旧身份并刷新令牌）</p><p>当然，你可能会说这样还是不够安全哇！如果你问出这个问题的话，那你可以使用 Session 模式，它的确是更加安全可控</p><p>但对于一般项目来说也没什么所谓了，JWT 也够了，毕竟方便</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近&lt;a href=&quot;https://www.v2ex.com/t/979326&quot;&gt;逛 V 站&lt;/a&gt;又看见有人在讨论 JWT，感觉很多人讲的很乱，我想简单记录下我印象中的理解&lt;/p&gt;
&lt;h2 id=&quot;Session&quot;&gt;Session&lt;/h2&gt;
&lt;p&gt;最开始应该是 session 方案，就是用户登陆后服务器返回客户端一个存根（token）来标识当前的会话&lt;/p&gt;
&lt;p&gt;服务器在缓存中保存这个 token，用户请求时需要传递这个 token（不管你是使用 cookie header 还是 query）&lt;/p&gt;
&lt;p&gt;每次请求服务器都在缓存中查找这个 token，并且找到当前会话的相关信息（比如说是哪个用户）&lt;/p&gt;
&lt;p&gt;使用这种方案的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强控制性：可以手动过期，如果想让某个用户下线就直接在缓存删除对应的键值对就行&lt;/li&gt;
&lt;li&gt;可观察性：可以很清楚地看见当前的在线用户数量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用这种方案的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能需求高：因为每次请求都要查缓存，如果用户规模越大的问题越明显&lt;/li&gt;
&lt;li&gt;对分布式不友好：</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『LeetCode-HOT-100』T61～T70</title>
    <link href="https://nickxu.me/post/leetcode-hot-100-t61-t70.html"/>
    <id>https://nickxu.me/post/leetcode-hot-100-t61-t70.html</id>
    <published>2023-09-12T04:46:02.000Z</published>
    <updated>2023-10-09T05:59:51.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="207-课程表"><a href="https://leetcode.cn/problems/course-schedule?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">207. 课程表</a></h1><p><a href="https://nickxu.me/2019/11/14/cc-2019csp-mo-ban/#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">拓扑排序</a>板子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="type">int</span>, prerequisites [][]<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    n:=<span class="built_in">len</span>(prerequisites)</span><br><span class="line">    rd:=<span class="built_in">make</span>([]<span class="type">int</span>,numCourses)</span><br><span class="line">    edge:=<span class="built_in">make</span>([][]<span class="type">int</span>,numCourses)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++&#123;</span><br><span class="line">        from,to:=prerequisites[i][<span class="number">0</span>],prerequisites[i][<span class="number">1</span>]</span><br><span class="line">        edge[from]=<span class="built_in">append</span>(edge[from],to)</span><br><span class="line">        rd[to]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fmt.Println(rd)</span></span><br><span class="line"></span><br><span class="line">    q:=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;numCourses;i++&#123;</span><br><span class="line">        <span class="keyword">if</span> rd[i]==<span class="number">0</span>&#123;</span><br><span class="line">            q=<span class="built_in">append</span>(q,i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fmt.Println(q)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q)!=<span class="number">0</span>&#123;</span><br><span class="line">        curr:=q[<span class="number">0</span>]</span><br><span class="line">        q=q[<span class="number">1</span>:]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(edge[curr]);i++&#123;</span><br><span class="line">            next:=edge[curr][i]</span><br><span class="line">            rd[next]--</span><br><span class="line">            <span class="keyword">if</span> rd[next]==<span class="number">0</span>&#123;</span><br><span class="line">                q=<span class="built_in">append</span>(q,next)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;numCourses;i++&#123;</span><br><span class="line">        <span class="keyword">if</span> rd[i]!=<span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="208-实现-Trie-前缀树"><a href="https://leetcode.cn/problems/implement-trie-prefix-tree?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">208. 实现 Trie (前缀树)</a></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    next [<span class="number">26</span>]*Trie</span><br><span class="line">    isEnd <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> Trie &#123;</span><br><span class="line">    <span class="keyword">return</span> Trie&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Insert(word <span class="type">string</span>)  &#123;</span><br><span class="line">    <span class="keyword">if</span> word == <span class="string">&quot;&quot;</span>&#123;</span><br><span class="line">        t.isEnd=<span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    c:=word[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> t.next[c]==<span class="literal">nil</span>&#123;</span><br><span class="line">        t.next[c]=&amp;Trie&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t.next[c].Insert(word[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> SearchPrefix(word <span class="type">string</span>)*Trie&#123;</span><br><span class="line">    <span class="keyword">if</span> word == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">    &#125;</span><br><span class="line">    c:=word[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> t.next[c]==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t.next[c].SearchPrefix(word[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Search(word <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    curr:=t.SearchPrefix(word)</span><br><span class="line">    <span class="keyword">return</span> curr!=<span class="literal">nil</span>&amp;&amp;curr.isEnd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> StartsWith(prefix <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.SearchPrefix(prefix)!=<span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="215-数组中的第K个最大元素"><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">215. 数组中的第K个最大元素</a></h1><p>还记得<a href="https://nickxu.me/posts/sorting-algorithm?highlight=%E5%BF%AB%E9%80%9F#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Quicksort%EF%BC%89">快速排序</a>吗？把其中的一步拎出来就行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">return</span> quickselect(nums, <span class="number">0</span>, n - <span class="number">1</span>, n - k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickselect</span><span class="params">(nums []<span class="type">int</span>, l, r, k <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[k]</span><br><span class="line">    &#125;</span><br><span class="line">    partition := nums[l]</span><br><span class="line">    i := l - <span class="number">1</span></span><br><span class="line">    j := r + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">for</span> i++;nums[i]&lt;partition;i++&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j--;nums[j]&gt;partition;j--&#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            nums[i],nums[j]=nums[j],nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= j)&#123;</span><br><span class="line">        <span class="keyword">return</span> quickselect(nums, l, j, k)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quickselect(nums, j + <span class="number">1</span>, r, k)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="221-最大正方形-https-leetcode-cn-problems-maximal-square-envType-featured-list-envId-2cktkvj-envType-featured-list-envId-2cktkvj">221. 最大正方形](<a href="https://leetcode.cn/problems/maximal-square?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">https://leetcode.cn/problems/maximal-square?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj</a>)</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximalSquare</span><span class="params">(matrix [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n, m := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, m)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; m; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> || j == <span class="number">0</span> &#123; <span class="comment">// 边界条件</span></span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = min(min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]), dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                ans = max(ans, dp[i][j])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans * ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="226-翻转二叉树"><a href="https://leetcode.cn/problems/invert-binary-tree?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">226. 翻转二叉树</a></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> root== <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    invertTree(root.Left)</span><br><span class="line">    invertTree(root.Right)</span><br><span class="line"></span><br><span class="line">    root.Left,root.Right=root.Right,root.Left</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="234-回文链表"><a href="https://leetcode.cn/problems/palindrome-linked-list?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">234. 回文链表</a></h1><p>方法很多，官方题解已经讲得清楚了</p><p>我使用反转后半部分然后比较的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// 定义快慢指针</span></span><br><span class="line"><span class="keyword">var</span> slow *ListNode = head</span><br><span class="line"><span class="keyword">var</span> fast *ListNode = head</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快慢指针走到中间节点</span></span><br><span class="line"><span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果fast不为空，说明链表长度为奇数，slow还要再前进一步</span></span><br><span class="line"><span class="keyword">if</span> fast != <span class="literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转后半部分链表</span></span><br><span class="line">slow = reverseList(slow)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较前后两部分链表</span></span><br><span class="line"><span class="keyword">for</span> slow != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> slow.Val != head.Val &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">slow = slow.Next</span><br><span class="line">head = head.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line"><span class="comment">// 定义前驱节点、当前节点、后继节点</span></span><br><span class="line"><span class="keyword">var</span> prev *ListNode = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> next *ListNode = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> curr *ListNode = head</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="keyword">for</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 保存下一个节点</span></span><br><span class="line">next = curr.Next</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前节点指向前驱节点</span></span><br><span class="line">curr.Next = prev</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前驱节点后移</span></span><br><span class="line">prev = curr</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前节点后移</span></span><br><span class="line">curr = next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回前驱节点</span></span><br><span class="line"><span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="236-二叉树的最近公共祖先"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">236. 二叉树的最近公共祖先</a></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> root== p||root==q||root==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    left:=lowestCommonAncestor(root.Left,p,q)</span><br><span class="line">    right:=lowestCommonAncestor(root.Right,p,q)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> left !=<span class="literal">nil</span> &amp;&amp; right!=<span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> left ==<span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="238-除自身以外数组的乘积"><a href="https://leetcode.cn/problems/product-of-array-except-self?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">238. 除自身以外数组的乘积</a></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productExceptSelf</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n:=<span class="built_in">len</span>(nums)</span><br><span class="line">    preSum:=<span class="built_in">make</span>([]<span class="type">int</span>,n)</span><br><span class="line">    backSum:=<span class="built_in">make</span>([]<span class="type">int</span>,n)</span><br><span class="line">    ans:=<span class="built_in">make</span>([]<span class="type">int</span>,n)</span><br><span class="line"></span><br><span class="line">    preSum[<span class="number">0</span>]=nums[<span class="number">0</span>]</span><br><span class="line">    backSum[n<span class="number">-1</span>]=nums[n<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;n;i++&#123;</span><br><span class="line">        preSum[i]=preSum[i<span class="number">-1</span>]*nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=n<span class="number">-2</span>;i&gt;<span class="number">0</span>;i--&#123;</span><br><span class="line">        backSum[i]=backSum[i+<span class="number">1</span>]*nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ans[<span class="number">0</span>]=backSum[<span class="number">1</span>]</span><br><span class="line">    ans[n<span class="number">-1</span>]=preSum[n<span class="number">-2</span>]</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++&#123;</span><br><span class="line">        ans[i]=preSum[i<span class="number">-1</span>]*backSum[i+<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="239-滑动窗口最大值"><a href="https://leetcode.cn/problems/sliding-window-maximum?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">239. 滑动窗口最大值</a></h1><p><a href="https://leetcode.cn/problems/sliding-window-maximum/solutions/543426/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/comments/2102032">这个评论</a>讲的很清楚</p><p>使用单调队列，感觉有点难想</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装单调队列的方式解题</span></span><br><span class="line"><span class="keyword">type</span> MyQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    queue []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyQueue</span><span class="params">()</span></span> *MyQueue &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyQueue&#123;</span><br><span class="line">        queue: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyQueue)</span></span> Front() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.queue[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyQueue)</span></span> Back() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.queue[<span class="built_in">len</span>(m.queue)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyQueue)</span></span> Empty() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(m.queue) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyQueue)</span></span> Push(val <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> !m.Empty() &amp;&amp; val &gt; m.Back() &#123;</span><br><span class="line">        m.queue = m.queue[:<span class="built_in">len</span>(m.queue)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    m.queue = <span class="built_in">append</span>(m.queue, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyQueue)</span></span> Pop(val <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> !m.Empty() &amp;&amp; val == m.Front() &#123;</span><br><span class="line">        m.queue = m.queue[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    queue := NewMyQueue()</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 先将前k个元素放入队列</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        queue.Push(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录前k个元素的最大值</span></span><br><span class="line">    res = <span class="built_in">append</span>(res, queue.Front())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := k; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="comment">// 滑动窗口移除最前面的元素</span></span><br><span class="line">        queue.Pop(nums[i-k])</span><br><span class="line">        <span class="comment">// 滑动窗口添加最后面的元素</span></span><br><span class="line">        queue.Push(nums[i])</span><br><span class="line">        <span class="comment">// 记录最大值</span></span><br><span class="line">        res = <span class="built_in">append</span>(res, queue.Front())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="240-搜索二维矩阵-II"><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">240. 搜索二维矩阵 II</a></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    n, m := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> || m == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> search(matrix, target, <span class="number">0</span>, <span class="number">0</span>, n<span class="number">-1</span>, m<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(matrix [][]<span class="type">int</span>, target, rowStart, colStart, rowEnd, colEnd <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> rowStart &gt; rowEnd || colStart &gt; colEnd &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    midRow, midCol := (rowStart+rowEnd)/<span class="number">2</span>, (colStart+colEnd)/<span class="number">2</span></span><br><span class="line">    midValue := matrix[midRow][midCol]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> midValue == target &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> midValue &gt; target &#123;</span><br><span class="line">        <span class="comment">// Recursively search the top-left, top-right, and bottom-left submatrices</span></span><br><span class="line">        <span class="keyword">return</span> search(matrix, target, rowStart, colStart, midRow<span class="number">-1</span>, colEnd) ||</span><br><span class="line">               search(matrix, target, midRow, colStart, rowEnd, midCol<span class="number">-1</span>) ||</span><br><span class="line">               search(matrix, target, midRow+<span class="number">1</span>, colStart, rowEnd, midCol<span class="number">-1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Recursively search the top-right, bottom-left, and bottom-right submatrices</span></span><br><span class="line">        <span class="keyword">return</span> search(matrix, target, rowStart, midCol+<span class="number">1</span>, midRow, colEnd) ||</span><br><span class="line">               search(matrix, target, rowStart, midCol+<span class="number">1</span>, rowEnd, colEnd) ||</span><br><span class="line">               search(matrix, target, midRow+<span class="number">1</span>, colStart, rowEnd, colEnd)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;207-课程表&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/course-schedule?envType=featured-list&amp;amp;envId=2cktkvj?envType=featured-list&amp;amp;envId=2cktkvj&quot;&gt;207. 课程表&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://nickxu.me/2019/11/14/cc-2019csp-mo-ban/#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F&quot;&gt;拓扑排序&lt;/a&gt;板子&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;b</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『LeetCode-HOT-100』T51～T60</title>
    <link href="https://nickxu.me/post/leetcode-hot-100-t51-t60.html"/>
    <id>https://nickxu.me/post/leetcode-hot-100-t51-t60.html</id>
    <published>2023-09-12T04:43:42.000Z</published>
    <updated>2023-10-05T11:19:48.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="142-环形链表-II"><a href="https://leetcode.cn/problems/linked-list-cycle-ii?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">142. 环形链表 II</a></h1><p>请见 <a href="/posts/275?highlight=%E9%93%BE%E8%A1%A8#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II">『算法拾遗』链表（Linked List）</a></p><h1 id="146-LRU-缓存"><a href="https://leetcode.cn/problems/lru-cache?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">146. LRU 缓存</a></h1><p>标准写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    size <span class="type">int</span></span><br><span class="line">    capacity <span class="type">int</span></span><br><span class="line">    cache <span class="keyword">map</span>[<span class="type">int</span>]*DlinkedNode</span><br><span class="line">    head,tail *DlinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DlinkedNode <span class="keyword">struct</span>&#123;</span><br><span class="line">    key,value <span class="type">int</span></span><br><span class="line">    prev,next *DlinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">    l:= LRUCache&#123;</span><br><span class="line">        cache:<span class="keyword">map</span>[<span class="type">int</span>]*DlinkedNode&#123;&#125;,</span><br><span class="line">        head: &amp;DlinkedNode&#123;&#125;,</span><br><span class="line">        tail: &amp;DlinkedNode&#123;&#125;,</span><br><span class="line">        capacity: capacity,</span><br><span class="line">    &#125;</span><br><span class="line">    l.head.next=l.tail</span><br><span class="line">    l.tail.prev=l.head</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok:=this.cache[key];!ok&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    node := this.cache[key]</span><br><span class="line">    this.moveToHead(node)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>)  &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok:=this.cache[key];!ok&#123;</span><br><span class="line">        node:=&amp;DlinkedNode&#123;</span><br><span class="line">            key: key,</span><br><span class="line">            value:value,</span><br><span class="line">        &#125;</span><br><span class="line">        this.cache[key]=node</span><br><span class="line">        this.addToHead(node)</span><br><span class="line">        this.size++</span><br><span class="line">        <span class="keyword">if</span> this.size&gt;this.capacity&#123;</span><br><span class="line">            removed:=this.removeTail()</span><br><span class="line">            <span class="built_in">delete</span>(this.cache,removed.key)</span><br><span class="line">            this.size--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        node:=this.cache[key]</span><br><span class="line">        node.value=value</span><br><span class="line">        this.moveToHead(node)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> addToHead(node *DlinkedNode) &#123;</span><br><span class="line">    node.prev = this.head</span><br><span class="line">    node.next = this.head.next</span><br><span class="line">    this.head.next.prev = node</span><br><span class="line">    this.head.next = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> removeNode(node *DlinkedNode) &#123;</span><br><span class="line">    node.prev.next = node.next</span><br><span class="line">    node.next.prev = node.prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> moveToHead(node *DlinkedNode) &#123;</span><br><span class="line">    this.removeNode(node)</span><br><span class="line">    this.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> removeTail() *DlinkedNode &#123;</span><br><span class="line">    node := this.tail.prev</span><br><span class="line">    this.removeNode(node)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面试快速默写版本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;key,value <span class="type">int</span>&#125;</span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">cap</span> <span class="type">int</span></span><br><span class="line">    cache <span class="keyword">map</span>[<span class="type">int</span>]*list.Element</span><br><span class="line">    lst *list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">    <span class="keyword">return</span> LRUCache&#123;capacity,<span class="keyword">map</span>[<span class="type">int</span>]*list.Element&#123;&#125;,list.New()&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    e:=c.cache[key]</span><br><span class="line">    <span class="keyword">if</span> e == <span class="literal">nil</span> &#123;<span class="keyword">return</span> <span class="number">-1</span>&#125;</span><br><span class="line">    c.lst.MoveToFront(e)</span><br><span class="line">    <span class="keyword">return</span> e.Value.(entry).value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>)  &#123;</span><br><span class="line">    <span class="keyword">if</span> e:=c.cache[key];e!=<span class="literal">nil</span>&#123;</span><br><span class="line">        e.Value=entry&#123;key,value&#125;</span><br><span class="line">        c.lst.MoveToFront(e)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.cache[key]=c.lst.PushFront(entry&#123;key,value&#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(c.cache)&gt;c.<span class="built_in">cap</span>&#123;</span><br><span class="line">        <span class="built_in">delete</span>(c.cache,c.lst.Remove(c.lst.Back()).(entry).key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="148-排序链表"><a href="https://leetcode.cn/problems/sort-list?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">148. 排序链表</a></h1><p>虽然但是，和<a href="https://leetcode.cn/problems/sort-list/solutions/2358097/ru-he-zheng-ming-pai-xu-lian-biao-shi-ku-tf9m/">这篇题解</a>说的一样，直接在链表上排序效率不及先转换成数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    s:=[]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> curr:= head;curr!=<span class="literal">nil</span>;curr=curr.Next&#123;</span><br><span class="line">        s=<span class="built_in">append</span>(s,curr.Val)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort.Ints(s)</span><br><span class="line"></span><br><span class="line">    dummy:=&amp;ListNode&#123;&#125;</span><br><span class="line">    curr:=dummy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,val:=<span class="keyword">range</span> s&#123;</span><br><span class="line">        curr.Next=&amp;ListNode&#123;&#125;</span><br><span class="line">        curr.Next.Val=val</span><br><span class="line">        curr=curr.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<a href="https://nickxu.me/posts/sorting-algorithm?highlight=%E5%BD%92%E5%B9%B6#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Merge-Sort%EF%BC%89">归并</a>的思路的版本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(head1, head2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    dummyHead := &amp;ListNode&#123;&#125;</span><br><span class="line">    temp, temp1, temp2 := dummyHead, head1, head2</span><br><span class="line">    <span class="keyword">for</span> temp1 != <span class="literal">nil</span> &amp;&amp; temp2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> temp1.Val &lt;= temp2.Val &#123;</span><br><span class="line">            temp.Next = temp1</span><br><span class="line">            temp1 = temp1.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp.Next = temp2</span><br><span class="line">            temp2 = temp2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> temp1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        temp.Next = temp1</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> temp2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        temp.Next = temp2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">(head, tail *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head.Next == tail &#123;</span><br><span class="line">        head.Next = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    slow, fast := head, head</span><br><span class="line">    <span class="keyword">for</span> fast != tail &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        <span class="keyword">if</span> fast != tail &#123;</span><br><span class="line">            fast = fast.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mid := slow</span><br><span class="line">    <span class="keyword">return</span> merge(sort(head, mid), sort(mid, tail))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">return</span> sort(head, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="152-乘积最大子数组"><a href="https://leetcode.cn/problems/maximum-product-subarray?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">152. 乘积最大子数组</a></h1><p>很巧妙的 dp 题目</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProduct</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n:=<span class="built_in">len</span>(nums)</span><br><span class="line">    dpMax:=<span class="built_in">make</span>([]<span class="type">int</span>,n)</span><br><span class="line">    dpMin:=<span class="built_in">make</span>([]<span class="type">int</span>,n)</span><br><span class="line"></span><br><span class="line">    dpMax[<span class="number">0</span>]=nums[<span class="number">0</span>]</span><br><span class="line">    dpMin[<span class="number">0</span>]=nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i,num:=<span class="keyword">range</span> nums&#123;</span><br><span class="line">        <span class="keyword">if</span> i==<span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        dpMax[i]=max(dpMax[i<span class="number">-1</span>]*num,dpMin[i<span class="number">-1</span>]*num,num)</span><br><span class="line">        dpMin[i]=min(dpMax[i<span class="number">-1</span>]*num,dpMin[i<span class="number">-1</span>]*num,num)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans:=math.MinInt</span><br><span class="line">    <span class="keyword">for</span> _,num:=<span class="keyword">range</span> dpMax&#123;</span><br><span class="line">        <span class="keyword">if</span> num&gt;ans&#123;</span><br><span class="line">            ans=num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a... <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">max := a[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line"><span class="keyword">if</span> v &gt; max &#123;</span><br><span class="line">max = v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a... <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">min := a[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line"><span class="keyword">if</span> v &lt; min &#123;</span><br><span class="line">min = v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="155-最小栈"><a href="https://leetcode.cn/problems/min-stack?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">155. 最小栈</a></h1><p>每次入栈时保存当前的最小值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    stack []<span class="type">int</span></span><br><span class="line">    minStack []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MinStack &#123;</span><br><span class="line">    <span class="keyword">return</span> MinStack&#123;</span><br><span class="line">        stack: []<span class="type">int</span>&#123;&#125;,</span><br><span class="line">        minStack: []<span class="type">int</span>&#123;math.MaxInt64&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Push(val <span class="type">int</span>)  &#123;</span><br><span class="line">    this.stack=<span class="built_in">append</span>(this.stack,val)</span><br><span class="line">    top:=this.minStack[<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]</span><br><span class="line">    this.minStack = <span class="built_in">append</span>(this.minStack,min(val,top))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Pop()  &#123;</span><br><span class="line">    this.stack = this.stack[:<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">    this.minStack = this.minStack[:<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Top() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.stack[<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> GetMin() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.minStack[<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="160-相交链表"><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">160. 相交链表</a></h1><p>请见 <a href="https://nickxu.me/posts/275?highlight=%E9%93%BE%E8%A1%A8#%E9%9D%A2%E8%AF%95%E9%A2%98-02-07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4">『算法拾遗』链表（Linked List）</a></p><h1 id="169-多数元素"><a href="https://leetcode.cn/problems/majority-element?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">169. 多数元素</a></h1><p>解法很多，还有一种「占山为王」的算法，数量多的最后肯定能占领</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n:=<span class="built_in">len</span>(nums)</span><br><span class="line">    m:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++&#123;</span><br><span class="line">        m[nums[i]]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> num,count:=<span class="keyword">range</span> m&#123;</span><br><span class="line">        <span class="keyword">if</span> count &gt; n/<span class="number">2</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="198-打家劫舍"><a href="https://leetcode.cn/problems/house-robber?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">198. 打家劫舍</a></h1><p>经典 dp</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n:=<span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp:=<span class="built_in">make</span>([]<span class="type">int</span>,n)</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>]=nums[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">1</span>]=max(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span>;i&lt;n;i++&#123;</span><br><span class="line">        dp[i]=max(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span> <span class="params">(i,j <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> i&gt;j&#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="200-岛屿数量"><a href="https://leetcode.cn/problems/number-of-islands?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">200. 岛屿数量</a></h1><p>一开始就想用并查集，但是其实有更简单的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">dx = []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">dy = []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">x, y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fa <span class="keyword">map</span>[node]node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span><span class="params">(x node)</span></span> node &#123;</span><br><span class="line"><span class="keyword">for</span> x != fa[x] &#123;</span><br><span class="line">fa[x] = fa[fa[x]]</span><br><span class="line">x = fa[x]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(x, y node)</span></span> &#123;</span><br><span class="line">fa[find(x)] = find(y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">fa = <span class="built_in">make</span>(<span class="keyword">map</span>[node]node)</span><br><span class="line">n, m := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; m; j++ &#123;</span><br><span class="line">fa[node&#123;i, j&#125;] = node&#123;i, j&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; m; j++ &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">for</span> k := <span class="number">0</span>; k &lt; <span class="number">4</span>; k++ &#123;</span><br><span class="line">nx := i + dx[k]</span><br><span class="line">ny := j + dy[k]</span><br><span class="line"><span class="keyword">if</span> nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m || grid[nx][ny] != <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">combine(node&#123;i, j&#125;, node&#123;nx, ny&#125;)</span><br><span class="line">grid[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fmt.Println(fa)</span></span><br><span class="line"><span class="comment">//ans := map[node]bool&#123;&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//for val, _ := range fa &#123;</span></span><br><span class="line"><span class="comment">//ans[find(val)] = true</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//fmt.Println(ans)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//return len(ans)</span></span><br><span class="line"></span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line">visited := <span class="built_in">make</span>(<span class="keyword">map</span>[node]<span class="type">bool</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; m; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">root := find(node&#123;i, j&#125;)</span><br><span class="line"><span class="keyword">if</span> !visited[root] &#123;</span><br><span class="line">ans++</span><br><span class="line">visited[root] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="206-反转链表"><a href="https://leetcode.cn/problems/reverse-linked-list?envType=featured-list&amp;envId=2cktkvj?envType=featured-list&amp;envId=2cktkvj">206. 反转链表</a></h1><p>请见 <a href="https://nickxu.me/posts/275?highlight=%E9%93%BE%E8%A1%A8#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">『算法拾遗』链表（Linked List）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;142-环形链表-II&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/linked-list-cycle-ii?envType=featured-list&amp;amp;envId=2cktkvj?envType=featured-list&amp;amp;envId=2cktkvj&quot;&gt;142. 环形链表 II&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;请见 &lt;a href=&quot;/posts/275?highlight=%E9%93%BE%E8%A1%A8#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II&quot;&gt;『算法拾遗』链表（Linked List）&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;146-LRU-缓存&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/lru-cache?envType=featured-list&amp;amp;envId=2cktkvj?envType=featured-list&amp;amp;envId=2cktkvj&quot;&gt;146. LRU 缓存&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;标准写法&lt;/p&gt;
&lt;figu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>字节二面挂，还是人太菜了</title>
    <link href="https://nickxu.me/post/bytedance-interview-failed-2023-09.html"/>
    <id>https://nickxu.me/post/bytedance-interview-failed-2023-09.html</id>
    <published>2023-09-07T09:19:57.000Z</published>
    <updated>2023-09-07T15:28:21.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字节一面">字节一面</h1><ul><li>自我介绍</li><li>简单介绍字节青训营项目</li><li>是组队的吗</li><li>项目耗时</li><li>项目收获的点</li><li>ELK 是你们搭建的吗</li><li>ELK 的软件安装</li><li>数据流大概是怎样的</li><li>是通过什么写到 Logstash 里的</li><li>Logstash 的功能</li><li>你们用的的 fail2ban 是什么</li><li>traceID 介绍</li><li>微服务框架用的什么</li><li>traceID 在框架中是怎么传递的</li><li>对于异步的请求怎么处理的</li><li>这个项目的挑战和难点</li><li>Golang 的 Panic 关键字</li><li>Panic 怎么恢复</li><li>不加 defer 会怎样</li><li>为什么不能恢复</li><li>go 的方法的传值，传递切片，是怎么传的，在里面改变切片，外部能感受到吗</li><li>你说的副本是什么概念</li><li>在函数中 map 改变 kv，外部能感受吗</li><li>传递结构体，一般传值还是传指针</li><li>GMP 模型</li><li>在一个程序中不断起 goroutine，它的队列最终是个什么状态</li><li>一个 G 在一个 M 上执行的时间过长，会怎样调度</li><li>是通过什么策略控制的呢</li><li>刚才说的太长时间你有个时间上的概念吗，什么时间算太长</li><li>协程和线程的区别</li><li>其他的优势，怎么时候选择协程，什么时候不应该选协程</li><li>线程和协程，IO 密集型和 CPU 密集型哪个更适合</li><li>他节省的时间是怎么体现的</li><li>如果我找其他的线程呢？有什么区别</li><li>你比较擅长什么</li><li>MySQL 为什么使用 B+ 树</li><li>分裂与结合，这个是 B 树与 B+ 树的区别吗</li><li>放在叶子结点上导致了什么呢</li><li>还有其他的吗</li><li>了解过跳表吗</li><li>时间复杂度一样吗，跳表和 B+</li><li>为什么 Redis 的 zest 使用了跳表，为什么不用 B+</li><li>MySQL 和 Redis 这两种的本质区别</li><li>有没有可能这两种分别适用于内存和磁盘</li><li>你有什么想问的</li><li>简单编程题 15min：两个 Version 字符串比较大小</li></ul><h1 id="字节二面">字节二面</h1><ul><li>自我介绍</li><li>个人擅长的领域，未来发展</li><li>能实习多长时间</li><li>什么时候可以开始</li><li>你想在哪些方向上，哪些团队实习</li><li>青训营经历</li><li>团队人数，分工</li><li>队长开发吗</li><li>持续时间</li><li>封闭式的吗</li><li>你对这个抖音后端的设计思路</li><li>微服务你这个怎么拆的</li><li>为什么这么拆</li><li>有没有必要把用户拆出来</li><li>微服务好处，实用角度</li><li>服务观测、日志收集，这个是怎么考虑的</li><li>项目难点</li><li>团队项目管理难点</li><li>怎样让协同的质量更高</li><li>做过的其他项目</li><li>跳表是什么</li><li>对比有序的数组的优点</li><li>平衡树是什么概念</li><li>平衡树有什么实现</li><li>某一种平衡树自平衡的思路</li><li>线程和协程的区别</li><li>协程为什么是 kb 级</li><li>开销更小，具体表现在哪些方面</li><li>还有别的吗</li><li>你学过什么计算机基础方面的课程吗</li><li>http 请求的数据包的传输，发生过程</li><li>四次挥手介绍</li><li>tcp 的拥塞算法</li><li>设计模式</li><li>多久接触 go 语言</li><li>gorm 的理解</li><li>技术的角度，你有没有看过源码，或者使用的角度</li><li>你有看过他的实现吗</li><li>乐观锁和悲观锁</li><li>互斥锁什么时候用</li><li>互斥锁使用的注意点</li><li>为什么设计上是不可重入的</li><li>设计上怎么避免重复上锁</li><li>介绍一下Protocol Buffers</li><li>还有吗</li><li>修改名字，换 key，在序列化上有什么注意点吗</li><li>技术上还有什么擅长的没问到的</li><li>缓存一致性</li><li>删除而不是更新是为什么</li><li>删除不会有这个问题吗</li><li>延迟双删再解释一下</li><li>如果中间有人拉了值那不就拉到旧值了</li><li>算法题 15min：手写 LRU</li></ul><h1 id="自我感受">自我感受</h1><p><img src="https://image.nickxu.me/202309072326888.png" alt="e1e010d400b8c12dce93aecd2ebee860"></p><p><img src="https://image.nickxu.me/202309072325699.png" alt="2f20f8a4ee11d8830852953215d693b0"></p><p>字节二面挂，复盘了一下感觉还是自己太菜了</p><p>感觉问的问题也算合理，我应该能答出来才对</p><p>最近发生了好多事情，真的累，以后再说吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字节一面&quot;&gt;字节一面&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;自我介绍&lt;/li&gt;
&lt;li&gt;简单介绍字节青训营项目&lt;/li&gt;
&lt;li&gt;是组队的吗&lt;/li&gt;
&lt;li&gt;项目耗时&lt;/li&gt;
&lt;li&gt;项目收获的点&lt;/li&gt;
&lt;li&gt;ELK 是你们搭建的吗&lt;/li&gt;
&lt;li&gt;ELK 的软件安装&lt;/li&gt;
&lt;li&gt;数据流大概是怎样的&lt;/li&gt;
&lt;li&gt;是通过什么写到 Logstash 里的&lt;/li&gt;
&lt;li&gt;Logstash 的功能&lt;/li&gt;
&lt;li&gt;你们用的的 fail2ban 是什么&lt;/li&gt;
&lt;li&gt;traceID 介绍&lt;/li&gt;
&lt;li&gt;微服务框架用的什么&lt;/li&gt;
&lt;li&gt;traceID 在框架中是怎么传递的&lt;/li&gt;
&lt;li&gt;对于异步的请求怎么处理的&lt;/li&gt;
&lt;li&gt;这个项目的挑战和难点&lt;/li&gt;
&lt;li&gt;Golang 的 Panic 关键字&lt;/li&gt;
&lt;li&gt;Panic 怎么恢复&lt;/li&gt;
&lt;li&gt;不加 defer 会怎样&lt;/li&gt;
&lt;li&gt;为什么不能恢复&lt;/li&gt;
&lt;li&gt;go 的方法的传值，传递切片，是怎么传的，在里面改变切片，外部能感受到吗&lt;/li&gt;
&lt;li&gt;你说的副本是什</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>🌟 你可能感兴趣的文章｜Posts you might be interested in</title>
    <link href="https://nickxu.me/posts-you-might-be-interested-in.html"/>
    <id>https://nickxu.me/posts-you-might-be-interested-in.html</id>
    <published>2023-08-21T16:18:49.000Z</published>
    <updated>2023-08-24T14:45:02.994Z</updated>
    
    <content type="html"><![CDATA[<details class="toggle" ><summary class="toggle-button" style="">Latest Resume｜最近在找实习哦</summary><div class="toggle-content"><p><img src="https://image.nickxu.me/202308242242128.png" alt="image-20230824下午104208821"></p></div></details><h1 id="Junior｜大三">Junior｜大三</h1><p>即将到来的生活，充满未知与期待</p><hr><h1 id="Sophomore｜大二">Sophomore｜大二</h1><ul><li><a href="https://nickxu.me/post/aliyun-oss-brushed-1000rmb-fees.html">阿里云OSS被刷，我交了1000RMB学费！</a></li><li><a href="https://nickxu.me/2023/06/my-story-with-OSPP-from-hearing-to-being-selected.html">『OSPP2023』我与 OSPP 的故事 —— 从听闻到中选</a></li><li><a href="https://nickxu.me/posts/274.html">2023五一总结：近况与将来</a></li><li><a href="https://nickxu.me/2023/03/18/%E5%91%8A%E5%88%ABELK%EF%BC%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9FGrafana-Loki%E5%88%9D%E4%B8%8A%E6%89%8B/">告别ELK！轻量级日志收集系统Grafana Loki初上手</a></li><li><a href="https://nickxu.me/2023/03/13/%E7%AC%AC%E4%BA%94%E5%B1%8A%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%92%E8%AE%AD%E8%90%A5%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">第五届字节跳动青训营项目总结</a></li><li><a href="https://nickxu.me/2023/03/01/%E5%86%99%E5%9C%A8%E5%A4%A7%E4%BA%8C%E5%BC%80%E5%AD%A6%E4%B9%8B%E5%88%9D/">写在大二下开学之初</a></li><li><a href="https://nickxu.me/2022/12/14/%E3%80%8ECI-CD%E3%80%8F%E7%BB%93%E5%90%88GitHub-Actions-Docker%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/">『CI/CD』结合GitHub Actions+Docker实现自动化部署</a></li><li><a href="https://nickxu.me/2022/10/31/%E5%86%99%E5%9C%A810%E6%9C%88%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/">写在10月的最后一天</a></li><li><a href="https://nickxu.me/2022/10/06/%E3%80%8ELinux%E3%80%8F%E5%B0%86-Ubuntu-22-04-%E4%BD%9C%E4%B8%BA%E4%B8%BB%E5%8A%9B%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%84%9F%E6%83%B3/">『Linux』一个多月来将 Ubuntu 22.04 作为主力系统的感想</a></li><li><a href="https://nickxu.me/2022/10/04/%E3%80%8EJWT%E3%80%8F%E5%9C%A8-go-zero-%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8-JWT-%E9%89%B4%E6%9D%83/">『JWT』在 go-zero 框架中使用 JWT 鉴权</a></li><li><a href="https://nickxu.me/2022/09/29/%E3%80%8E%E6%80%BB%E7%BB%93%E3%80%8F2022%20%E5%9B%BD%E5%BA%86%E5%89%8D%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/">『总结』2022 国庆前阶段性总结</a></li><li><a href="https://nickxu.me/2022/10/12/%E3%80%8Ehduhelp%E3%80%8F%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%8E%A5%E5%85%A5%E5%8A%A9%E6%89%8B%20OAuth/">『hduhelp』如何在项目中接入助手 OAuth</a></li><li><a href="https://nickxu.me/2022/09/28/%E3%80%8Ehduhelp%E3%80%8F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8A%A9%E6%89%8B%E7%9A%84%E5%BC%80%E6%94%BE%E6%9C%8D%E5%8A%A1/">『hduhelp』如何使用助手鉴权/使用助手的开放服务</a></li><li><a href="https://nickxu.me/2022/09/18/%E3%80%8E%E9%9A%8F%E7%AC%94%E3%80%8F2022-%E6%9D%AD%E5%8A%A9%E6%8B%9B%E6%96%B0%E9%9D%A2%E8%AF%95%E6%84%9F%E6%83%B3/">『随笔』面试官竟是我自己 —— 2022 杭助秋招面试工作感想</a></li><li><a href="https://nickxu.me/2022/09/30/GORM-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%89%8D%E8%A8%80%E4%B8%8E%E4%BB%8B%E7%BB%8D/">GORM 入门笔记（一）前言与介绍</a></li><li><a href="https://nickxu.me/2022/09/11/%E3%80%8ETwikoo%E3%80%8F%E8%A7%A3%E5%86%B3-Vercel-app-%E5%9C%A8%E5%9B%BD%E5%86%85%E8%A2%AB%E5%A2%99%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/">『Twikoo』解决 Vercel.app 在国内被墙导致无法使用的问题</a></li><li><a href="https://nickxu.me/2022/09/10/%E3%80%8E%E9%9A%8F%E7%AC%94%E3%80%8F%E5%86%99%E5%9C%A8%E6%96%B0%E5%AD%A6%E5%B9%B4%E4%BC%8A%E5%A7%8B/">『随笔』写在新学年伊始</a></li></ul><hr><h1 id="Freshman｜大一">Freshman｜大一</h1><ul><li><a href="https://nickxu.me/2022/06/29/%E3%80%8EGitHub%E3%80%8F%E5%AD%A6%E7%94%9F%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E9%97%AE%E9%A2%98/">『GitHub』学生身份认证问题</a></li><li><a href="https://nickxu.me/2022/06/14/%E3%80%8E%E9%9A%8F%E7%AC%94%E3%80%8F618%E6%A1%8C%E9%9D%A2%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92/">『随笔』618桌面改造计划</a></li><li><a href="https://nickxu.me/2022/06/12/%E3%80%8E%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5%E3%80%8F%E7%BB%93%E8%90%A5%E6%84%9F%E6%83%B3/">『字节青训营-3rd』结营感想（待后续）</a></li><li><a href="https://nickxu.me/2022/05/26/%E3%80%8EGit%E3%80%8F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Git-%E5%8F%82%E4%B8%8E%E6%9D%AD%E5%8A%A9%E7%9A%84%E9%A1%B9%E7%9B%AE/">『Git』如何使用 Git 参与杭助的项目</a></li><li><a href="https://nickxu.me/2022/05/21/%E3%80%8EWSL%E3%80%8F%E5%9C%A8WSL%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%BB%E6%9C%BA%E7%9A%84%E4%BB%A3%E7%90%86/">『WSL』在 WSL 中使用主机的代理（以 Clash 为例）</a></li><li><a href="https://nickxu.me/2022/04/23/%E3%80%8E%E5%AE%9E%E8%AE%B0%E3%80%8F%E2%80%9C%E9%9F%B5%E5%91%B3%E6%9D%AD%E5%B7%9E%E2%80%9D%E6%B5%8B%E8%AF%95%E8%B5%9B%E7%90%83%E7%AB%A5%E5%BF%97%E6%84%BF%E7%BB%8F%E5%8E%86/">『实记』“韵味杭州”测试赛球童志愿经历</a></li><li><a href="https://nickxu.me/2022/04/17/%E3%80%8E%E6%80%BB%E7%BB%93%E3%80%8F%E5%A4%A7%E4%B8%80%E4%B8%8B%E6%9C%9F%E4%B8%AD%E6%80%BB%E7%BB%93/">『总结』大一下期中总结</a></li><li><a href="https://nickxu.me/2022/04/10/%E3%80%8EOthers%E3%80%8F%E7%AC%AC%E4%B8%89%E5%B1%8A%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%92%E8%AE%AD%E8%90%A5-%E5%90%8E%E7%AB%AF%E4%B8%93%E5%9C%BA-%E6%97%A9%E7%9F%A5%E6%99%93%E7%9B%B4%E6%92%AD%E4%BC%9A%E8%AE%AE%E7%BA%AA%E8%A6%81/">『Others』第三届字节跳动青训营 - 后端专场 早知晓直播会议纪要</a></li><li><a href="https://nickxu.me/2022/01/18/gin-ru-men-bi-ji-yi-chu-shi-gin-yu-huan-jing-da-jian/">Gin 入门笔记（一）环境搭建、简单的路由配置</a></li><li><a href="https://nickxu.me/2022/03/21/%E3%80%8EWSL%E3%80%8F%E8%A7%A3%E5%86%B3%E6%AF%8F%E6%AC%A1%E5%90%AF%E5%8A%A8%E5%90%8E%E8%87%AA%E5%8A%A8%E5%88%86%E9%85%8D-IP-%E7%9A%84%E9%97%AE%E9%A2%98/">『WSL』解决每次启动后自动分配 IP 的问题</a></li><li><a href="https://nickxu.me/2022/03/13/%E3%80%8E%E6%9D%82%E6%96%87%E3%80%8F%E5%9C%A8%E8%BF%B7%E8%8C%AB%E4%B8%AD%E5%89%8D%E8%BF%9B/">『杂文』在迷茫中前进</a></li><li><a href="https://nickxu.me/2022/03/02/Python-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/">Python 入门笔记（一）搭建环境</a></li><li><a href="https://nickxu.me/2022/03/01/Java-%E7%89%88-Minecraft-%E5%8A%A0%E6%A8%A1%E7%BB%84%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/">Java 版 Minecraft 加模组开服教程</a></li><li><a href="https://nickxu.me/2022/02/28/%E3%80%8ELinux%E3%80%8FNginx-%E9%85%8D%E7%BD%AE-SSL-%E8%AF%81%E4%B9%A6/">『Linux』Nginx 配置 SSL 证书</a></li><li><a href="https://nickxu.me/2021/12/31/cc-vscode-huan-jing-pei-zhi/">『C/C++』VScode 环境配置</a></li><li><a href="https://nickxu.me/2022/02/13/Hexo%20+%20Butterfly%20%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%EF%BC%88%E3%80%87%EF%BC%89%E5%89%8D%E8%A8%80/">Hexo + Butterfly 建站指南（〇）前言</a></li></ul><hr><h1 id="High-School｜高中">High School｜高中</h1><ul><li><a href="https://nickxu.me/2020/02/20/shu-mei-pai-ru-he-yi-zheng-que-de-zi-shi-zhi-zuo-shu-mei-pai-de-tf-qia-shu-ju-jing-xiang/">『树莓派』如何以正确的姿势制作树莓派的TF卡数据镜像</a></li><li><a href="https://nickxu.me/2020/01/26/shu-mei-pai-minecraft-chao-chang-kai-fu-zhe-teng-ji-lu-javaji-yan-with-hong-shi/">『树莓派』Minecraft超长开服折腾记录（Java+基岩with红石）</a></li><li><a href="https://nickxu.me/2019/11/14/cc-2019csp-mo-ban/">『C/C++』2019CSP模板</a></li><li><a href="https://nickxu.me/2019/07/23/suan-fa-zong-jie-ou-ji-li-de-suan-fa-ji-tuo-zhan/">『算法』总结欧几里得算法及拓展</a></li><li><a href="https://nickxu.me/2019/07/15/suan-fa-zong-jie-kmp-suan-fa/">『算法』总结KMP算法</a></li><li><a href="https://nickxu.me/2019/07/10/shu-mei-pai-da-jian-si-you-yun-fu-wu-qi-nextcloud/">『树莓派』搭建私有云服务器（Nextcloud）</a></li><li><a href="https://nickxu.me/2019/07/06/shu-mei-pai-wifi-xin-hao-zhong-ji/">『树莓派』WiFi信号中继</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;details class=&quot;toggle&quot; &gt;&lt;summary class=&quot;toggle-button&quot; style=&quot;&quot;&gt;Latest Resume｜最近在找实习哦&lt;/summary&gt;&lt;div class=&quot;toggle-content&quot;&gt;&lt;p&gt;&lt;img src=&quot;https://image.nickxu.me/202308242242128.png&quot; alt=&quot;image-20230824下午104208821&quot;&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/details&gt;
&lt;h1 id=&quot;Junior｜大三&quot;&gt;Junior｜大三&lt;/h1&gt;
&lt;p&gt;即将到来的生活，充满未知与期待&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Sophomore｜大二&quot;&gt;Sophomore｜大二&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://nickxu.me/post/aliyun-oss-brushed-1000rmb-fees.html&quot;&gt;阿里云OSS被刷，我交了1000RMB学费！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nickxu.me/2023/06/my-story-wit</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>阿里云OSS被刷，我交了1000RMB学费</title>
    <link href="https://nickxu.me/post/aliyun-oss-brushed-1000rmb-fees.html"/>
    <id>https://nickxu.me/post/aliyun-oss-brushed-1000rmb-fees.html</id>
    <published>2023-08-19T02:38:24.000Z</published>
    <updated>2023-10-09T12:14:15.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大致经过">大致经过</h1><h2 id="垂死病中惊坐起😱">垂死病中惊坐起😱</h2><img src="https://image.nickxu.me/202308191506591.png" alt="image-20230819下午30609530" style="zoom:50%;" /><blockquote><p>事情发生在 8 月 8 日凌晨，凌晨三点我突然看见手机上的消息</p></blockquote><p>我一开始是疑惑的，我的 OSS 是用来当做图床的，一个月也用不了几个钱</p><p>账号里记得还有 20 多块钱，怎么会这么快用完</p><p>然后我进阿里云一看，哇，我被人刷了？</p><p><img src="https://image.nickxu.me/202308191512039.png" alt="image-20230819下午31250992"><img src="https://image.nickxu.me/202308191513456.png" alt="image-20230819下午31311428"></p><p><img src="https://image.nickxu.me/202308191514660.png" alt="image-20230819下午31405635"></p><blockquote><p>最后发现被刷了 3.57 TB，请求了 138 万次</p></blockquote><p>哇，我从没想到过这种事情会发生在我的身上</p><p>而且我停机之后他还一直在刷，根本不带停的（</p><img src="https://image.nickxu.me/202308191534994.png" alt="55d88e13ece3787389f2e55c5ca8c71f" style="zoom:50%;" /><p>我想，算了，300 块交学费得了，以后得好好重视</p><p>然后我下午就看见了——</p><h2 id="1000-软妹币的账单😭">1000 软妹币的账单😭</h2><p><img src="https://image.nickxu.me/202308191544460.png" alt="897cdaf323ff4619efb6bd2975ef2716"></p><blockquote><p>1000 RMB！这下真的被上课了😱</p></blockquote><p><img src="https://image.nickxu.me/202308191544007.png" alt="f565bb21f42f5915ba0f99219b92dd27"></p><p>由于账单会有几小时的延迟，很多人说为什么欠费了不自动停，其实等你欠费的时候，人家已经刷完了</p><p>这次在我发现的时候，就已经结束了</p><img src="https://image.nickxu.me/202308191550486.png" alt="9ae17dca6a3b4610815e748cccf27cd0" style="zoom: 25%;" /><p>真的太可怕了，直接大出血</p><p>花了好久才缓过来劲</p><h2 id="可能的原因">可能的原因</h2><p>我感觉最可能的原因，是我前段时间我写的一个玩具被人发到 Twitter 上了（<a href="https://twitter.com/ProbiusOfficial/status/1687339560144093184?s=20">属于是间接出圈</a></p><img src="https://image.nickxu.me/202308191600438.png" alt="412e8c4d11403878c10ddb6629e71825" style="zoom:33%;" /><p>然后就别人盯上了🥹</p><p><s>当时还挺高兴的，这属于是出名的代价吗</s></p><h2 id="寻求客服">寻求客服</h2><p>最后我想看看找一手客服，其实我是不报希望的，看了一堆案例都是自己承担的</p><img src="https://image.nickxu.me/202308191552445.png" alt="image-20230819下午35242417" style="zoom:50%;" /><blockquote><p>结果的确如此，真的是交了 1000 RMB 学费了</p></blockquote><hr><h1 id="解决方案">解决方案</h1><p>事已至此，接下来的事情就是寻找解决方案了</p><p>在与群友交流和不断 Google 后，我总结了几种比较好的图床解决方案：</p><ol><li>国内云 OSS + 国内云 CDN（如果你很在意国内的访问速度）</li><li>国内云 OSS + Cloudflare（比较推荐的方案，但是国内访问不会很快）</li><li>Cloudflare R2（如果你有信用卡）</li><li>某些奇技淫巧</li></ol><h2 id="国内云-OSS-国内云-CDN">国内云 OSS + 国内云 CDN</h2><p>主要思路：关闭 OSS 的直接访问，只能通过 CDN 进行访问，并使用 CDN 的流量防护措施</p><p>一方面， CDN 的流量更加便宜</p><p>另一方面，你可以通过 CDN 对流量进行限制，例如限制总流量，限制最大带宽自动停机，限制 IP qps 等等</p><p>当然你也可以说我能在 OSS 上进行防护，比如说防盗链之类的</p><p>但这其实防不胜防，真要有人想搞你换个 header 就行，只能限额，而且 OSS 防火墙规则好少</p><p>总结：</p><ul><li>优点：国内访问快</li><li>缺点：需要你同时操心 OSS 和 CDN，而且国内 CDN 域名应该需要备案</li></ul><p>教程：这种教程很多，我就贴一个阿里云的吧 <a href="https://www.alibabacloud.com/help/zh/oss/user-guide/use-cdn-to-accelerate-access-to-oss">使用CDN加速OSS访问</a></p><h2 id="国内云-OSS-Cloudflare">国内云 OSS + Cloudflare</h2><p>如果你还不了解 Cloudflare，你可以先去了解一下</p><p>主要思路：由于阿里云加入了 Cloudflare 带宽联盟，你可以通过 Cloudflare 访问 OSS 中的图片，而无需支付流量费用</p><p>我没有实操过这个方案，但是下面是我感觉需要注意的事项：</p><ol><li>必须是非大陆的 OSS 才能走  CF ，比如香港（有人说必须国际站，这个不清楚）</li><li>经历不要让他人发现源 OSS</li></ol><p>总结：</p><ul><li>优点：只需支付 OSS 的存储费用</li><li>缺点：国内访问不会很快</li></ul><p>相关链接：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/605406893">阿里云OSS套CloudFlare储存WordPress博客网站图片并达到免费加速效果</a></li><li><a href="https://luotianyi.vc/6044.html">【对象存储】搭配CF带宽联盟实现流量免费</a></li><li><a href="https://fmk.im/p/cloudflare-oss/">Cloudflare与阿里云OSS配合使用的一点小问题</a></li><li><a href="https://www.v2ex.com/t/923655">想咨询下 跨境电商商品图片 如何存储和展示, cloudflare 家</a></li></ul><h2 id="Cloudflare-R2">Cloudflare R2</h2><p>主要思路：使用 Cloudflare R2 代替阿里云 OSS，这也是我最后采取的方案</p><p>R2 是 Cloudflare 推出的 S3 兼容的对象存储，最大的特点是就是便宜，量大管饱</p><p><img src="https://image.nickxu.me/202308191434581.png" alt="e81872a0f282add5b8058c27e41cefd4"></p><p>他的不是用流量计费的，而是用访问次数计费的，而且每月有免费额度</p><p>感觉这个每月 1000 万的读操作额度已经远远超过使用需求（我本次遭受的攻击也就 100万次访问）</p><p>并且 10G/月 的免费存储用作图床也是足够的</p><p>最大的缺点就是需要绑信用卡，即使你仅仅想使用免费额度也是如此</p><p><img src="https://image.nickxu.me/202308191454808.png" alt=""></p><p>于是我让群友转了点 USDT，去整了个 <a href="https://card.onekey.so/?i=YQOVM1">OneKey</a> 的卡</p><p><img src="https://image.nickxu.me/202308191459910.png" alt="image-20230819下午25900887"></p><p>下面是我当时看的两个教程</p><ul><li><a href="https://youtu.be/U0aTo71ZmvM">Depay全新升级：Dupay Visa卡来了！如何开卡充值USDT？与Master卡有何不同？</a></li><li><a href="https://youtu.be/UXHzP9g-mus">虚拟信用卡哪家强？Onekey vs Dupay，充值USDC/USDT实际损耗测算，答案和你想的一样吗？</a></li></ul><p>关于 R2 的安全性，我感觉是可以放心的，毕竟被刷 cf 肯定不会坐视不管，而且我也配置了一些规则</p><p>总结：</p><ul><li>优点：理论上不会有任何费用</li><li>缺点：国内访问不会很快（你现在看的图片都是 R2 上的，你感觉怎么样👀</li></ul><h2 id="其他方案">其他方案</h2><p>其他方案，你可以去用一些图床服务，但是我感觉不是很心动</p><p>你可能话说放 GitHub 上，但是 GitHub 单仓库 2G，我目前的图片就已经 1G 多了</p><p>又或者，还有一些奇技淫巧哈哈哈😂</p><p>比如说这个 <a href="https://github.com/cf-pages/Telegraph-Image">https://github.com/cf-pages/Telegraph-Image</a></p><h1 id="总结">总结</h1><h2 id="做好安全防护">做好安全防护</h2><p>一定要做好安全防护哇！</p><p>一定一定一定！</p><p>就当是我为大家交了学费了，你也保证一下以后不会被交学费了好不好😭</p><h2 id="缩减照片大小">缩减照片大小</h2><p>群友问的另一个问题就是为什么我的图片这么大</p><p>其实也是，我没有压缩处理一下</p><p>于是我在 PicGo 里找了一番插件，以后就上传压缩后的图片了</p><img src="https://image.nickxu.me/202308191444053.png" alt="image-20230819下午24432015" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大致经过&quot;&gt;大致经过&lt;/h1&gt;
&lt;h2 id=&quot;垂死病中惊坐起😱&quot;&gt;垂死病中惊坐起😱&lt;/h2&gt;
&lt;img src=&quot;https://image.nickxu.me/202308191506591.png&quot; alt=&quot;image-20230819下午30609530&quot; style=&quot;zoom:50%;&quot; /&gt;
&lt;blockquote&gt;
&lt;p&gt;事情发生在 8 月 8 日凌晨，凌晨三点我突然看见手机上的消息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我一开始是疑惑的，我的 OSS 是用来当做图床的，一个月也用不了几个钱&lt;/p&gt;
&lt;p&gt;账号里记得还有 20 多块钱，怎么会这么快用完&lt;/p&gt;
&lt;p&gt;然后我进阿里云一看，哇，我被人刷了？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.nickxu.me/202308191512039.png&quot; alt=&quot;image-20230819下午31250992&quot;&gt;&lt;img src=&quot;https://image.nickxu.me/202308191513456.png&quot; alt=&quot;image-20230819下午3131</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『Golang』并发编程之通道（Channel）</title>
    <link href="https://nickxu.me/post/golang-concurrent-programming-channel.html"/>
    <id>https://nickxu.me/post/golang-concurrent-programming-channel.html</id>
    <published>2023-08-17T14:08:01.000Z</published>
    <updated>2023-08-18T12:17:08.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通道（Channel）">通道（Channel）</h1><blockquote><p>通道是什么，为什么使用通道</p></blockquote><p>「不要通过共享内存来通信，而应该通过通信来共享内存」</p><p>通道可以在多个 goroutine 之间传递数据</p><p>一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符 <code>&lt;-</code>。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向</p><blockquote><p>如何初始化通道</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">    ch1 &lt;- <span class="number">2</span></span><br><span class="line">    ch1 &lt;- <span class="number">1</span></span><br><span class="line">    ch1 &lt;- <span class="number">3</span></span><br><span class="line">    elem1 := &lt;-ch1</span><br><span class="line">    fmt.Printf(<span class="string">&quot;The first element received from channel ch1: %v\n&quot;</span>,elem1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 <code>make</code> 函数声明并初始化通道</li><li>通道的容量是 <code>int</code> 类型，但是不能小于 0 （缓冲通道和非缓冲通道）</li></ol><blockquote><p>通道的发送和接收操作都有哪些基本的特性</p></blockquote><ol><li>对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的</li><li>发送操作和接收操作中，对元素值的处理都是不可分割的</li><li>发送操作在完全完成之前会被阻塞，接收操作也是如此</li><li>元素值从外界进入通道时会被复制<ul><li>非缓冲通道的数据是直接从发送方复制到接收方</li><li>大多数情况下缓冲通道都会中转数据，如果发送时正好有人在等着接收，则会直接复制过去</li></ul></li></ol><blockquote><p>什么时候会阻塞</p></blockquote><p>正常情况下</p><ul><li>缓冲通道：如果通道已满，所有的发送操作会被依次阻塞</li><li>非缓冲通道：无论是发送操作还是接收操作，一开始执行的时候都会被阻塞，直到配对的操作也开始执行</li></ul><p>不正常情况</p><ul><li>值为 <code>nil</code> （没有使用 <code>make</code> 初始化）时，两种操作都会被永久阻塞</li></ul><blockquote><p>什么时候会 panic</p></blockquote><ul><li>对关闭的通道发送数据</li><li>对关闭的通道再次关闭</li></ul><blockquote><p>关闭的通道有什么性质</p></blockquote><p>关闭通道是指关闭通道的入口，通道关闭后仍可以从中取出数据</p><p>如果接收两个值，第二个值是 <code>bool</code> ，表示还能不能取出元素</p><p>如果值为 <code>false</code> ，表示通道已经关闭并且没有元素了，此时第一个元素会是零值</p><p>如果值为 <code>true</code> ，表示成功地取出了元素，注意你此时无法判断通道是否关闭</p><p>因此使用这个 <code>bool</code> 值判断通道是否关闭是有延迟的</p><p>永远在发送方关闭通道，不能在接收方关闭通道</p><blockquote><p>什么是单向通道，有什么用</p></blockquote><p>如果声明时包含接收操作符（<code>&lt;-</code>），就是单向通道</p><ul><li>发送通道：<code>chan&lt;-</code> ，只能发不能收</li><li>接收通道：<code>&lt;-chan</code> ，只能收不能发</li></ul><p>单向通道可以限制其他代码的行为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendInt</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    ch &lt;- rand.Intn(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里限制了函数内只能向通道内发送元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">    SendInt(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，还有可以用在接口里</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntChan</span><span class="params">()</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">    num := <span class="number">5</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, num)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">      ch &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里限制了得到返回值的程序，只能从通道中接收元素</p><blockquote><p>怎么用 <code>for range</code> 从通道中取出元素</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intChan2 := getIntChan()</span><br><span class="line"><span class="keyword">for</span> elem := <span class="keyword">range</span> intChan2 &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;The element in intChan2: %v\n&quot;</span>, elem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性质与正常操作时相同</p><blockquote><p><code>select</code> 如何与通道连用</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg1 := &lt;-ch1:</span><br><span class="line">        fmt.Println(msg1)</span><br><span class="line">    <span class="keyword">case</span> msg2 := &lt;-ch2:</span><br><span class="line">        fmt.Println(msg2)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;没有收到任何消息&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>select</code> 语句只能与通道联用，是一种多路通信选择的控制结构，允许一个 goroutine 等待多个通信操作</p><p>它由若干个分支组成。每次执行这种语句的时候，只有一个分支中的接收/发送代码会被运行</p><blockquote><p>select` 语句的分支选择规则有哪些</p></blockquote><ul><li><p>如果所有分支都阻塞，则会运行 <code>defult</code> 分支</p><p>（也就是说含有默认分支的 <code>select</code> 永远不会阻塞）</p></li><li><p>如果所有分支都阻塞，又没有 <code>defult</code> 分支，则会一直阻塞，直到有分支可以执行</p></li><li><p>如果同时有多个分支可以执行，则会随机选择一个</p></li></ul><blockquote><p>使用 <code>select</code> 的注意事项</p></blockquote><ul><li><p>如果通道关闭了，接收并不会阻塞，而同时获得零值与 <code>false</code></p><p>所以如果发现通道关闭了，应当及时屏蔽对应的分支或者采取其他措施</p><p>（将通道赋值为 <code>nil</code> 可以屏蔽改对应的分支了，因为 <code>nil</code> 的通道是一直阻塞的）</p></li><li><p><code>select</code> 语句只会将某分支的通道操作运行一次，所以如果你想连续操作的话，可以在 <code>for</code> 中使用 <code>select</code></p><p>但是如果你在 <code>select</code> 中使用 <code>break</code> 的话，只会跳出当前 <code>select</code>，而 <code>for</code> 并不会跳出</p><p>（如果想将 <code>for</code> 也跳出，可以在 <code>for</code> 前面放一个 <code>label</code>，再将 <code>label</code> 与 <code>break</code> 一起使用）</p></li><li><p>尽管 <code>select</code> 本身是并发安全的，但是不代表你的 <code>case</code> 表达式和分支中的代码也是并发安全的</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通道（Channel）&quot;&gt;通道（Channel）&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;通道是什么，为什么使用通道&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;「不要通过共享内存来通信，而应该通过通信来共享内存」&lt;/p&gt;
&lt;p&gt;通道可以在多个 goroutine 之间传递数据&lt;/p&gt;
&lt;p&gt;一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符 &lt;code&gt;&amp;lt;-&lt;/code&gt;。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何初始化通道&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/sp</summary>
      
    
    
    
    <category term="Golang" scheme="https://nickxu.me/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>『LeetCode-HOT-100』T41～T50</title>
    <link href="https://nickxu.me/post/leetcode-hot-100-t41-t50.html"/>
    <id>https://nickxu.me/post/leetcode-hot-100-t41-t50.html</id>
    <published>2023-08-13T06:06:21.000Z</published>
    <updated>2023-08-29T04:05:29.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的层序遍历"><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></h1><p>简单的 BFS 练习</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    ans := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line">    queue := []TreeNode&#123;&#125;</span><br><span class="line">    queue = <span class="built_in">append</span>(queue, *root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line">        tmpAns := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">        nextLevel := []TreeNode&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line">            curr := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">            tmpAns = <span class="built_in">append</span>(tmpAns, curr.Val)</span><br><span class="line">            <span class="keyword">if</span> curr.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                nextLevel = <span class="built_in">append</span>(nextLevel, *curr.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> curr.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                nextLevel = <span class="built_in">append</span>(nextLevel, *curr.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = <span class="built_in">append</span>(ans, tmpAns)</span><br><span class="line">        queue = nextLevel</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二叉树的最大深度"><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></h1><p>直接上一题改改哈哈哈</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line">    queue := []TreeNode&#123;&#125;</span><br><span class="line">    queue = <span class="built_in">append</span>(queue, *root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line">        ans++</span><br><span class="line">        nextLevel := []TreeNode&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line">            curr := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> curr.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                nextLevel = <span class="built_in">append</span>(nextLevel, *curr.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> curr.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                nextLevel = <span class="built_in">append</span>(nextLevel, *curr.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue = nextLevel</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="从前序与中序遍历序列构造二叉树"><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a></h1><p>前序中左右，中序左中右，后序左右中（「中」在前、在中、在后）</p><p>二叉树基本功</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="type">int</span>, inorder []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;TreeNode&#123;</span><br><span class="line">            Val:   preorder[<span class="number">0</span>],</span><br><span class="line">            Left:  <span class="literal">nil</span>,</span><br><span class="line">            Right: <span class="literal">nil</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ans:=&amp;TreeNode&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    midVal := preorder[<span class="number">0</span>] <span class="comment">// mid 的值</span></span><br><span class="line">    inorderMinIdx := <span class="number">0</span>    <span class="comment">// mid 在中序的位置</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(inorder); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> inorder[i] == midVal &#123;</span><br><span class="line">            inorderMinIdx = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leftInorder := inorder[:inorderMinIdx]</span><br><span class="line">    rightInorder := inorder[inorderMinIdx+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为 len(「右」) 在前序和中序是一样的，并且都在结尾</span></span><br><span class="line">    <span class="comment">// 所以很容易能把前序的「左」「右」区分开来</span></span><br><span class="line">    lenRight := <span class="built_in">len</span>(inorder) - inorderMinIdx</span><br><span class="line">    leftPreorder := preorder[<span class="number">1</span> : <span class="built_in">len</span>(preorder)-lenRight+<span class="number">1</span>]</span><br><span class="line">    rightPreorder := preorder[<span class="built_in">len</span>(preorder)-lenRight+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fmt.Println(&quot;leftInorder&quot;,leftInorder)</span></span><br><span class="line">    <span class="comment">// fmt.Println(&quot;rightInorder&quot;,rightInorder)</span></span><br><span class="line">    <span class="comment">// fmt.Println(&quot;leftPreorder&quot;,leftPreorder)</span></span><br><span class="line">    <span class="comment">// fmt.Println(&quot;rightPreorder&quot;,rightPreorder)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;TreeNode&#123;</span><br><span class="line">        Val:   midVal,</span><br><span class="line">        Left:  buildTree(leftPreorder, leftInorder),</span><br><span class="line">        Right: buildTree(rightPreorder, rightInorder),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树展开为链表"><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a></h1><p>要求展开成先序遍历一样的顺序</p><p>首先你遍历的同时构造新链表肯定是可以的，但是这样就没意思了，肯定得写个原地的</p><p>首先先序是中左右，所以你把左和右分别搞定之后，再拼一起就行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatten</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">   _ = myFlatten(root)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFlatten</span><span class="params">(root *TreeNode)</span></span> (tail *TreeNode) &#123;</span><br><span class="line">   <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> root</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   leftTail := myFlatten(root.Left)</span><br><span class="line">   rightTail := myFlatten(root.Right)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> leftTail != <span class="literal">nil</span> &#123;</span><br><span class="line">      leftTail.Left = <span class="literal">nil</span></span><br><span class="line">      leftTail.Right = root.Right</span><br><span class="line">      root.Right = root.Left</span><br><span class="line">      root.Left = <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> rightTail != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> rightTail</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> leftTail</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></h1><p>首先暴力肯定没问题，但是数据量大了会 TLE</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(prices)</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            v := prices[j] - prices[i]</span><br><span class="line">            <span class="keyword">if</span> v &gt; ans &#123;</span><br><span class="line">                ans = v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实实质就是找到差别最大的两个数字，并且小的在前面</p><p>求出相邻之间的 <code>diff</code> 数组，然后遍历即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(prices)</span><br><span class="line">    diff := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        diff[i] = prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    curr := <span class="number">0</span></span><br><span class="line">    <span class="comment">// fmt.Println(diff)</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        curr += diff[i]</span><br><span class="line">        <span class="keyword">if</span> curr &gt; ans &#123;</span><br><span class="line">            ans = curr</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> curr &lt; <span class="number">0</span> &#123;</span><br><span class="line">            curr = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><s>dp 我也想了，但是想了半天都是 n 方的（</s></p><p>结果看见了<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solutions/136684/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/comments/930057">这条评论</a>，感觉还是人外有人👀（</p><h1 id="二叉树中的最大路径和"><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">二叉树中的最大路径和</a></h1><p>第一眼：嗯？图的最长路算法？</p><p>但是这个数据量应该来不及转换成图然后处理</p><p>第二眼：嗯？树形 dp？</p><p>但是有个问题就是不好确定起点哇，如果是必须经过 <code>root</code> 的话还可以左右两边分别 dp，然后合一起</p><p>仔细思考，我感觉可以从所有的叶子结点向 <code>root</code> 开始 dp，转移方程就是，每一个分支结点都可以选择继承左儿子，或者继承右儿子，或者都不继承</p><p>但是这个遍历顺序有点难搞，算了，还是写成记忆化搜索吧（dp 其实就是记忆化搜索 Pro Max）</p><p>哎等等？好像可以直接写成搜索？</p><p>再等等？好像少了一种情况，或者在当前打住，把两边拉一起，但是上面不能再引用这个数据（啊我好像知道 ans 怎么求了</p><p>啊好像还得加个只选自身结点</p><p>啊还有只选左边和只选右边</p><p>我去我居然手搓过了一个 hard，成绩还这么好😭</p><p><img src="https://image.nickxu.me/202308291204954.png" alt="image-20230813下午113211729"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxPathSum</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := math.MinInt</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(curr *TreeNode)</span></span> <span class="type">int</span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(curr *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> left, right <span class="type">int</span></span><br><span class="line">        <span class="keyword">if</span> curr.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            left = dfs(curr.Left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> curr.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            right = dfs(curr.Right)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = max(ans,</span><br><span class="line">            left+right+curr.Val,</span><br><span class="line">            left+curr.Val,</span><br><span class="line">            right+curr.Val,</span><br><span class="line">            curr.Val,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(left+curr.Val, right+curr.Val, curr.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    _ = dfs(root)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    max := a[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; max &#123;</span><br><span class="line">            max = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长连续序列"><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">最长连续序列</a></h1><p>啊，一眼貌似 dp，但是我想不出怎么写</p><p>能不能用桶排的思路呢？数据范围太大了</p><p>但是要求 <code>O(n)</code> ，我感觉也只有 dp 了哇</p><p>实在写不出来，一看标签，卧槽，有并查集，但是也不行哇（</p><p>看了题解之后：</p><p>原来哈希表不是 <code>O(logn)</code> 哇， 我一直以为 <code>map</code> 是 <code>O(logn)</code>，那没事了~~（高中学的 C++ 的 <code>std::map</code> 说是基于红黑树的，红黑树是 <code>O(logn)</code>，所以一直记得 <code>map</code> 就是 <code>O(logn)</code>~~</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestConsecutive</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    fa := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    exist := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)</span><br><span class="line">    count := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        fa[nums[i]] = nums[i]</span><br><span class="line">        exist[nums[i]] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> x != fa[x] &#123;</span><br><span class="line">            fa[x] = fa[fa[x]]</span><br><span class="line">            x = fa[x]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    combine := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// fmt.Println(a,b)</span></span><br><span class="line">        fa[find(a)] = find(b)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> exist[nums[i]<span class="number">-1</span>] &#123;</span><br><span class="line">            combine(nums[i], nums[i]<span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> exist[nums[i]+<span class="number">1</span>] &#123;</span><br><span class="line">            combine(nums[i], nums[i]+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> exist &#123;</span><br><span class="line">        count[find(i)]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fmt.Println(n)</span></span><br><span class="line">    <span class="comment">// fmt.Println(fa)</span></span><br><span class="line">    <span class="comment">// fmt.Println(exist)</span></span><br><span class="line">    <span class="comment">// fmt.Println(count)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> count &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; ans &#123;</span><br><span class="line">            ans = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="只出现一次的数字"><a href="https://leetcode.cn/problems/single-number/">只出现一次的数字</a></h1><p>完全想不出「该算法只使用常量额外空间」的方法</p><p>我能想到的是一个变量连续计算，然后两个相同的能自动抵消，<code>O(n)</code> 只能是这样，但是想不出来</p><p>一看标签卧槽位运算</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        ans ^= i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单词拆分"><a href="https://leetcode.cn/problems/word-break/">单词拆分</a></h1><p>先来个暴力好吧，但是 TLE 了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(s <span class="type">string</span>, wordDict []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> wordDict &#123;</span><br><span class="line">        <span class="keyword">if</span> isTrim(s, word) &amp;&amp; wordBreak(s[<span class="built_in">len</span>(word):], wordDict) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isTrim</span><span class="params">(s, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(t) == <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">return</span> s == t</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i] != t[i] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想改进一下这个暴力，如果 wordDict 中有单词可以由其他单词组合成，那就可以忽略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(s <span class="type">string</span>, wordDict []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    wordDict= prework(wordDict)</span><br><span class="line">    <span class="keyword">return</span> myWordBreak(s,wordDict)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prework</span><span class="params">(wordDict []<span class="type">string</span>)</span></span> []<span class="type">string</span>&#123;</span><br><span class="line">    ans := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(wordDict);i++&#123;</span><br><span class="line">        ext:=<span class="built_in">make</span>([]<span class="type">string</span>,<span class="built_in">len</span>(wordDict)<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">copy</span>(ext,wordDict[:i])</span><br><span class="line">        <span class="built_in">copy</span>(ext[i:],wordDict[i+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">if</span> !myWordBreak(wordDict[i],ext)&#123;</span><br><span class="line">            ans=<span class="built_in">append</span>(ans,wordDict[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myWordBreak</span><span class="params">(s <span class="type">string</span>, wordDict []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,word:=<span class="keyword">range</span> wordDict&#123;</span><br><span class="line">        <span class="keyword">if</span> isTrim(s,word)&amp;&amp;myWordBreak(s[<span class="built_in">len</span>(word):],wordDict) &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isTrim</span><span class="params">(s,t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(t)&gt;<span class="built_in">len</span>(s)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(t)==<span class="built_in">len</span>(s)&#123;</span><br><span class="line">        <span class="keyword">return</span> s == t</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(t);i++&#123;</span><br><span class="line">            <span class="keyword">if</span> s[i]!=t[i]&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是还是 TLE 了😭</p><p>再优化一手试试，来点记忆化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vis = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line"><span class="keyword">var</span> flag <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(s <span class="type">string</span>, wordDict []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    flag = <span class="literal">false</span></span><br><span class="line">    vis = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    wordDict = prework(wordDict)</span><br><span class="line">    vis = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> myWordBreak(s, wordDict)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prework</span><span class="params">(wordDict []<span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    ans := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(wordDict); i++ &#123;</span><br><span class="line">        ext := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(wordDict)<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">copy</span>(ext, wordDict[:i])</span><br><span class="line">        <span class="built_in">copy</span>(ext[i:], wordDict[i+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">if</span> !myWordBreak(wordDict[i], ext) &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, wordDict[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myWordBreak</span><span class="params">(s <span class="type">string</span>, wordDict []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> flag &#123;</span><br><span class="line">        <span class="keyword">if</span> val, ok := vis[s]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> wordDict &#123;</span><br><span class="line">        <span class="keyword">if</span> isTrim(s, word) &amp;&amp; myWordBreak(s[<span class="built_in">len</span>(word):], wordDict) &#123;</span><br><span class="line">            vis[s] = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[s] = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isTrim</span><span class="params">(s, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(t) == <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">return</span> s == t</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i] != t[i] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>居然过了🤣</p><p>言归正传，这个问题最好的方法肯定是 dp，GPT 给了很好的过程描述</p><ol><li><strong>问题定义：</strong> 我们希望判断字符串 <code>s</code> 是否可以被拆分成词典中的单词。为了解决这个问题，我们引入一个布尔数组 <code>dp</code>，其中 <code>dp[i]</code> 表示字符串的前 <code>i</code> 个字符是否可以被拆分成词典中的单词。</li><li><strong>初始化：</strong> 我们将 <code>dp[0]</code> 初始化为 <code>true</code>，这是因为空字符串总是可以被拆分，即不拆分成任何单词。</li><li><strong>状态转移：</strong> 对于每个位置 <code>i</code>（从 1 到字符串长度），我们需要判断字符串的前 <code>i</code> 个字符是否可以被拆分成词典中的单词。我们遍历从 <code>0</code> 到 <code>i-1</code> 的每个位置 <code>j</code>，如果 <code>dp[j]</code> 为 <code>true</code>，并且子串 <code>s[j:i]</code> 在词典中，那么我们可以将字符串的前 <code>i</code> 个字符拆分成单词，即 <code>dp[i] = true</code>。这是因为如果从位置 <code>j</code> 到位置 <code>i-1</code> 的子串是一个有效的单词，且前 <code>j</code> 个字符可以被拆分成单词，那么前 <code>i</code> 个字符也可以被拆分。</li><li><strong>返回结果：</strong> 最终，我们返回 <code>dp[len(s)]</code>，即字符串的全部字符是否可以被拆分成词典中的单词。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(s <span class="type">string</span>, wordDict []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">bool</span>, n+<span class="number">1</span>)</span><br><span class="line">    exist := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(wordDict); i++ &#123;</span><br><span class="line">        exist[wordDict[i]] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> dp[j] &amp;&amp; exist[s[j:i]] == <span class="literal">true</span> &#123;</span><br><span class="line">                dp[i] = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="环形链表"><a href="https://leetcode.cn/problems/linked-list-cycle/">环形链表</a></h1><p>做过了，请见<a href="/posts/275.html#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8">『算法拾遗』链表（Linked List）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树的层序遍历&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/binary-tree-level-order-traversal/&quot;&gt;二叉树的层序遍历&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;简单的 BFS 练习&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『LeetCode-HOT-100』T31～T40</title>
    <link href="https://nickxu.me/post/leetcode-hot-100-t31-t40.html"/>
    <id>https://nickxu.me/post/leetcode-hot-100-t31-t40.html</id>
    <published>2023-08-05T03:20:08.000Z</published>
    <updated>2023-08-28T08:57:52.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="颜色分类"><a href="https://leetcode.cn/problems/sort-colors/">颜色分类</a></h1><p>这真的是 Medium 吗，哈哈哈😂</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortColors</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> red, white, blue <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">switch</span> nums[i] &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            red++</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            white++</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            blue++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; red; i++ &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := red; i &lt; red+white; i++ &#123;</span><br><span class="line">        nums[i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := red + white; i &lt; red+white+blue; i++ &#123;</span><br><span class="line">        nums[i] = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小覆盖子串"><a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a></h1><p>很好的滑动窗口的题目</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minWindow</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    target:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    window:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(t);i++&#123;</span><br><span class="line">        target[t[i]]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left,right:=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    ansLeft,ansRight:=<span class="number">0</span>,math.MaxInt</span><br><span class="line">    diff:=<span class="built_in">len</span>(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right&lt;<span class="built_in">len</span>(s)&#123;</span><br><span class="line">        c:=s[right]</span><br><span class="line">        right++</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> _,ok:=target[c] ; ok&#123;</span><br><span class="line">            <span class="keyword">if</span> window[c]&lt;target[c]&#123;</span><br><span class="line">                diff--</span><br><span class="line">            &#125;</span><br><span class="line">            window[c]++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> diff == <span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> right-left&lt;ansRight-ansLeft&#123;</span><br><span class="line">                ansRight,ansLeft=right,left</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            d:=s[left]</span><br><span class="line">            left++</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> _,ok:=target[d];ok&#123;</span><br><span class="line">                <span class="keyword">if</span> window[d] &lt;= target[d]&#123;</span><br><span class="line">                    diff++</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ansRight == math.MaxInt&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s[ansLeft:ansRight]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="子集"><a href="https://leetcode.cn/problems/subsets/">子集</a></h1><p>直接套模板，请见<a href="/2022/07/10/%E3%80%8E%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97%E3%80%8F%E6%8E%92%E5%88%97%E4%B8%8E%E7%BB%84%E5%90%88/?highlight=%E5%AD%90%E9%9B%86#%E5%AD%90%E9%9B%86%E7%94%9F%E6%88%90%E9%97%AE%E9%A2%98">『算法拾遗』排列与组合</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">   n := <span class="built_in">len</span>(nums)</span><br><span class="line">   <span class="keyword">var</span> ans [][]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++ &#123;</span><br><span class="line">      <span class="keyword">var</span> tmp []<span class="type">int</span></span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">         <span class="keyword">if</span> i&amp;(<span class="number">1</span>&lt;&lt;j) != <span class="number">0</span> &#123;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp, nums[j])</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ans = <span class="built_in">append</span>(ans, tmp)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单词搜索"><a href="https://leetcode.cn/problems/word-search/">单词搜索</a></h1><p>暴力 DFS</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exist</span><span class="params">(board [][]<span class="type">byte</span>, word <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    dir := [][]<span class="type">int</span>&#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m, n := <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">    vis := <span class="built_in">make</span>([][]<span class="type">bool</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        vis[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startX, startY := []<span class="type">int</span>&#123;&#125;, []<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == word[<span class="number">0</span>] &#123;</span><br><span class="line">                startX = <span class="built_in">append</span>(startX, i)</span><br><span class="line">                startY = <span class="built_in">append</span>(startY, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(count <span class="type">int</span>, x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">bool</span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(count <span class="type">int</span>, x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count == <span class="built_in">len</span>(word) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vis[x][y] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">            nx := x + dir[i][<span class="number">0</span>]</span><br><span class="line">            ny := y + dir[i][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n &amp;&amp; board[nx][ny] == word[count] &amp;&amp; !vis[nx][ny] &#123;</span><br><span class="line">                vis[nx][ny] = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">if</span> dfs(count+<span class="number">1</span>, nx, ny) == <span class="literal">true</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                vis[nx][ny] = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(startX); i++ &#123;</span><br><span class="line">        vis = <span class="built_in">make</span>([][]<span class="type">bool</span>, m)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">            vis[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dfs(<span class="number">1</span>, startX[i], startY[i]) == <span class="literal">true</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="柱状图中最大的矩形"><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></h1><p>一开始以为是 dp，但想了一下感觉又不行，想不到什么好方法，干脆看题解去了（</p><p>首先暴力很容易写，但是会 TLE</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestRectangleArea</span><span class="params">(heights []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(heights); i++ &#123;</span><br><span class="line">        left, right := i, i</span><br><span class="line">        <span class="keyword">for</span> left<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; heights[left<span class="number">-1</span>] &gt;= heights[i] &#123;</span><br><span class="line">            left--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> right+<span class="number">1</span> &lt; <span class="built_in">len</span>(heights) &amp;&amp; heights[right+<span class="number">1</span>] &gt;= heights[i] &#123;</span><br><span class="line">            right++</span><br><span class="line">        &#125;</span><br><span class="line">        area := (right - left + <span class="number">1</span>) * heights[i]</span><br><span class="line">        <span class="keyword">if</span> area &gt; ans &#123;</span><br><span class="line">            ans = area</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最佳方法是使用单调栈，主要思路我感觉 GPT 说的比题解更清楚：</p><ol><li>创建一个栈来存储柱子的索引。栈中的元素满足递增顺序，表示当前柱子高度在数组中的位置。</li><li>从左到右遍历数组中的每个柱子：<ul><li>如果栈为空，或者当前柱子的高度大于等于栈顶柱子的高度，将当前柱子的索引入栈。</li><li>如果当前柱子的高度小于栈顶柱子的高度，说明栈顶柱子不再能够向右扩展，因此弹出栈顶元素，并计算以该栈顶柱子为高度的矩形的面积。栈顶柱子出栈后，其左边第一个比它矮的柱子即为当前栈顶元素，右边第一个比它矮的柱子为当前遍历到的柱子。</li></ul></li><li>在每次弹出栈顶元素时，计算以该柱子为高度的矩形的面积，其宽度为当前遍历到的柱子索引与栈顶柱子的索引之差。</li><li>重复步骤 2 和 3，直到遍历完整个数组。</li><li>在遍历完数组后，可能还有一些柱子留在栈中。对于这些柱子，它们的右边界就是数组的末尾，左边界就是栈中紧邻的柱子。弹出这些柱子并计算矩形面积。</li><li>在整个过程中，不断更新并记录最大的矩形面积。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestRectangleArea</span><span class="params">(heights []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    heights = <span class="built_in">append</span>(heights, <span class="number">0</span>)</span><br><span class="line">    n := <span class="built_in">len</span>(heights)</span><br><span class="line">    stack := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; heights[i] &lt; heights[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;</span><br><span class="line">            curr := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            left := <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                left = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            area := (i - left - <span class="number">1</span>) * heights[curr]</span><br><span class="line">            <span class="keyword">if</span> area &gt; ans &#123;</span><br><span class="line">                ans = area</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个技巧就是直接在末尾添加一个 <code>0</code> ，这样就能强制清空栈，不用再写个循环来最后清空栈</p><p>但是这个两重 <code>for</code> 我不是很能理解，就这样吧（</p><h1 id="最大矩形"><a href="https://leetcode.cn/problems/maximal-rectangle/">最大矩形</a></h1><p>一眼 dp，但是我看了半天想不出转移方程😭</p><p>只能去看题解了</p><p><a href="https://leetcode.cn/problems/maximal-rectangle/solutions/9535/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-1-8/?envType=featured-list&amp;envId=2cktkvj">发现可以直接转换成上一题</a>，但是那个 dp 我看不懂，算了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximalRectangle</span><span class="params">(matrix [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    m,n:=<span class="built_in">len</span>(matrix),<span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> m==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    heights:=<span class="built_in">make</span>([]<span class="type">int</span>,n)</span><br><span class="line">    ans:=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;m;i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;n;j++&#123;</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j]==<span class="string">&#x27;1&#x27;</span>&#123;</span><br><span class="line">                heights[j]+=<span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                heights[j]=<span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=max(ans,largestRectangleArea(heights))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> a&gt;b&#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的中序遍历"><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/"> 二叉树的中序遍历</a></h1><p>前序中左右，中序左中右，后序左右中（「中」在前、在中、在后，左右的顺序就是左右）</p><p>我的写法有点浪费空间，每次都要拷贝，但是随便了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    ans:=[]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Left!=<span class="literal">nil</span>&#123;</span><br><span class="line">        ans=inorderTraversal(root.Left)</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="built_in">append</span>(ans,root.Val)</span><br><span class="line">    <span class="keyword">if</span> root.Right!=<span class="literal">nil</span>&#123;</span><br><span class="line">        ans=<span class="built_in">append</span>(ans,inorderTraversal(root.Right)...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不同的二叉搜索树"><a href="https://leetcode.cn/problems/unique-binary-search-trees/">不同的二叉搜索树</a></h1><p><s>什么同分异构体</s></p><p><s>第一眼，范围那么小，直接打表出省一</s></p><p>第二眼，肯定有数学规律，套公式就行</p><p>头疼，直接看题解去了，发现是卡特兰数，没事了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numTrees</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    C := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        C = C * <span class="number">2</span> * (<span class="number">2</span> * i + <span class="number">1</span>) / (i + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="验证二叉搜索树"><a href="https://leetcode.cn/problems/validate-binary-search-tree/">验证二叉搜索树</a></h1><p>经典递归，看了眼题解还可以用「二叉搜索树中序遍历一定是递增的」这个性质</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> myIsValidBST(root, math.MinInt, math.MaxInt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myIsValidBST</span><span class="params">(root *TreeNode, minVal, maxVal <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root.Val &lt;= minVal || root.Val &gt;= maxVal &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leftIsValid := myIsValidBST(root.Left, minVal, root.Val)</span><br><span class="line">    rightIsValid := myIsValidBST(root.Right, root.Val, maxVal)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftIsValid &amp;&amp; rightIsValid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对称二叉树"><a href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a></h1><p>第一反应：嗯？</p><p>第二反应：左侧用「左中右」遍历，右侧用「右中左」遍历，然后比较行不行？</p><p>第三反应：将一侧的左右儿子递归地反转，然后和另一侧比较是不是完全一样</p><p>但是这样感觉太麻烦了，我递归的时候直接镜像比较行不行（左边的左儿子比较右边的右儿子）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> myIsSymmetric(root.Left, root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myIsSymmetric</span><span class="params">(left *TreeNode, right *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> left == <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span>) || (left != <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span>) || left.Val != right.Val &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> myIsSymmetric(left.Left, right.Right) &amp;&amp; myIsSymmetric(left.Right, right.Left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;颜色分类&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/sort-colors/&quot;&gt;颜色分类&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;这真的是 Medium 吗，哈哈哈😂&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
