<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NX の 博客</title>
  <icon>https://nickxu.me/static/favicon.jpg</icon>
  
  <link href="https://nickxu.me/atom.xml" rel="self"/>
  
  <link href="https://nickxu.me/"/>
  <updated>2023-08-24T14:45:02.994Z</updated>
  <id>https://nickxu.me/</id>
  
  <author>
    <name>Nick Xu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>🌟 你可能感兴趣的文章｜Posts you might be interested in</title>
    <link href="https://nickxu.me/posts-you-might-be-interested-in.html"/>
    <id>https://nickxu.me/posts-you-might-be-interested-in.html</id>
    <published>2023-08-21T16:18:49.000Z</published>
    <updated>2023-08-24T14:45:02.994Z</updated>
    
    <content type="html"><![CDATA[<details class="toggle" ><summary class="toggle-button" style="">Latest Resume｜最近在找实习哦</summary><div class="toggle-content"><p><img src="https://image.nickxu.me/202308242242128.png" alt="image-20230824下午104208821"></p></div></details><h1 id="Junior｜大三">Junior｜大三</h1><p>即将到来的生活，充满未知与期待</p><hr><h1 id="Sophomore｜大二">Sophomore｜大二</h1><ul><li><a href="https://nickxu.me/post/aliyun-oss-brushed-1000rmb-fees.html">阿里云OSS被刷，我交了1000RMB学费！</a></li><li><a href="https://nickxu.me/2023/06/my-story-with-OSPP-from-hearing-to-being-selected.html">『OSPP2023』我与 OSPP 的故事 —— 从听闻到中选</a></li><li><a href="https://nickxu.me/posts/274.html">2023五一总结：近况与将来</a></li><li><a href="https://nickxu.me/2023/03/18/%E5%91%8A%E5%88%ABELK%EF%BC%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9FGrafana-Loki%E5%88%9D%E4%B8%8A%E6%89%8B/">告别ELK！轻量级日志收集系统Grafana Loki初上手</a></li><li><a href="https://nickxu.me/2023/03/13/%E7%AC%AC%E4%BA%94%E5%B1%8A%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%92%E8%AE%AD%E8%90%A5%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">第五届字节跳动青训营项目总结</a></li><li><a href="https://nickxu.me/2023/03/01/%E5%86%99%E5%9C%A8%E5%A4%A7%E4%BA%8C%E5%BC%80%E5%AD%A6%E4%B9%8B%E5%88%9D/">写在大二下开学之初</a></li><li><a href="https://nickxu.me/2022/12/14/%E3%80%8ECI-CD%E3%80%8F%E7%BB%93%E5%90%88GitHub-Actions-Docker%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/">『CI/CD』结合GitHub Actions+Docker实现自动化部署</a></li><li><a href="https://nickxu.me/2022/10/31/%E5%86%99%E5%9C%A810%E6%9C%88%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/">写在10月的最后一天</a></li><li><a href="https://nickxu.me/2022/10/06/%E3%80%8ELinux%E3%80%8F%E5%B0%86-Ubuntu-22-04-%E4%BD%9C%E4%B8%BA%E4%B8%BB%E5%8A%9B%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%84%9F%E6%83%B3/">『Linux』一个多月来将 Ubuntu 22.04 作为主力系统的感想</a></li><li><a href="https://nickxu.me/2022/10/04/%E3%80%8EJWT%E3%80%8F%E5%9C%A8-go-zero-%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8-JWT-%E9%89%B4%E6%9D%83/">『JWT』在 go-zero 框架中使用 JWT 鉴权</a></li><li><a href="https://nickxu.me/2022/09/29/%E3%80%8E%E6%80%BB%E7%BB%93%E3%80%8F2022%20%E5%9B%BD%E5%BA%86%E5%89%8D%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/">『总结』2022 国庆前阶段性总结</a></li><li><a href="https://nickxu.me/2022/10/12/%E3%80%8Ehduhelp%E3%80%8F%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%8E%A5%E5%85%A5%E5%8A%A9%E6%89%8B%20OAuth/">『hduhelp』如何在项目中接入助手 OAuth</a></li><li><a href="https://nickxu.me/2022/09/28/%E3%80%8Ehduhelp%E3%80%8F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8A%A9%E6%89%8B%E7%9A%84%E5%BC%80%E6%94%BE%E6%9C%8D%E5%8A%A1/">『hduhelp』如何使用助手鉴权/使用助手的开放服务</a></li><li><a href="https://nickxu.me/2022/09/18/%E3%80%8E%E9%9A%8F%E7%AC%94%E3%80%8F2022-%E6%9D%AD%E5%8A%A9%E6%8B%9B%E6%96%B0%E9%9D%A2%E8%AF%95%E6%84%9F%E6%83%B3/">『随笔』面试官竟是我自己 —— 2022 杭助秋招面试工作感想</a></li><li><a href="https://nickxu.me/2022/09/30/GORM-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%89%8D%E8%A8%80%E4%B8%8E%E4%BB%8B%E7%BB%8D/">GORM 入门笔记（一）前言与介绍</a></li><li><a href="https://nickxu.me/2022/09/11/%E3%80%8ETwikoo%E3%80%8F%E8%A7%A3%E5%86%B3-Vercel-app-%E5%9C%A8%E5%9B%BD%E5%86%85%E8%A2%AB%E5%A2%99%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/">『Twikoo』解决 Vercel.app 在国内被墙导致无法使用的问题</a></li><li><a href="https://nickxu.me/2022/09/10/%E3%80%8E%E9%9A%8F%E7%AC%94%E3%80%8F%E5%86%99%E5%9C%A8%E6%96%B0%E5%AD%A6%E5%B9%B4%E4%BC%8A%E5%A7%8B/">『随笔』写在新学年伊始</a></li></ul><hr><h1 id="Freshman｜大一">Freshman｜大一</h1><ul><li><a href="https://nickxu.me/2022/06/29/%E3%80%8EGitHub%E3%80%8F%E5%AD%A6%E7%94%9F%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E9%97%AE%E9%A2%98/">『GitHub』学生身份认证问题</a></li><li><a href="https://nickxu.me/2022/06/14/%E3%80%8E%E9%9A%8F%E7%AC%94%E3%80%8F618%E6%A1%8C%E9%9D%A2%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92/">『随笔』618桌面改造计划</a></li><li><a href="https://nickxu.me/2022/06/12/%E3%80%8E%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5%E3%80%8F%E7%BB%93%E8%90%A5%E6%84%9F%E6%83%B3/">『字节青训营-3rd』结营感想（待后续）</a></li><li><a href="https://nickxu.me/2022/05/26/%E3%80%8EGit%E3%80%8F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Git-%E5%8F%82%E4%B8%8E%E6%9D%AD%E5%8A%A9%E7%9A%84%E9%A1%B9%E7%9B%AE/">『Git』如何使用 Git 参与杭助的项目</a></li><li><a href="https://nickxu.me/2022/05/21/%E3%80%8EWSL%E3%80%8F%E5%9C%A8WSL%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%BB%E6%9C%BA%E7%9A%84%E4%BB%A3%E7%90%86/">『WSL』在 WSL 中使用主机的代理（以 Clash 为例）</a></li><li><a href="https://nickxu.me/2022/04/23/%E3%80%8E%E5%AE%9E%E8%AE%B0%E3%80%8F%E2%80%9C%E9%9F%B5%E5%91%B3%E6%9D%AD%E5%B7%9E%E2%80%9D%E6%B5%8B%E8%AF%95%E8%B5%9B%E7%90%83%E7%AB%A5%E5%BF%97%E6%84%BF%E7%BB%8F%E5%8E%86/">『实记』“韵味杭州”测试赛球童志愿经历</a></li><li><a href="https://nickxu.me/2022/04/17/%E3%80%8E%E6%80%BB%E7%BB%93%E3%80%8F%E5%A4%A7%E4%B8%80%E4%B8%8B%E6%9C%9F%E4%B8%AD%E6%80%BB%E7%BB%93/">『总结』大一下期中总结</a></li><li><a href="https://nickxu.me/2022/04/10/%E3%80%8EOthers%E3%80%8F%E7%AC%AC%E4%B8%89%E5%B1%8A%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%92%E8%AE%AD%E8%90%A5-%E5%90%8E%E7%AB%AF%E4%B8%93%E5%9C%BA-%E6%97%A9%E7%9F%A5%E6%99%93%E7%9B%B4%E6%92%AD%E4%BC%9A%E8%AE%AE%E7%BA%AA%E8%A6%81/">『Others』第三届字节跳动青训营 - 后端专场 早知晓直播会议纪要</a></li><li><a href="https://nickxu.me/2022/01/18/gin-ru-men-bi-ji-yi-chu-shi-gin-yu-huan-jing-da-jian/">Gin 入门笔记（一）环境搭建、简单的路由配置</a></li><li><a href="https://nickxu.me/2022/03/21/%E3%80%8EWSL%E3%80%8F%E8%A7%A3%E5%86%B3%E6%AF%8F%E6%AC%A1%E5%90%AF%E5%8A%A8%E5%90%8E%E8%87%AA%E5%8A%A8%E5%88%86%E9%85%8D-IP-%E7%9A%84%E9%97%AE%E9%A2%98/">『WSL』解决每次启动后自动分配 IP 的问题</a></li><li><a href="https://nickxu.me/2022/03/13/%E3%80%8E%E6%9D%82%E6%96%87%E3%80%8F%E5%9C%A8%E8%BF%B7%E8%8C%AB%E4%B8%AD%E5%89%8D%E8%BF%9B/">『杂文』在迷茫中前进</a></li><li><a href="https://nickxu.me/2022/03/02/Python-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/">Python 入门笔记（一）搭建环境</a></li><li><a href="https://nickxu.me/2022/03/01/Java-%E7%89%88-Minecraft-%E5%8A%A0%E6%A8%A1%E7%BB%84%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/">Java 版 Minecraft 加模组开服教程</a></li><li><a href="https://nickxu.me/2022/02/28/%E3%80%8ELinux%E3%80%8FNginx-%E9%85%8D%E7%BD%AE-SSL-%E8%AF%81%E4%B9%A6/">『Linux』Nginx 配置 SSL 证书</a></li><li><a href="https://nickxu.me/2021/12/31/cc-vscode-huan-jing-pei-zhi/">『C/C++』VScode 环境配置</a></li><li><a href="https://nickxu.me/2022/02/13/Hexo%20+%20Butterfly%20%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%EF%BC%88%E3%80%87%EF%BC%89%E5%89%8D%E8%A8%80/">Hexo + Butterfly 建站指南（〇）前言</a></li></ul><hr><h1 id="High-School｜高中">High School｜高中</h1><ul><li><a href="https://nickxu.me/2020/02/20/shu-mei-pai-ru-he-yi-zheng-que-de-zi-shi-zhi-zuo-shu-mei-pai-de-tf-qia-shu-ju-jing-xiang/">『树莓派』如何以正确的姿势制作树莓派的TF卡数据镜像</a></li><li><a href="https://nickxu.me/2020/01/26/shu-mei-pai-minecraft-chao-chang-kai-fu-zhe-teng-ji-lu-javaji-yan-with-hong-shi/">『树莓派』Minecraft超长开服折腾记录（Java+基岩with红石）</a></li><li><a href="https://nickxu.me/2019/11/14/cc-2019csp-mo-ban/">『C/C++』2019CSP模板</a></li><li><a href="https://nickxu.me/2019/07/23/suan-fa-zong-jie-ou-ji-li-de-suan-fa-ji-tuo-zhan/">『算法』总结欧几里得算法及拓展</a></li><li><a href="https://nickxu.me/2019/07/15/suan-fa-zong-jie-kmp-suan-fa/">『算法』总结KMP算法</a></li><li><a href="https://nickxu.me/2019/07/10/shu-mei-pai-da-jian-si-you-yun-fu-wu-qi-nextcloud/">『树莓派』搭建私有云服务器（Nextcloud）</a></li><li><a href="https://nickxu.me/2019/07/06/shu-mei-pai-wifi-xin-hao-zhong-ji/">『树莓派』WiFi信号中继</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;details class=&quot;toggle&quot; &gt;&lt;summary class=&quot;toggle-button&quot; style=&quot;&quot;&gt;Latest Resume｜最近在找实习哦&lt;/summary&gt;&lt;div class=&quot;toggle-content&quot;&gt;&lt;p&gt;&lt;img src=&quot;https://image.nickxu.me/202308242242128.png&quot; alt=&quot;image-20230824下午104208821&quot;&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/details&gt;
&lt;h1 id=&quot;Junior｜大三&quot;&gt;Junior｜大三&lt;/h1&gt;
&lt;p&gt;即将到来的生活，充满未知与期待&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Sophomore｜大二&quot;&gt;Sophomore｜大二&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://nickxu.me/post/aliyun-oss-brushed-1000rmb-fees.html&quot;&gt;阿里云OSS被刷，我交了1000RMB学费！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nickxu.me/2023/06/my-story-wit</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>阿里云OSS被刷，我交了1000RMB学费！</title>
    <link href="https://nickxu.me/post/aliyun-oss-brushed-1000rmb-fees.html"/>
    <id>https://nickxu.me/post/aliyun-oss-brushed-1000rmb-fees.html</id>
    <published>2023-08-19T02:38:24.000Z</published>
    <updated>2023-08-19T08:30:24.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大致经过">大致经过</h1><h2 id="垂死病中惊坐起😱">垂死病中惊坐起😱</h2><img src="https://image.nickxu.me/202308191506591.png" alt="image-20230819下午30609530" style="zoom:50%;" /><blockquote><p>事情发生在 8 月 8 日凌晨，凌晨三点我突然看见手机上的消息</p></blockquote><p>我一开始是疑惑的，我的 OSS 是用来当做图床的，一个月也用不了几个钱</p><p>账号里记得还有 20 多块钱，怎么会这么快用完</p><p>然后我进阿里云一看，哇，我被人刷了？</p><p><img src="https://image.nickxu.me/202308191512039.png" alt="image-20230819下午31250992"><img src="https://image.nickxu.me/202308191513456.png" alt="image-20230819下午31311428"></p><p><img src="https://image.nickxu.me/202308191514660.png" alt="image-20230819下午31405635"></p><blockquote><p>最后发现被刷了 3.57 TB，请求了 138 万次</p></blockquote><p>哇，我从没想到过这种事情会发生在我的身上</p><p>而且我停机之后他还一直在刷，根本不带停的（</p><img src="https://image.nickxu.me/202308191534994.png" alt="55d88e13ece3787389f2e55c5ca8c71f" style="zoom:50%;" /><p>我想，算了，300 块交学费得了，以后得好好重视</p><p>然后我下午就看见了——</p><h2 id="1000-软妹币的账单😭">1000 软妹币的账单😭</h2><p><img src="https://image.nickxu.me/202308191544460.png" alt="897cdaf323ff4619efb6bd2975ef2716"></p><blockquote><p>1000 RMB！这下真的被上课了😱</p></blockquote><p><img src="https://image.nickxu.me/202308191544007.png" alt="f565bb21f42f5915ba0f99219b92dd27"></p><p>由于账单会有几小时的延迟，很多人说为什么欠费了不自动停，其实等你欠费的时候，人家已经刷完了</p><p>这次在我发现的时候，就已经结束了</p><img src="https://image.nickxu.me/202308191550486.png" alt="9ae17dca6a3b4610815e748cccf27cd0" style="zoom: 25%;" /><p>真的太可怕了，直接大出血</p><p>花了好久才缓过来劲</p><h2 id="可能的原因">可能的原因</h2><p>我感觉最可能的原因，是我前段时间我写的一个玩具被人发到 Twitter 上了（<a href="https://twitter.com/ProbiusOfficial/status/1687339560144093184?s=20">属于是间接出圈</a></p><img src="https://image.nickxu.me/202308191600438.png" alt="412e8c4d11403878c10ddb6629e71825" style="zoom:33%;" /><p>然后就别人盯上了🥹</p><p><s>当时还挺高兴的，这属于是出名的代价吗</s></p><h2 id="寻求客服">寻求客服</h2><p>最后我想看看找一手客服，其实我是不报希望的，看了一堆案例都是自己承担的</p><img src="https://image.nickxu.me/202308191552445.png" alt="image-20230819下午35242417" style="zoom:50%;" /><blockquote><p>结果的确如此，真的是交了 1000 RMB 学费了</p></blockquote><hr><h1 id="解决方案">解决方案</h1><p>事已至此，接下来的事情就是寻找解决方案了</p><p>在与群友交流和不断 Google 后，我总结了几种比较好的图床解决方案：</p><ol><li>国内云 OSS + 国内云 CDN（如果你很在意国内的访问速度）</li><li>国内云 OSS + Cloudflare（比较推荐的方案，但是国内访问不会很快）</li><li>Cloudflare R2（如果你有信用卡）</li><li>某些奇技淫巧</li></ol><h2 id="国内云-OSS-国内云-CDN">国内云 OSS + 国内云 CDN</h2><p>主要思路：关闭 OSS 的直接访问，只能通过 CDN 进行访问，并使用 CDN 的流量防护措施</p><p>一方面， CDN 的流量更加便宜</p><p>另一方面，你可以通过 CDN 对流量进行限制，例如限制总流量，限制最大带宽自动停机，限制 IP qps 等等</p><p>当然你也可以说我能在 OSS 上进行防护，比如说防盗链之类的</p><p>但这其实防不胜防，真要有人想搞你换个 header 就行，只能限额，而且 OSS 防火墙规则好少</p><p>总结：</p><ul><li>优点：国内访问快</li><li>缺点：需要你同时操心 OSS 和 CDN，而且国内 CDN 域名应该需要备案</li></ul><p>教程：这种教程很多，我就贴一个阿里云的吧 <a href="https://www.alibabacloud.com/help/zh/oss/user-guide/use-cdn-to-accelerate-access-to-oss">使用CDN加速OSS访问</a></p><h2 id="国内云-OSS-Cloudflare">国内云 OSS + Cloudflare</h2><p>如果你还不了解 Cloudflare，你可以先去了解一下</p><p>主要思路：由于阿里云加入了 Cloudflare 带宽联盟，你可以通过 Cloudflare 访问 OSS 中的图片，而无需支付流量费用</p><p>我没有实操过这个方案，但是下面是我感觉需要注意的事项：</p><ol><li>必须是非大陆的 OSS 才能走  CF ，比如香港（有人说必须国际站，这个不清楚）</li><li>经历不要让他人发现源 OSS</li></ol><p>总结：</p><ul><li>优点：只需支付 OSS 的存储费用</li><li>缺点：国内访问不会很快</li></ul><p>相关链接：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/605406893">阿里云OSS套CloudFlare储存WordPress博客网站图片并达到免费加速效果</a></li><li><a href="https://luotianyi.vc/6044.html">【对象存储】搭配CF带宽联盟实现流量免费</a></li><li><a href="https://fmk.im/p/cloudflare-oss/">Cloudflare与阿里云OSS配合使用的一点小问题</a></li><li><a href="https://www.v2ex.com/t/923655">想咨询下 跨境电商商品图片 如何存储和展示, cloudflare 家</a></li></ul><h2 id="Cloudflare-R2">Cloudflare R2</h2><p>主要思路：使用 Cloudflare R2 代替阿里云 OSS，这也是我最后采取的方案</p><p>R2 是 Cloudflare 推出的 S3 兼容的对象存储，最大的特点是就是便宜，量大管饱</p><p><img src="https://image.nickxu.me/202308191434581.png" alt="e81872a0f282add5b8058c27e41cefd4"></p><p>他的不是用流量计费的，而是用访问次数计费的，而且每月有免费额度</p><p>感觉这个每月 1000 万的读操作额度已经远远超过使用需求（我本次遭受的攻击也就 100万次访问）</p><p>并且 10G/月 的免费存储用作图床也是足够的</p><p>最大的缺点就是需要绑信用卡，即使你仅仅想使用免费额度也是如此</p><p><img src="https://image.nickxu.me/202308191454808.png" alt=""></p><p>于是我让群友转了点 USDT，去整了个 <a href="https://card.onekey.so/?i=YQOVM1">OneKey</a> 的卡</p><p><img src="https://image.nickxu.me/202308191459910.png" alt="image-20230819下午25900887"></p><p>下面是我当时看的两个教程</p><ul><li><a href="https://youtu.be/U0aTo71ZmvM">Depay全新升级：Dupay Visa卡来了！如何开卡充值USDT？与Master卡有何不同？</a></li><li><a href="https://youtu.be/UXHzP9g-mus">虚拟信用卡哪家强？Onekey vs Dupay，充值USDC/USDT实际损耗测算，答案和你想的一样吗？</a></li></ul><p>关于 R2 的安全性，我感觉是可以放心的，毕竟被刷 cf 肯定不会坐视不管，而且我也配置了一些规则</p><p>总结：</p><ul><li>优点：理论上不会有任何费用</li><li>缺点：国内访问不会很快（你现在看的图片都是 R2 上的，你感觉怎么样👀</li></ul><h2 id="其他方案">其他方案</h2><p>其他方案，你可以去用一些图床服务，但是我感觉不是很心动</p><p>你可能话说放 GitHub 上，但是 GitHub 单仓库 2G，我目前的图片就已经 1G 多了</p><p>又或者，还有一些奇技淫巧哈哈哈😂</p><p>比如说这个 <a href="https://github.com/cf-pages/Telegraph-Image">https://github.com/cf-pages/Telegraph-Image</a></p><h1 id="总结">总结</h1><h2 id="做好安全防护">做好安全防护</h2><p>一定要做好安全防护哇！</p><p>一定一定一定！</p><p>就当是我为大家交了学费了，你也保证一下以后不会被交学费了好不好😭</p><h2 id="缩减照片大小">缩减照片大小</h2><p>群友问的另一个问题就是为什么我的图片这么大</p><p>其实也是，我没有压缩处理一下</p><p>于是我在 PicGo 里找了一番插件，以后就上传压缩后的图片了</p><img src="https://image.nickxu.me/202308191444053.png" alt="image-20230819下午24432015" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大致经过&quot;&gt;大致经过&lt;/h1&gt;
&lt;h2 id=&quot;垂死病中惊坐起😱&quot;&gt;垂死病中惊坐起😱&lt;/h2&gt;
&lt;img src=&quot;https://image.nickxu.me/202308191506591.png&quot; alt=&quot;image-20230819下午30609530&quot; style=&quot;zoom:50%;&quot; /&gt;
&lt;blockquote&gt;
&lt;p&gt;事情发生在 8 月 8 日凌晨，凌晨三点我突然看见手机上的消息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我一开始是疑惑的，我的 OSS 是用来当做图床的，一个月也用不了几个钱&lt;/p&gt;
&lt;p&gt;账号里记得还有 20 多块钱，怎么会这么快用完&lt;/p&gt;
&lt;p&gt;然后我进阿里云一看，哇，我被人刷了？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.nickxu.me/202308191512039.png&quot; alt=&quot;image-20230819下午31250992&quot;&gt;&lt;img src=&quot;https://image.nickxu.me/202308191513456.png&quot; alt=&quot;image-20230819下午3131</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『Golang』并发编程之通道（Channel）</title>
    <link href="https://nickxu.me/post/golang-concurrent-programming-channel.html"/>
    <id>https://nickxu.me/post/golang-concurrent-programming-channel.html</id>
    <published>2023-08-17T14:08:01.000Z</published>
    <updated>2023-08-18T12:17:08.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通道（Channel）">通道（Channel）</h1><blockquote><p>通道是什么，为什么使用通道</p></blockquote><p>「不要通过共享内存来通信，而应该通过通信来共享内存」</p><p>通道可以在多个 goroutine 之间传递数据</p><p>一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符 <code>&lt;-</code>。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向</p><blockquote><p>如何初始化通道</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">    ch1 &lt;- <span class="number">2</span></span><br><span class="line">    ch1 &lt;- <span class="number">1</span></span><br><span class="line">    ch1 &lt;- <span class="number">3</span></span><br><span class="line">    elem1 := &lt;-ch1</span><br><span class="line">    fmt.Printf(<span class="string">&quot;The first element received from channel ch1: %v\n&quot;</span>,elem1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 <code>make</code> 函数声明并初始化通道</li><li>通道的容量是 <code>int</code> 类型，但是不能小于 0 （缓冲通道和非缓冲通道）</li></ol><blockquote><p>通道的发送和接收操作都有哪些基本的特性</p></blockquote><ol><li>对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的</li><li>发送操作和接收操作中，对元素值的处理都是不可分割的</li><li>发送操作在完全完成之前会被阻塞，接收操作也是如此</li><li>元素值从外界进入通道时会被复制<ul><li>非缓冲通道的数据是直接从发送方复制到接收方</li><li>大多数情况下缓冲通道都会中转数据，如果发送时正好有人在等着接收，则会直接复制过去</li></ul></li></ol><blockquote><p>什么时候会阻塞</p></blockquote><p>正常情况下</p><ul><li>缓冲通道：如果通道已满，所有的发送操作会被依次阻塞</li><li>非缓冲通道：无论是发送操作还是接收操作，一开始执行的时候都会被阻塞，直到配对的操作也开始执行</li></ul><p>不正常情况</p><ul><li>值为 <code>nil</code> （没有使用 <code>make</code> 初始化）时，两种操作都会被永久阻塞</li></ul><blockquote><p>什么时候会 panic</p></blockquote><ul><li>对关闭的通道发送数据</li><li>对关闭的通道再次关闭</li></ul><blockquote><p>关闭的通道有什么性质</p></blockquote><p>关闭通道是指关闭通道的入口，通道关闭后仍可以从中取出数据</p><p>如果接收两个值，第二个值是 <code>bool</code> ，表示还能不能取出元素</p><p>如果值为 <code>false</code> ，表示通道已经关闭并且没有元素了，此时第一个元素会是零值</p><p>如果值为 <code>true</code> ，表示成功地取出了元素，注意你此时无法判断通道是否关闭</p><p>因此使用这个 <code>bool</code> 值判断通道是否关闭是有延迟的</p><p>永远在发送方关闭通道，不能在接收方关闭通道</p><blockquote><p>什么是单向通道，有什么用</p></blockquote><p>如果声明时包含接收操作符（<code>&lt;-</code>），就是单向通道</p><ul><li>发送通道：<code>chan&lt;-</code> ，只能发不能收</li><li>接收通道：<code>&lt;-chan</code> ，只能收不能发</li></ul><p>单向通道可以限制其他代码的行为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendInt</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    ch &lt;- rand.Intn(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里限制了函数内只能向通道内发送元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">    SendInt(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，还有可以用在接口里</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntChan</span><span class="params">()</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">    num := <span class="number">5</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, num)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">      ch &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里限制了得到返回值的程序，只能从通道中接收元素</p><blockquote><p>怎么用 <code>for range</code> 从通道中取出元素</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intChan2 := getIntChan()</span><br><span class="line"><span class="keyword">for</span> elem := <span class="keyword">range</span> intChan2 &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;The element in intChan2: %v\n&quot;</span>, elem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性质与正常操作时相同</p><blockquote><p><code>select</code> 如何与通道连用</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg1 := &lt;-ch1:</span><br><span class="line">        fmt.Println(msg1)</span><br><span class="line">    <span class="keyword">case</span> msg2 := &lt;-ch2:</span><br><span class="line">        fmt.Println(msg2)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;没有收到任何消息&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>select</code> 语句只能与通道联用，是一种多路通信选择的控制结构，允许一个 goroutine 等待多个通信操作</p><p>它由若干个分支组成。每次执行这种语句的时候，只有一个分支中的接收/发送代码会被运行</p><blockquote><p>select` 语句的分支选择规则有哪些</p></blockquote><ul><li><p>如果所有分支都阻塞，则会运行 <code>defult</code> 分支</p><p>（也就是说含有默认分支的 <code>select</code> 永远不会阻塞）</p></li><li><p>如果所有分支都阻塞，又没有 <code>defult</code> 分支，则会一直阻塞，直到有分支可以执行</p></li><li><p>如果同时有多个分支可以执行，则会随机选择一个</p></li></ul><blockquote><p>使用 <code>select</code> 的注意事项</p></blockquote><ul><li><p>如果通道关闭了，接收并不会阻塞，而同时获得零值与 <code>false</code></p><p>所以如果发现通道关闭了，应当及时屏蔽对应的分支或者采取其他措施</p><p>（将通道赋值为 <code>nil</code> 可以屏蔽改对应的分支了，因为 <code>nil</code> 的通道是一直阻塞的）</p></li><li><p><code>select</code> 语句只会将某分支的通道操作运行一次，所以如果你想连续操作的话，可以在 <code>for</code> 中使用 <code>select</code></p><p>但是如果你在 <code>select</code> 中使用 <code>break</code> 的话，只会跳出当前 <code>select</code>，而 <code>for</code> 并不会跳出</p><p>（如果想将 <code>for</code> 也跳出，可以在 <code>for</code> 前面放一个 <code>label</code>，再将 <code>label</code> 与 <code>break</code> 一起使用）</p></li><li><p>尽管 <code>select</code> 本身是并发安全的，但是不代表你的 <code>case</code> 表达式和分支中的代码也是并发安全的</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通道（Channel）&quot;&gt;通道（Channel）&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;通道是什么，为什么使用通道&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;「不要通过共享内存来通信，而应该通过通信来共享内存」&lt;/p&gt;
&lt;p&gt;通道可以在多个 goroutine 之间传递数据&lt;/p&gt;
&lt;p&gt;一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符 &lt;code&gt;&amp;lt;-&lt;/code&gt;。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何初始化通道&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/sp</summary>
      
    
    
    
    <category term="Golang" scheme="https://nickxu.me/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>『LeetCode-HOT-100』T41～T50</title>
    <link href="https://nickxu.me/post/leetcode-hot-100-t41-t50.html"/>
    <id>https://nickxu.me/post/leetcode-hot-100-t41-t50.html</id>
    <published>2023-08-13T06:06:21.000Z</published>
    <updated>2023-08-15T16:00:13.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的层序遍历"><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></h1><p>简单的 BFS 练习</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    ans := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line">    queue := []TreeNode&#123;&#125;</span><br><span class="line">    queue = <span class="built_in">append</span>(queue, *root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line">        tmpAns := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">        nextLevel := []TreeNode&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line">            curr := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">            tmpAns = <span class="built_in">append</span>(tmpAns, curr.Val)</span><br><span class="line">            <span class="keyword">if</span> curr.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                nextLevel = <span class="built_in">append</span>(nextLevel, *curr.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> curr.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                nextLevel = <span class="built_in">append</span>(nextLevel, *curr.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = <span class="built_in">append</span>(ans, tmpAns)</span><br><span class="line">        queue = nextLevel</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二叉树的最大深度"><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></h1><p>直接上一题改改哈哈哈</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line">    queue := []TreeNode&#123;&#125;</span><br><span class="line">    queue = <span class="built_in">append</span>(queue, *root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line">        ans++</span><br><span class="line">        nextLevel := []TreeNode&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line">            curr := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> curr.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                nextLevel = <span class="built_in">append</span>(nextLevel, *curr.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> curr.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                nextLevel = <span class="built_in">append</span>(nextLevel, *curr.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue = nextLevel</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="从前序与中序遍历序列构造二叉树"><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a></h1><p>前序中左右，中序左中右，后序左右中</p><p>二叉树基本功</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="type">int</span>, inorder []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;TreeNode&#123;</span><br><span class="line">            Val:   preorder[<span class="number">0</span>],</span><br><span class="line">            Left:  <span class="literal">nil</span>,</span><br><span class="line">            Right: <span class="literal">nil</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ans:=&amp;TreeNode&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    midVal := preorder[<span class="number">0</span>] <span class="comment">// mid 的值</span></span><br><span class="line">    inorderMinIdx := <span class="number">0</span>    <span class="comment">// mid 在中序的位置</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(inorder); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> inorder[i] == midVal &#123;</span><br><span class="line">            inorderMinIdx = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leftInorder := inorder[:inorderMinIdx]</span><br><span class="line">    rightInorder := inorder[inorderMinIdx+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为 len(「右」) 在前序和中序是一样的，并且都在结尾</span></span><br><span class="line">    <span class="comment">// 所以很容易能把前序的「左」「右」区分开来</span></span><br><span class="line">    lenRight := <span class="built_in">len</span>(inorder) - inorderMinIdx</span><br><span class="line">    leftPreorder := preorder[<span class="number">1</span> : <span class="built_in">len</span>(preorder)-lenRight+<span class="number">1</span>]</span><br><span class="line">    rightPreorder := preorder[<span class="built_in">len</span>(preorder)-lenRight+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fmt.Println(&quot;leftInorder&quot;,leftInorder)</span></span><br><span class="line">    <span class="comment">// fmt.Println(&quot;rightInorder&quot;,rightInorder)</span></span><br><span class="line">    <span class="comment">// fmt.Println(&quot;leftPreorder&quot;,leftPreorder)</span></span><br><span class="line">    <span class="comment">// fmt.Println(&quot;rightPreorder&quot;,rightPreorder)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;TreeNode&#123;</span><br><span class="line">        Val:   midVal,</span><br><span class="line">        Left:  buildTree(leftPreorder, leftInorder),</span><br><span class="line">        Right: buildTree(rightPreorder, rightInorder),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树展开为链表"><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a></h1><p>要求展开成先序遍历一样的顺序</p><p>首先你遍历的同时构造新链表肯定是可以的，但是这样就没意思了，肯定得写个原地的</p><p>首先先序是中左右，所以你把左和右分别搞定之后，再拼一起就行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatten</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">   _ = myFlatten(root)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFlatten</span><span class="params">(root *TreeNode)</span></span> (tail *TreeNode) &#123;</span><br><span class="line">   <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> root</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   leftTail := myFlatten(root.Left)</span><br><span class="line">   rightTail := myFlatten(root.Right)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> leftTail != <span class="literal">nil</span> &#123;</span><br><span class="line">      leftTail.Left = <span class="literal">nil</span></span><br><span class="line">      leftTail.Right = root.Right</span><br><span class="line">      root.Right = root.Left</span><br><span class="line">      root.Left = <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> rightTail != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> rightTail</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> leftTail</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></h1><p>首先暴力肯定没问题，但是数据量大了会 TLE</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(prices)</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            v := prices[j] - prices[i]</span><br><span class="line">            <span class="keyword">if</span> v &gt; ans &#123;</span><br><span class="line">                ans = v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实实质就是找到差别最大的两个数字，并且小的在前面</p><p>求出相邻之间的 <code>diff</code> 数组，然后遍历即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(prices)</span><br><span class="line">    diff := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        diff[i] = prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    curr := <span class="number">0</span></span><br><span class="line">    <span class="comment">// fmt.Println(diff)</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        curr += diff[i]</span><br><span class="line">        <span class="keyword">if</span> curr &gt; ans &#123;</span><br><span class="line">            ans = curr</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> curr &lt; <span class="number">0</span> &#123;</span><br><span class="line">            curr = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><s>dp 我也想了，但是想了半天都是 n 方的（</s></p><p>结果看见了<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solutions/136684/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/comments/930057">这条评论</a>，感觉还是人外有人👀（</p><h1 id="二叉树中的最大路径和"><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">二叉树中的最大路径和</a></h1><p>第一眼：嗯？图的最长路算法？</p><p>但是这个数据量应该来不及转换成图然后处理</p><p>第二眼：嗯？树形 dp？</p><p>但是有个问题就是不好确定起点哇，如果是必须经过 <code>root</code> 的话还可以左右两边分别 dp，然后合一起</p><p>仔细思考，我感觉可以从所有的叶子结点向 <code>root</code> 开始 dp，转移方程就是，每一个分支结点都可以选择继承左儿子，或者继承右儿子，或者都不继承</p><p>但是这个遍历顺序有点难搞，算了，还是写成记忆化搜索吧（dp 其实就是记忆化搜索 Pro Max）</p><p>哎等等？好像可以直接写成搜索？</p><p>再等等？好像少了一种情况，或者在当前打住，把两边拉一起，但是上面不能再引用这个数据（啊我好像知道 ans 怎么求了</p><p>啊好像还得加个只选自身结点</p><p>啊还有只选左边和只选右边</p><p>我去我居然手搓过了一个 hard，成绩还这么好😭</p><p><img src="../../../../Library/Application%20Support/typora-user-images/image-20230813%E4%B8%8B%E5%8D%88113211729.png" alt="image-20230813下午113211729"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxPathSum</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := math.MinInt</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(curr *TreeNode)</span></span> <span class="type">int</span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(curr *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> left, right <span class="type">int</span></span><br><span class="line">        <span class="keyword">if</span> curr.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            left = dfs(curr.Left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> curr.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            right = dfs(curr.Right)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = max(ans,</span><br><span class="line">            left+right+curr.Val,</span><br><span class="line">            left+curr.Val,</span><br><span class="line">            right+curr.Val,</span><br><span class="line">            curr.Val,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(left+curr.Val, right+curr.Val, curr.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    _ = dfs(root)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    max := a[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; max &#123;</span><br><span class="line">            max = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长连续序列"><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">最长连续序列</a></h1><p>啊，一眼貌似 dp，但是我想不出怎么写</p><p>能不能用桶排的思路呢？数据范围太大了</p><p>但是要求 <code>O(n)</code> ，我感觉也只有 dp 了哇</p><p>实在写不出来，一看标签，卧槽，有并查集，但是也不行哇（</p><p>看了题解之后：</p><p>原来哈希表不是 <code>O(logn)</code> 哇， 我一直以为 <code>map</code> 是 <code>O(logn)</code>，那没事了~~（高中学的 C++ 的 <code>std::map</code> 说是基于红黑树的，红黑树是 <code>O(logn)</code>，所以一直记得 <code>map</code> 就是 <code>O(logn)</code>~~</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestConsecutive</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    fa := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    exist := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)</span><br><span class="line">    count := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        fa[nums[i]] = nums[i]</span><br><span class="line">        exist[nums[i]] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> x != fa[x] &#123;</span><br><span class="line">            fa[x] = fa[fa[x]]</span><br><span class="line">            x = fa[x]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    combine := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// fmt.Println(a,b)</span></span><br><span class="line">        fa[find(a)] = find(b)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> exist[nums[i]<span class="number">-1</span>] &#123;</span><br><span class="line">            combine(nums[i], nums[i]<span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> exist[nums[i]+<span class="number">1</span>] &#123;</span><br><span class="line">            combine(nums[i], nums[i]+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> exist &#123;</span><br><span class="line">        count[find(i)]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fmt.Println(n)</span></span><br><span class="line">    <span class="comment">// fmt.Println(fa)</span></span><br><span class="line">    <span class="comment">// fmt.Println(exist)</span></span><br><span class="line">    <span class="comment">// fmt.Println(count)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> count &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; ans &#123;</span><br><span class="line">            ans = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="只出现一次的数字"><a href="https://leetcode.cn/problems/single-number/">只出现一次的数字</a></h1><p>完全想不出「该算法只使用常量额外空间」的方法</p><p>我能想到的是一个变量连续计算，然后两个相同的能自动抵消，<code>O(n)</code> 只能是这样，但是想不出来</p><p>一看标签卧槽位运算</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        ans ^= i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单词拆分"><a href="https://leetcode.cn/problems/word-break/">单词拆分</a></h1><p>先来个暴力好吧，但是 TLE 了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(s <span class="type">string</span>, wordDict []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> wordDict &#123;</span><br><span class="line">        <span class="keyword">if</span> isTrim(s, word) &amp;&amp; wordBreak(s[<span class="built_in">len</span>(word):], wordDict) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isTrim</span><span class="params">(s, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(t) == <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">return</span> s == t</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i] != t[i] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想改进一下这个暴力，如果 wordDict 中有单词可以由其他单词组合成，那就可以忽略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(s <span class="type">string</span>, wordDict []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    wordDict= prework(wordDict)</span><br><span class="line">    <span class="keyword">return</span> myWordBreak(s,wordDict)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prework</span><span class="params">(wordDict []<span class="type">string</span>)</span></span> []<span class="type">string</span>&#123;</span><br><span class="line">    ans := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(wordDict);i++&#123;</span><br><span class="line">        ext:=<span class="built_in">make</span>([]<span class="type">string</span>,<span class="built_in">len</span>(wordDict)<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">copy</span>(ext,wordDict[:i])</span><br><span class="line">        <span class="built_in">copy</span>(ext[i:],wordDict[i+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">if</span> !myWordBreak(wordDict[i],ext)&#123;</span><br><span class="line">            ans=<span class="built_in">append</span>(ans,wordDict[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myWordBreak</span><span class="params">(s <span class="type">string</span>, wordDict []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,word:=<span class="keyword">range</span> wordDict&#123;</span><br><span class="line">        <span class="keyword">if</span> isTrim(s,word)&amp;&amp;myWordBreak(s[<span class="built_in">len</span>(word):],wordDict) &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isTrim</span><span class="params">(s,t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(t)&gt;<span class="built_in">len</span>(s)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(t)==<span class="built_in">len</span>(s)&#123;</span><br><span class="line">        <span class="keyword">return</span> s == t</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(t);i++&#123;</span><br><span class="line">            <span class="keyword">if</span> s[i]!=t[i]&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是还是 TLE 了😭</p><p>再优化一手试试，来点记忆化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vis = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line"><span class="keyword">var</span> flag <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(s <span class="type">string</span>, wordDict []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    flag = <span class="literal">false</span></span><br><span class="line">    vis = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    wordDict = prework(wordDict)</span><br><span class="line">    vis = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> myWordBreak(s, wordDict)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prework</span><span class="params">(wordDict []<span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    ans := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(wordDict); i++ &#123;</span><br><span class="line">        ext := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(wordDict)<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">copy</span>(ext, wordDict[:i])</span><br><span class="line">        <span class="built_in">copy</span>(ext[i:], wordDict[i+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">if</span> !myWordBreak(wordDict[i], ext) &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, wordDict[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myWordBreak</span><span class="params">(s <span class="type">string</span>, wordDict []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> flag &#123;</span><br><span class="line">        <span class="keyword">if</span> val, ok := vis[s]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> wordDict &#123;</span><br><span class="line">        <span class="keyword">if</span> isTrim(s, word) &amp;&amp; myWordBreak(s[<span class="built_in">len</span>(word):], wordDict) &#123;</span><br><span class="line">            vis[s] = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[s] = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isTrim</span><span class="params">(s, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(t) == <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">return</span> s == t</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i] != t[i] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>居然过了🤣</p><p>言归正传，这个问题最好的方法肯定是 dp，GPT 给了很好的过程描述</p><ol><li><strong>问题定义：</strong> 我们希望判断字符串 <code>s</code> 是否可以被拆分成词典中的单词。为了解决这个问题，我们引入一个布尔数组 <code>dp</code>，其中 <code>dp[i]</code> 表示字符串的前 <code>i</code> 个字符是否可以被拆分成词典中的单词。</li><li><strong>初始化：</strong> 我们将 <code>dp[0]</code> 初始化为 <code>true</code>，这是因为空字符串总是可以被拆分，即不拆分成任何单词。</li><li><strong>状态转移：</strong> 对于每个位置 <code>i</code>（从 1 到字符串长度），我们需要判断字符串的前 <code>i</code> 个字符是否可以被拆分成词典中的单词。我们遍历从 <code>0</code> 到 <code>i-1</code> 的每个位置 <code>j</code>，如果 <code>dp[j]</code> 为 <code>true</code>，并且子串 <code>s[j:i]</code> 在词典中，那么我们可以将字符串的前 <code>i</code> 个字符拆分成单词，即 <code>dp[i] = true</code>。这是因为如果从位置 <code>j</code> 到位置 <code>i-1</code> 的子串是一个有效的单词，且前 <code>j</code> 个字符可以被拆分成单词，那么前 <code>i</code> 个字符也可以被拆分。</li><li><strong>返回结果：</strong> 最终，我们返回 <code>dp[len(s)]</code>，即字符串的全部字符是否可以被拆分成词典中的单词。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(s <span class="type">string</span>, wordDict []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">bool</span>, n+<span class="number">1</span>)</span><br><span class="line">    exist := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(wordDict); i++ &#123;</span><br><span class="line">        exist[wordDict[i]] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> dp[j] &amp;&amp; exist[s[j:i]] == <span class="literal">true</span> &#123;</span><br><span class="line">                dp[i] = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="环形链表"><a href="https://leetcode.cn/problems/linked-list-cycle/">环形链表</a></h1><p>做过了，请见<a href="/posts/275.html#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8">『算法拾遗』链表（Linked List）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树的层序遍历&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/binary-tree-level-order-traversal/&quot;&gt;二叉树的层序遍历&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;简单的 BFS 练习&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『LeetCode-HOT-100』T31～T40</title>
    <link href="https://nickxu.me/post/leetcode-hot-100-t31-t40.html"/>
    <id>https://nickxu.me/post/leetcode-hot-100-t31-t40.html</id>
    <published>2023-08-05T03:20:08.000Z</published>
    <updated>2023-08-14T09:59:32.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="颜色分类"><a href="https://leetcode.cn/problems/sort-colors/">颜色分类</a></h1><p>这真的是 Medium 吗，哈哈哈😂</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortColors</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> red, white, blue <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">switch</span> nums[i] &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            red++</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            white++</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            blue++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; red; i++ &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := red; i &lt; red+white; i++ &#123;</span><br><span class="line">        nums[i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := red + white; i &lt; red+white+blue; i++ &#123;</span><br><span class="line">        nums[i] = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小覆盖子串"><a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a></h1><p>很好的滑动窗口的题目</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minWindow</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    target:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    window:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(t);i++&#123;</span><br><span class="line">        target[t[i]]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left,right:=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    ansLeft,ansRight:=<span class="number">0</span>,math.MaxInt</span><br><span class="line">    diff:=<span class="built_in">len</span>(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right&lt;<span class="built_in">len</span>(s)&#123;</span><br><span class="line">        c:=s[right]</span><br><span class="line">        right++</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> _,ok:=target[c] ; ok&#123;</span><br><span class="line">            <span class="keyword">if</span> window[c]&lt;target[c]&#123;</span><br><span class="line">                diff--</span><br><span class="line">            &#125;</span><br><span class="line">            window[c]++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> diff == <span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> right-left&lt;ansRight-ansLeft&#123;</span><br><span class="line">                ansRight,ansLeft=right,left</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            d:=s[left]</span><br><span class="line">            left++</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> _,ok:=target[d];ok&#123;</span><br><span class="line">                <span class="keyword">if</span> window[d] &lt;= target[d]&#123;</span><br><span class="line">                    diff++</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ansRight == math.MaxInt&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s[ansLeft:ansRight]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="子集"><a href="https://leetcode.cn/problems/subsets/">子集</a></h1><p>直接套模板，请见<a href="/2022/07/10/%E3%80%8E%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97%E3%80%8F%E6%8E%92%E5%88%97%E4%B8%8E%E7%BB%84%E5%90%88/?highlight=%E5%AD%90%E9%9B%86#%E5%AD%90%E9%9B%86%E7%94%9F%E6%88%90%E9%97%AE%E9%A2%98">『算法拾遗』排列与组合</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">   n := <span class="built_in">len</span>(nums)</span><br><span class="line">   <span class="keyword">var</span> ans [][]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++ &#123;</span><br><span class="line">      <span class="keyword">var</span> tmp []<span class="type">int</span></span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">         <span class="keyword">if</span> i&amp;(<span class="number">1</span>&lt;&lt;j) != <span class="number">0</span> &#123;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp, nums[j])</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ans = <span class="built_in">append</span>(ans, tmp)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单词搜索"><a href="https://leetcode.cn/problems/word-search/">单词搜索</a></h1><p>暴力 DFS</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exist</span><span class="params">(board [][]<span class="type">byte</span>, word <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    dir := [][]<span class="type">int</span>&#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m, n := <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">    vis := <span class="built_in">make</span>([][]<span class="type">bool</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        vis[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startX, startY := []<span class="type">int</span>&#123;&#125;, []<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == word[<span class="number">0</span>] &#123;</span><br><span class="line">                startX = <span class="built_in">append</span>(startX, i)</span><br><span class="line">                startY = <span class="built_in">append</span>(startY, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(count <span class="type">int</span>, x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">bool</span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(count <span class="type">int</span>, x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count == <span class="built_in">len</span>(word) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vis[x][y] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">            nx := x + dir[i][<span class="number">0</span>]</span><br><span class="line">            ny := y + dir[i][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n &amp;&amp; board[nx][ny] == word[count] &amp;&amp; !vis[nx][ny] &#123;</span><br><span class="line">                vis[nx][ny] = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">if</span> dfs(count+<span class="number">1</span>, nx, ny) == <span class="literal">true</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                vis[nx][ny] = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(startX); i++ &#123;</span><br><span class="line">        vis = <span class="built_in">make</span>([][]<span class="type">bool</span>, m)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">            vis[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dfs(<span class="number">1</span>, startX[i], startY[i]) == <span class="literal">true</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="柱状图中最大的矩形"><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></h1><p>一开始以为是 dp，但想了一下感觉又不行，想不到什么好方法，干脆看题解去了（</p><p>首先暴力很容易写，但是会 TLE</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestRectangleArea</span><span class="params">(heights []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(heights); i++ &#123;</span><br><span class="line">        left, right := i, i</span><br><span class="line">        <span class="keyword">for</span> left<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; heights[left<span class="number">-1</span>] &gt;= heights[i] &#123;</span><br><span class="line">            left--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> right+<span class="number">1</span> &lt; <span class="built_in">len</span>(heights) &amp;&amp; heights[right+<span class="number">1</span>] &gt;= heights[i] &#123;</span><br><span class="line">            right++</span><br><span class="line">        &#125;</span><br><span class="line">        area := (right - left + <span class="number">1</span>) * heights[i]</span><br><span class="line">        <span class="keyword">if</span> area &gt; ans &#123;</span><br><span class="line">            ans = area</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最佳方法是使用单调栈，主要思路我感觉 GPT 说的比题解更清楚：</p><ol><li>创建一个栈来存储柱子的索引。栈中的元素满足递增顺序，表示当前柱子高度在数组中的位置。</li><li>从左到右遍历数组中的每个柱子：<ul><li>如果栈为空，或者当前柱子的高度大于等于栈顶柱子的高度，将当前柱子的索引入栈。</li><li>如果当前柱子的高度小于栈顶柱子的高度，说明栈顶柱子不再能够向右扩展，因此弹出栈顶元素，并计算以该栈顶柱子为高度的矩形的面积。栈顶柱子出栈后，其左边第一个比它矮的柱子即为当前栈顶元素，右边第一个比它矮的柱子为当前遍历到的柱子。</li></ul></li><li>在每次弹出栈顶元素时，计算以该柱子为高度的矩形的面积，其宽度为当前遍历到的柱子索引与栈顶柱子的索引之差。</li><li>重复步骤 2 和 3，直到遍历完整个数组。</li><li>在遍历完数组后，可能还有一些柱子留在栈中。对于这些柱子，它们的右边界就是数组的末尾，左边界就是栈中紧邻的柱子。弹出这些柱子并计算矩形面积。</li><li>在整个过程中，不断更新并记录最大的矩形面积。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestRectangleArea</span><span class="params">(heights []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    heights = <span class="built_in">append</span>(heights, <span class="number">0</span>)</span><br><span class="line">    n := <span class="built_in">len</span>(heights)</span><br><span class="line">    stack := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; heights[i] &lt; heights[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;</span><br><span class="line">            curr := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            left := <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                left = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            area := (i - left - <span class="number">1</span>) * heights[curr]</span><br><span class="line">            <span class="keyword">if</span> area &gt; ans &#123;</span><br><span class="line">                ans = area</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个技巧就是直接在末尾添加一个 <code>0</code> ，这样就能强制清空栈，不用再写个循环来最后清空栈</p><p>但是这个两重 <code>for</code> 我不是很能理解，就这样吧（</p><h1 id="最大矩形"><a href="https://leetcode.cn/problems/maximal-rectangle/">最大矩形</a></h1><p>一眼 dp，但是我看了半天想不出转移方程😭</p><p>只能去看题解了</p><p><a href="https://leetcode.cn/problems/maximal-rectangle/solutions/9535/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-1-8/?envType=featured-list&amp;envId=2cktkvj">发现可以直接转换成上一题</a>，但是那个 dp 我看不懂，算了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximalRectangle</span><span class="params">(matrix [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    m,n:=<span class="built_in">len</span>(matrix),<span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> m==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    heights:=<span class="built_in">make</span>([]<span class="type">int</span>,n)</span><br><span class="line">    ans:=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;m;i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;n;j++&#123;</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j]==<span class="string">&#x27;1&#x27;</span>&#123;</span><br><span class="line">                heights[j]+=<span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                heights[j]=<span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=max(ans,largestRectangleArea(heights))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> a&gt;b&#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的中序遍历"><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/"> 二叉树的中序遍历</a></h1><p>前序中左右，中序左中右，后序左右中</p><p>我的写法有点浪费空间，每次都要拷贝，但是随便了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    ans:=[]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Left!=<span class="literal">nil</span>&#123;</span><br><span class="line">        ans=inorderTraversal(root.Left)</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="built_in">append</span>(ans,root.Val)</span><br><span class="line">    <span class="keyword">if</span> root.Right!=<span class="literal">nil</span>&#123;</span><br><span class="line">        ans=<span class="built_in">append</span>(ans,inorderTraversal(root.Right)...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不同的二叉搜索树"><a href="https://leetcode.cn/problems/unique-binary-search-trees/">不同的二叉搜索树</a></h1><p><s>什么同分异构体</s></p><p><s>第一眼，范围那么小，直接打表出省一</s></p><p>第二眼，肯定有数学规律，套公式就行</p><p>头疼，直接看题解去了，发现是卡特兰数，没事了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numTrees</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    C := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        C = C * <span class="number">2</span> * (<span class="number">2</span> * i + <span class="number">1</span>) / (i + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="验证二叉搜索树"><a href="https://leetcode.cn/problems/validate-binary-search-tree/">验证二叉搜索树</a></h1><p>经典递归，看了眼题解还可以用「二叉搜索树中序遍历一定是递增的」这个性质</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> myIsValidBST(root, math.MinInt, math.MaxInt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myIsValidBST</span><span class="params">(root *TreeNode, minVal, maxVal <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root.Val &lt;= minVal || root.Val &gt;= maxVal &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leftIsValid := myIsValidBST(root.Left, minVal, root.Val)</span><br><span class="line">    rightIsValid := myIsValidBST(root.Right, root.Val, maxVal)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftIsValid &amp;&amp; rightIsValid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对称二叉树"><a href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a></h1><p>第一反应：嗯？</p><p>第二反应：左侧用「左中右」遍历，右侧用「右中左」遍历，然后比较行不行？</p><p>第三反应：将一侧的左右儿子递归地反转，然后和另一侧比较是不是完全一样</p><p>但是这样感觉太麻烦了，我递归的时候直接镜像比较行不行（左边的左儿子比较右边的右儿子）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> myIsSymmetric(root.Left, root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myIsSymmetric</span><span class="params">(left *TreeNode, right *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> left == <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span>) || (left != <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span>) || left.Val != right.Val &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> myIsSymmetric(left.Left, right.Right) &amp;&amp; myIsSymmetric(left.Right, right.Left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;颜色分类&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/sort-colors/&quot;&gt;颜色分类&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;这真的是 Medium 吗，哈哈哈😂&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『LeetCode-HOT-100』T21～T30</title>
    <link href="https://nickxu.me/post/leetcode-hot-100-t21-t30.html"/>
    <id>https://nickxu.me/post/leetcode-hot-100-t21-t30.html</id>
    <published>2023-08-03T08:27:29.000Z</published>
    <updated>2023-08-14T09:59:33.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全排列"><a href="https://leetcode.cn/problems/permutations/">全排列</a></h1><p><a href="https://nickxu.me/2022/07/10/%E3%80%8E%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97%E3%80%8F%E6%8E%92%E5%88%97%E4%B8%8E%E7%BB%84%E5%90%88/?highlight=%E6%8E%92%E5%88%97#%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%EF%BC%88%E6%B3%95%E4%BA%8C%EF%BC%8C%E6%8E%A8%E8%8D%90%EF%BC%89">板子题</a>，不解释</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> (ans [][]<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(begain, end <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(begain, end <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> begain == end &#123;</span><br><span class="line">            <span class="comment">// 切片是引用类型，需要深拷贝一下</span></span><br><span class="line">            tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">            <span class="built_in">copy</span>(tmp, nums)</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, tmp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := begain; i &lt;= end; i++ &#123;</span><br><span class="line">            nums[begain], nums[i] = nums[i], nums[begain]</span><br><span class="line">            dfs(begain+<span class="number">1</span>, end)</span><br><span class="line">            nums[begain], nums[i] = nums[i], nums[begain]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="旋转图像"><a href="https://leetcode.cn/problems/rotate-image/">旋转图像</a></h1><p>感觉纯脑筋急转弯，在草稿纸推演一波应该就行👀</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(matrix)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; (n+<span class="number">1</span>)/<span class="number">2</span>; j++ &#123;</span><br><span class="line">            matrix[i][j], matrix[n-j<span class="number">-1</span>][i], matrix[n-i<span class="number">-1</span>][n-j<span class="number">-1</span>], matrix[j][n-i<span class="number">-1</span>] =</span><br><span class="line">                matrix[n-j<span class="number">-1</span>][i], matrix[n-i<span class="number">-1</span>][n-j<span class="number">-1</span>], matrix[j][n-i<span class="number">-1</span>], matrix[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字母异位词分组"><a href="https://leetcode.cn/problems/group-anagrams/">字母异位词分组</a></h1><p>没想到暴力解法时间上能击败 95% 的 Go 用户🤣</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">groupAnagrams</span><span class="params">(strs []<span class="type">string</span>)</span></span> [][]<span class="type">string</span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">var</span> ans [][]<span class="type">string</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, str := <span class="keyword">range</span> strs &#123;</span><br><span class="line">        tmpStr := []<span class="type">byte</span>(str)</span><br><span class="line">        sort.Slice(tmpStr, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> tmpStr[i] &lt; tmpStr[j]</span><br><span class="line">        &#125;)</span><br><span class="line">        m[<span class="type">string</span>(tmpStr)] = <span class="built_in">append</span>(m[<span class="type">string</span>(tmpStr)], idx)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, idxs := <span class="keyword">range</span> m &#123;</span><br><span class="line">        tmp := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(idxs))</span><br><span class="line">        <span class="keyword">for</span> i, idx := <span class="keyword">range</span> idxs &#123;</span><br><span class="line">            tmp[i] = strs[idx]</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, tmp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种方法是统计字符个数来区分</p><h1 id="最大子数组和"><a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></h1><p>经典 dp，但是做完了才发现有更好的方法，就是只接纳有贡献的元素（大于 0）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    ans := nums[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        dp[i] = max(dp[i<span class="number">-1</span>]+nums[i], nums[i])</span><br><span class="line">        ans = max(ans, dp[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="跳跃游戏"><a href="https://leetcode.cn/problems/jump-game/">跳跃游戏</a></h1><p>也是经典 dp，当然也有其他的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> dp[i] &#123;</span><br><span class="line">            <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt;= i+nums[i] &amp;&amp; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">                dp[j] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="合并区间"><a href="https://leetcode.cn/problems/merge-intervals/">合并区间</a></h1><p>打死不看🙈题解，我手搓了一个暴力改了好几回终于也过了😭</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SIZE = <span class="number">10001</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals [][]<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">    end := <span class="built_in">make</span>([]<span class="type">int</span>, SIZE) <span class="comment">// 当前区间的结束位置</span></span><br><span class="line">    v := <span class="built_in">make</span>([]<span class="type">int</span>, SIZE)   <span class="comment">// 被区间覆盖次数</span></span><br><span class="line"></span><br><span class="line">    sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> intervals[i][<span class="number">1</span>] != intervals[j][<span class="number">1</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> intervals[i][<span class="number">1</span>] &lt; intervals[j][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals[i][<span class="number">0</span>] &lt; intervals[j][<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fmt.Println(intervals)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, interval := <span class="keyword">range</span> intervals &#123;</span><br><span class="line">        <span class="keyword">if</span> idx+<span class="number">1</span> &lt; <span class="built_in">len</span>(intervals) &amp;&amp; intervals[idx][<span class="number">0</span>] == intervals[idx+<span class="number">1</span>][<span class="number">0</span>] &amp;&amp; intervals[idx][<span class="number">1</span>] == intervals[idx+<span class="number">1</span>][<span class="number">1</span>] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := interval[<span class="number">0</span>]; i &lt;= interval[<span class="number">1</span>]; i++ &#123;</span><br><span class="line">            end[i] = interval[<span class="number">1</span>]</span><br><span class="line">            v[i]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fmt.Println(end)</span></span><br><span class="line">    <span class="comment">// fmt.Println(v)</span></span><br><span class="line">    <span class="keyword">var</span> ans [][]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; SIZE; i++ &#123;</span><br><span class="line">        <span class="comment">// if v[end[i]] == 0&#123;</span></span><br><span class="line">        <span class="comment">//     continue</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span> &amp;&amp; end[i] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> v[end[i]] == <span class="number">1</span> &#123;</span><br><span class="line">            tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">            tmp[<span class="number">0</span>] = i</span><br><span class="line">            i = end[i]</span><br><span class="line">            tmp[<span class="number">1</span>] = i</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, tmp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> v[end[i]] &gt;= <span class="number">2</span> &#123;</span><br><span class="line">            tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">            tmp[<span class="number">0</span>] = i</span><br><span class="line">            <span class="keyword">for</span> v[end[i]] &gt;= <span class="number">2</span> &amp;&amp; i != end[i] &#123;</span><br><span class="line">                i = end[i]</span><br><span class="line">            &#125;</span><br><span class="line">            i = end[i]</span><br><span class="line">            tmp[<span class="number">1</span>] = i</span><br><span class="line">            <span class="comment">// fmt.Println(tmp)</span></span><br><span class="line">            ans = <span class="built_in">append</span>(ans, tmp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实有更简单的方法，也是先排序（这里以左端点为例），然后按照下面的思路处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 当前区间的左端点 &lt;= 前一个区间的右端点 &#123;</span><br><span class="line">    与 ans 的最后一个区间合并（右端点取最大值）</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    直接加入 ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不同路径"><a href="https://leetcode.cn/problems/unique-paths/">不同路径</a></h1><p>我写的应该是记忆化搜索（？）和 dp 感觉没什么区别了👀</p><p>当然你还可以用排列组合公式一步到位哈哈哈</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> N = <span class="number">128</span></span><br><span class="line"><span class="keyword">var</span> count [][]<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    count = <span class="built_in">make</span>([][]<span class="type">int</span>, N)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">        count[i] = <span class="built_in">make</span>([]<span class="type">int</span>, N)</span><br><span class="line">    &#125;</span><br><span class="line">    count[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePaths</span><span class="params">(m <span class="type">int</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> count[m][n] != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count[m][n]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> m<span class="number">-1</span> &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        count[m][n] += uniquePaths(m<span class="number">-1</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n<span class="number">-1</span> &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        count[m][n] += uniquePaths(m, n<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小路径和"><a href="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a></h1><p>这个也是 dp，但是我还是写了个记忆化搜索（</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> N = <span class="number">256</span></span><br><span class="line"><span class="keyword">var</span> count [][]<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minPathSum</span><span class="params">(grid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    count = <span class="built_in">make</span>([][]<span class="type">int</span>, N)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">        count[i] = <span class="built_in">make</span>([]<span class="type">int</span>, N)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; N; j++ &#123;</span><br><span class="line">            count[i][j] = math.MaxInt</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    count[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="built_in">len</span>(grid)<span class="number">-1</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>])<span class="number">-1</span>, grid)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(m, n <span class="type">int</span>, grid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> count[m][n] != math.MaxInt &#123;</span><br><span class="line">        <span class="keyword">return</span> count[m][n]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> m<span class="number">-1</span> &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        count[m][n] = min(count[m][n], dfs(m<span class="number">-1</span>, n, grid)+grid[m][n])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n<span class="number">-1</span> &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        count[m][n] = min(count[m][n], dfs(m, n<span class="number">-1</span>, grid)+grid[m][n])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count[m][n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="爬楼梯"><a href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a></h1><p>最最经典的 dp 了！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> N = <span class="number">64</span></span><br><span class="line"><span class="keyword">var</span> dp = <span class="built_in">make</span>([]<span class="type">int</span>, N)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编辑距离"><a href="https://leetcode.cn/problems/edit-distance/">编辑距离</a></h1><p>哇这个题目感觉有点难度</p><p>我先从暴搜开始想，感觉纯 BFS 还是纯 DFS 都不行，得剪枝，然后我还想到 A*，就像八数码那样，但是感觉应该是我想复杂了</p><p>然后我一看标签，卧槽动态规划，我只能说这也能用 dp？然后我就去乖乖地看题解了😭</p><p><a href="https://leetcode.cn/problems/edit-distance/solutions/188223/bian-ji-ju-chi-by-leetcode-solution/comments/331399">这个评论</a>感觉讲的很清楚，主要还是要理解转移方程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDistance</span><span class="params">(word1 <span class="type">string</span>, word2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   m, n := <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">   dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">      dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m+<span class="number">1</span>; i++ &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = i</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n+<span class="number">1</span>; j++ &#123;</span><br><span class="line">      dp[<span class="number">0</span>][j] = j</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m+<span class="number">1</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n+<span class="number">1</span>; j++ &#123;</span><br><span class="line">         <span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>] &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = <span class="number">1</span> + Min(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>])</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Min</span><span class="params">(args ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   min := args[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">for</span> _, item := <span class="keyword">range</span> args &#123;</span><br><span class="line">      <span class="keyword">if</span> item &lt; min &#123;</span><br><span class="line">         min = item</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;全排列&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/permutations/&quot;&gt;全排列&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://nickxu.me/2022/07/10/%E3%80%8E%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97%E3%80%8F%E6%8E%92%E5%88%97%E4%B8%8E%E7%BB%84%E5%90%88/?highlight=%E6%8E%92%E5%88%97#%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%EF%BC%88%E6%B3%95%E4%BA%8C%EF%BC%8C%E6%8E%A8%E8%8D%90%EF%BC%89&quot;&gt;板子题&lt;/a&gt;，不解释&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『LeetCode-HOT-100』T11～T20</title>
    <link href="https://nickxu.me/post/leetcode-hot-100-t11-t20.html"/>
    <id>https://nickxu.me/post/leetcode-hot-100-t11-t20.html</id>
    <published>2023-07-30T11:40:58.000Z</published>
    <updated>2023-08-14T09:59:07.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有效的括号"><a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a></h1><p>栈的经典题目了属于是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    stack := <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; <span class="built_in">len</span>(s); k++ &#123;</span><br><span class="line">        i := s[k]</span><br><span class="line">        <span class="keyword">switch</span> i &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            stack = stack + <span class="type">string</span>(i)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> stack != <span class="string">&quot;&quot;</span> &amp;&amp; stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">                stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">            stack = stack + <span class="type">string</span>(i)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> stack != <span class="string">&quot;&quot;</span> &amp;&amp; stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] == <span class="string">&#x27;&#123;&#x27;</span> &#123;</span><br><span class="line">                stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">            stack = stack + <span class="type">string</span>(i)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> stack != <span class="string">&quot;&quot;</span> &amp;&amp; stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] == <span class="string">&#x27;[&#x27;</span> &#123;</span><br><span class="line">                stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> stack == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="合并两个有序链表"><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">合并两个有序链表</a></h1><p>做过了，请见<a href="/posts/275.html#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">『算法拾遗』链表（Linked List）</a></p><h1 id="括号生成"><a href="https://leetcode.cn/problems/generate-parentheses/">括号生成</a></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    ans = []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    dfs(<span class="number">0</span>, n)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    curr <span class="type">string</span></span><br><span class="line">    ans  []<span class="type">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(count <span class="type">int</span>, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(curr) &gt;= n*<span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, curr)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre := curr</span><br><span class="line">    <span class="keyword">if</span> count &lt; n &#123;</span><br><span class="line">        curr = pre + <span class="string">&quot;(&quot;</span></span><br><span class="line">        dfs(count+<span class="number">1</span>, n)</span><br><span class="line">        curr = pre</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> count &gt; <span class="number">0</span> &#123;</span><br><span class="line">        curr = pre + <span class="string">&quot;)&quot;</span></span><br><span class="line">        dfs(count<span class="number">-1</span>, n)</span><br><span class="line">        curr = pre</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="合并-K-个升序链表"><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">合并 K 个升序链表</a></h1><p>方法很多</p><ol><li>暴力解：把所有链表的结点都拆出来，值存在一个切片里，然后排序再构建一个新链表返回</li><li>逐个对比头结点：每次逐一比较每个链表的头节点值，生成新链表</li><li>优先队列头节点：使用优先队列，存储所有链表的头节点值，之后动态取出最大值</li><li>逐一合并： 使用 合并两个有序链表 的方法，将所有链表逐个合到第一个链表中</li><li>两两合并：和上一种类型，但是是将链表两两合并，就跟淘汰赛一样，最后剩一个</li></ol><h2 id="暴力解">暴力解</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">var</span> vals []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, list := <span class="keyword">range</span> lists &#123;</span><br><span class="line">        curr := list</span><br><span class="line">        <span class="keyword">for</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line">            vals = <span class="built_in">append</span>(vals, curr.Val)</span><br><span class="line">            curr = curr.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort.Ints(vals)</span><br><span class="line"></span><br><span class="line">    dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">    curr := dummy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> vals &#123;</span><br><span class="line">        curr.Next = &amp;ListNode&#123;</span><br><span class="line">            Val: val,</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逐个对比头结点">逐个对比头结点</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    dummy:=&amp;ListNode&#123;&#125;</span><br><span class="line">    curr:=dummy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        minIndex:=<span class="number">-1</span></span><br><span class="line">        minVal:=math.MaxInt32</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index,listHead := <span class="keyword">range</span> lists&#123;</span><br><span class="line">            <span class="keyword">if</span> listHead!=<span class="literal">nil</span> &amp;&amp; listHead.Val&lt;minVal&#123;</span><br><span class="line">                minIndex=index</span><br><span class="line">                minVal=listHead.Val</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> minIndex==<span class="number">-1</span>&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curr.Next=lists[minIndex]</span><br><span class="line">        lists[minIndex]=lists[minIndex].Next</span><br><span class="line">        curr=curr.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先队列头节点">优先队列头节点</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index <span class="type">int</span></span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cmp</span><span class="params">(a, b any)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> utils.IntComparator(</span><br><span class="line">        a.(Node).Val,</span><br><span class="line">        b.(Node).Val,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">    curr := dummy</span><br><span class="line"></span><br><span class="line">    q := priorityqueue.NewWith(cmp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, listHead := <span class="keyword">range</span> lists &#123;</span><br><span class="line">        <span class="keyword">if</span> listHead != <span class="literal">nil</span> &#123;</span><br><span class="line">            q.Enqueue(Node&#123;</span><br><span class="line">                Index: index,</span><br><span class="line">                Val:   listHead.Val,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !q.Empty() &#123;</span><br><span class="line"></span><br><span class="line">        tmp, _ := q.Dequeue()</span><br><span class="line">        minNode := tmp.(Node)</span><br><span class="line">        curr.Next = lists[minNode.Index]</span><br><span class="line">        lists[minNode.Index] = lists[minNode.Index].Next</span><br><span class="line">        curr = curr.Next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> lists[minNode.Index] != <span class="literal">nil</span> &#123;</span><br><span class="line">            q.Enqueue(Node&#123;</span><br><span class="line">                Index: minNode.Index,</span><br><span class="line">                Val:   lists[minNode.Index].Val,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逐一合并">逐一合并</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lists) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(lists); i++ &#123;</span><br><span class="line">        lists[<span class="number">0</span>] = mergeTwoLists(lists[<span class="number">0</span>], lists[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两两合并">两两合并</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lists) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(lists) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    empty := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(lists))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !empty[<span class="number">1</span>] &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="built_in">len</span>(lists) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">            lists[i/<span class="number">2</span>] = mergeTwoLists(lists[i/<span class="number">2</span>], lists[i])</span><br><span class="line">            empty[i] = <span class="literal">true</span></span><br><span class="line">            empty[i/<span class="number">2</span>] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="下一个排列"><a href="https://leetcode.cn/problems/next-permutation/">下一个排列</a></h1><ol><li>从右向左找到第一个升序的位置 <code>i</code></li><li>如果 <code>i &gt;= 0</code>，从右向左找到第一个大于 <code>nums[i]</code> 的位置 <code>j</code></li><li>交换位置 <code>i</code> 和 <code>j</code> 的元素</li><li>反转 <code>i</code> 之后的元素，得到下一个全排列</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextPermutation</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Step 1: 从右向左找到第一个升序的位置 i</span></span><br><span class="line">    i := <span class="built_in">len</span>(nums) - <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">        i--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: 如果 i &gt;= 0，从右向左找到第一个大于 nums[i] 的位置 j</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        j := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &lt;= nums[i] &#123;</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Step 3: 交换位置 i 和 j 的元素</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 4: 反转 i 之后的元素，得到下一个全排列</span></span><br><span class="line">    reverse(nums[i+<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">        left++</span><br><span class="line">        right--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长有效括号"><a href="https://leetcode.cn/problems/longest-valid-parentheses/">最长有效括号</a></h1><h2 id="栈">栈</h2><p>题解里面的先压入 <code>-1</code> 我是真的理解不来，这个是我一开始手搓的，没发现还要连着看之前的记录，后来发现了，就加了个 <code>maxLen</code> ，居然就过了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestValidParentheses</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 某个下标的有效长度，这东西有点dp那味了哈哈哈</span></span><br><span class="line">    maxLen := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    stack := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, i := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, idx)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            pre := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前这对括号的有效长度</span></span><br><span class="line">            maxLen[idx] = idx - pre + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pre<span class="number">-1</span> &gt; <span class="number">0</span> &#123; <span class="comment">// 看看能不能和前面的拼一起👀</span></span><br><span class="line">                maxLen[idx] += maxLen[pre<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> maxLen[idx] &gt; ans &#123;</span><br><span class="line">                ans = maxLen[idx]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划">动态规划</h2><p><code>dp[i]</code> 表示以第 <code>i</code> 个字符为结尾的最长有效括号子串的长度</p><ol><li>对于每个 <code>s[i]</code> 为 <code>(</code> ，<code>dp[i]</code> 必定为 <code>0</code> ，因为以 <code>(</code> 结尾的字符串永远不会是有效的括号子串。</li><li>对于每个 <code>s[i]</code> 为 <code>)</code>，如果 <code>s[i-1]</code> 为 <code>(</code> ，则 <code>dp[i] = dp[i-2] + 2</code></li><li>对于每个 <code>s[i]</code> 为 <code>)</code>，如果 <code>s[i-1]</code> 为 <code>)</code>并且 <code>s[i-dp[i-1]-1]</code> 为 <code>(</code>，则 <code>dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]</code></li></ol><p>我只能说我的🧠不可能自己转的过来🥲</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestValidParentheses</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    maxLength := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> i<span class="number">-2</span> &gt;= <span class="number">0</span> &#123;</span><br><span class="line">                    dp[i] = dp[i<span class="number">-2</span>] + <span class="number">2</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i] = <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> i-dp[i<span class="number">-1</span>]<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> i-dp[i<span class="number">-1</span>]<span class="number">-2</span> &gt;= <span class="number">0</span> &#123;</span><br><span class="line">                    dp[i] = dp[i<span class="number">-1</span>] + <span class="number">2</span> + dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i] = dp[i<span class="number">-1</span>] + <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            maxLength = max(maxLength, dp[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="搜索旋转排序数组"><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></h1><p>修改过的二分法，有点意思</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化左右指针</span></span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用二分查找算法，在搜索范围内查找目标值</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        <span class="comment">// 计算中间位置</span></span><br><span class="line">        mid := left + (right - left) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果中间值等于目标值，则找到目标，返回下标</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断哪一半是有序的</span></span><br><span class="line">        <span class="keyword">if</span> nums[left] &lt;= nums[mid] &#123;</span><br><span class="line">            <span class="comment">// 如果左半段有序</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= target &amp;&amp; target &lt; nums[mid] &#123;</span><br><span class="line">                <span class="comment">// 如果目标值在左半段范围内，则在左半段继续查找</span></span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则在右半段继续查找</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果右半段有序</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target &amp;&amp; target &lt;= nums[right] &#123;</span><br><span class="line">                <span class="comment">// 如果目标值在右半段范围内，则在右半段继续查找</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则在左半段继续查找</span></span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果未找到目标值，则返回 -1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在排序数组中查找元素的第一个和最后一个位置"><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h1><p>也是二分，我的思路是先传统二分找到一个元素，再两侧二分</p><p>其实也可以两次二分，一次找最小值，一次找最大值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idx := findIdx(nums, target)</span><br><span class="line">    fmt.Println(idx)</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left := leftExt(nums, idx)</span><br><span class="line">    right := rightExt(nums, idx)</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;left, right&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findIdx</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    left, right := <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">leftExt</span><span class="params">(nums []<span class="type">int</span>, idx <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    target := nums[idx]</span><br><span class="line">    left, right := <span class="number">0</span>, idx</span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rightExt</span><span class="params">(nums []<span class="type">int</span>, idx <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    target := nums[idx]</span><br><span class="line">    left, right := idx, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := (left + right + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            left = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合总和"><a href="https://leetcode.cn/problems/combination-sum/">组合总和</a></h1><p>想起来高中的经典硬币买商品的题目，但是那个好像是统计有多少种方法，从 0 开始往后 dp 转移就行，这个题感觉递归更好，而且去重也有点麻烦</p><p>选择递归也要处理去重的问题，可以限定每次新的元素不能比之前的元素小（答案元素单调），这样就行了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> curr []<span class="type">int</span> <span class="comment">// 当前选择的元素</span></span><br><span class="line">    <span class="keyword">var</span> ans [][]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(target <span class="type">int</span>, pre <span class="type">int</span>)</span></span> <span class="comment">// 目标 target，之前是第 pre 个元素</span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(target <span class="type">int</span>, pre <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 因为切片是引用类型，所以得深拷贝一下</span></span><br><span class="line">            tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(curr))</span><br><span class="line">            <span class="built_in">copy</span>(tmp, curr)</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := pre; i &lt; <span class="built_in">len</span>(candidates); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> target-candidates[i] &gt;= <span class="number">0</span> &#123;</span><br><span class="line">                curr = <span class="built_in">append</span>(curr, candidates[i])</span><br><span class="line">                dfs(target-candidates[i], i)</span><br><span class="line">                curr = curr[:<span class="built_in">len</span>(curr)<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(target, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接雨水"><a href="https://leetcode.cn/problems/trapping-rain-water/">接雨水</a></h1><p>哇经典接雨水，之前三维接雨水把我折腾的够呛（</p><p>这道题解法太多了，除了暴力（每个位置往左右扫，看左右最高有多少），还有动态规划，栈和双指针等，下面是动态规划的写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="type">int</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(height)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leftMax := <span class="built_in">make</span>([]<span class="type">int</span>, n)  <span class="comment">// 当前及左边的最大高度</span></span><br><span class="line">    rightMax := <span class="built_in">make</span>([]<span class="type">int</span>, n) <span class="comment">// 当前及右边的最大高度</span></span><br><span class="line">    leftMax[<span class="number">0</span>] = height[<span class="number">0</span>]</span><br><span class="line">    rightMax[n<span class="number">-1</span>] = height[n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        leftMax[i] = max(leftMax[i<span class="number">-1</span>], height[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        rightMax[i] = max(rightMax[i+<span class="number">1</span>], height[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, h := <span class="keyword">range</span> height &#123;</span><br><span class="line">        ans += min(leftMax[idx], rightMax[idx]) - h</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;有效的括号&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/valid-parentheses/&quot;&gt;有效的括号&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;栈的经典题目了属于是&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『LeetCode-HOT-100』T1～T10</title>
    <link href="https://nickxu.me/post/leetcode-hot-100-t1-t10.html"/>
    <id>https://nickxu.me/post/leetcode-hot-100-t1-t10.html</id>
    <published>2023-07-24T09:40:22.000Z</published>
    <updated>2023-08-14T09:59:03.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两数之和"><a href="https://leetcode.cn/problems/two-sum/?envType=featured-list&amp;envId=2cktkvj">两数之和</a></h1><h2 id="暴力枚举">暴力枚举</h2><p>暴力枚举 <code>i</code> 和 <code>j</code> ，没什么好说的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i]+nums[j] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> []<span class="type">int</span>&#123;i, j&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希表">哈希表</h2><p>对于每一个 <code>x</code>，检查以前有没有遍历过另一半</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        j, ok := m[target-x]</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;i, j&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m[x] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="两数相加"><a href="https://leetcode.cn/problems/add-two-numbers/?envType=featured-list&amp;envId=2cktkvj">两数相加</a></h1><p>一开始想着能不能抽离出一个函数用来维护 <code>ans</code> 链表，结果这东西不能解决最后的进位问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 创建一个哨兵节点作为新链表的头部</span></span><br><span class="line">    dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">    curr := dummy</span><br><span class="line"></span><br><span class="line">    i, j := l1, l2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i != <span class="literal">nil</span> &amp;&amp; j != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">        addNum(&amp;curr, i.Val+j.Val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i.Next == <span class="literal">nil</span> &amp;&amp; j.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j != <span class="literal">nil</span> &#123;</span><br><span class="line">                addNum(&amp;curr, j.Val)</span><br><span class="line">                j = j.Next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> j.Next == <span class="literal">nil</span> &amp;&amp; i.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i != <span class="literal">nil</span> &#123;</span><br><span class="line">                addNum(&amp;curr, i.Val)</span><br><span class="line">                i = i.Next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i = i.Next</span><br><span class="line">        j = j.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNum</span><span class="params">(curr **ListNode, num <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(num)</span><br><span class="line"></span><br><span class="line">    (*curr).Val = ((*curr).Val + num) % <span class="number">10</span></span><br><span class="line">    (*curr).Next = &amp;ListNode&#123;</span><br><span class="line">        Val:  num / <span class="number">10</span>,</span><br><span class="line">        Next: <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(*curr)</span><br><span class="line"></span><br><span class="line">    *curr = (*curr).Next</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没办法，还是按照题解的思路打了一遍</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 创建一个哨兵节点作为新链表的头部</span></span><br><span class="line">    dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">    curr := dummy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂存进位</span></span><br><span class="line">    tmp := <span class="number">0</span></span><br><span class="line">    i, j := l1, l2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i != <span class="literal">nil</span> || j != <span class="literal">nil</span> &#123;</span><br><span class="line">        x, y := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i != <span class="literal">nil</span> &#123;</span><br><span class="line">            x = i.Val</span><br><span class="line">            i = i.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j != <span class="literal">nil</span> &#123;</span><br><span class="line">            y = j.Val</span><br><span class="line">            j = j.Next</span><br><span class="line">        &#125;</span><br><span class="line">        sum := x + y + tmp</span><br><span class="line">        sum, tmp = sum%<span class="number">10</span>, sum/<span class="number">10</span></span><br><span class="line"></span><br><span class="line">        curr.Next = &amp;ListNode&#123;Val: sum&#125;</span><br><span class="line">        curr = curr.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tmp &gt; <span class="number">0</span> &#123;</span><br><span class="line">        curr.Next = &amp;ListNode&#123;Val: tmp&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="无重复字符的最长子串"><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h1><h2 id="暴力枚举-2">暴力枚举</h2><p>你应该想到的怎么写，不写了</p><h2 id="滑动窗口">滑动窗口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录某个字符有没有出现过，也可以用 [128]int&#123;&#125;</span></span><br><span class="line">    set := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="comment">// 左右指针</span></span><br><span class="line">    i, j, ans := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j &lt; n &#123;</span><br><span class="line">        <span class="keyword">if</span> set[s[j]] &#123; <span class="comment">// 如果存在，就在左侧一直删，删到不存在</span></span><br><span class="line">            <span class="built_in">delete</span>(set, s[i])</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不存在就记录并更新长度</span></span><br><span class="line">            set[s[j]] = <span class="literal">true</span></span><br><span class="line">            ans = max(ans, j-i+<span class="number">1</span>)</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="寻找两个正序数组的中位数"><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></h1><h2 id="合并后排序">合并后排序</h2><p>没什么好说的，最暴力的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    nums3 := <span class="built_in">append</span>(nums1, nums2...)</span><br><span class="line">    sort.Ints(nums3)</span><br><span class="line">    <span class="comment">// fmt.Println(nums3)</span></span><br><span class="line"></span><br><span class="line">    n := <span class="built_in">len</span>(nums3)</span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">float64</span>(nums3[n/<span class="number">2</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">float64</span>(nums3[n/<span class="number">2</span>]+nums3[n/<span class="number">2</span><span class="number">-1</span>]) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用归并法有序合并">使用归并法有序合并</h2><p>不写了，就是归并排序的其中一步</p><h2 id="双指针逐个移动">双指针逐个移动</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="comment">// 定义三个指针和两个数组长度</span></span><br><span class="line">    i, j, k := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    n1, n2 := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="comment">// 定义中位数变量和之前的值</span></span><br><span class="line">    pre, cur := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment">// 计算总元素个数</span></span><br><span class="line">    m := n1 + n2</span><br><span class="line">    <span class="comment">// 计算中位数的位置</span></span><br><span class="line">    mid := m / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环，直到找到中位数的位置</span></span><br><span class="line">    <span class="keyword">for</span> k &lt;= mid &#123;</span><br><span class="line">        <span class="comment">// 保存上一次的值</span></span><br><span class="line">        pre = cur</span><br><span class="line">        <span class="comment">// 比较两个数组的元素，将较小的元素放入当前位置，指针向后移动</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; n1 &amp;&amp; j &lt; n2 &#123;</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &lt; nums2[j] &#123;</span><br><span class="line">                cur = nums1[i]</span><br><span class="line">                i++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = nums2[j]</span><br><span class="line">                j++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> i &lt; n1 &#123; <span class="comment">// 第一个数组还有剩余元素</span></span><br><span class="line">            cur = nums1[i]</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 第二个数组还有剩余元素</span></span><br><span class="line">            cur = nums2[j]</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        k++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断总元素个数是奇数还是偶数，返回相应的结果</span></span><br><span class="line">    <span class="keyword">if</span> m % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">float64</span>(pre + cur) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">float64</span>(cur)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双指针二分移动（类似第-k-小数）">双指针二分移动（类似第 k 小数）</h2><p>建议去看一眼题解👀</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="comment">// 确保nums1是较短的数组</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums1) &gt; <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">        nums1, nums2 = nums2, nums1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取两个数组的长度</span></span><br><span class="line">    m, n := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="comment">// 计算总元素个数</span></span><br><span class="line">    total := m + n</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义二分查找的边界</span></span><br><span class="line">    left, right := <span class="number">0</span>, m</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        <span class="comment">// 二分查找分割线的位置</span></span><br><span class="line">        partition1 := (left + right) / <span class="number">2</span></span><br><span class="line">        partition2 := (total+<span class="number">1</span>)/<span class="number">2</span> - partition1</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算分割线两边的最大最小值</span></span><br><span class="line">        maxLeft1 := math.MinInt32</span><br><span class="line">        <span class="keyword">if</span> partition1 &gt; <span class="number">0</span> &#123;</span><br><span class="line">            maxLeft1 = nums1[partition1<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maxLeft2 := math.MinInt32</span><br><span class="line">        <span class="keyword">if</span> partition2 &gt; <span class="number">0</span> &#123;</span><br><span class="line">            maxLeft2 = nums2[partition2<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        minRight1 := math.MaxInt32</span><br><span class="line">        <span class="keyword">if</span> partition1 &lt; m &#123;</span><br><span class="line">            minRight1 = nums1[partition1]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        minRight2 := math.MaxInt32</span><br><span class="line">        <span class="keyword">if</span> partition2 &lt; n &#123;</span><br><span class="line">            minRight2 = nums2[partition2]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否找到了正确的分割线</span></span><br><span class="line">        <span class="keyword">if</span> maxLeft1 &lt;= minRight2 &amp;&amp; maxLeft2 &lt;= minRight1 &#123;</span><br><span class="line">            <span class="comment">// 根据总元素个数是奇数还是偶数返回结果</span></span><br><span class="line">            <span class="keyword">if</span> total % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="type">float64</span>(max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / <span class="number">2.0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="type">float64</span>(max(maxLeft1, maxLeft2))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> maxLeft1 &gt; minRight2 &#123;</span><br><span class="line">            <span class="comment">// 如果当前分割线左侧的元素过多，缩小右边界</span></span><br><span class="line">            right = partition1 - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前分割线右侧的元素过多，增大左边界</span></span><br><span class="line">            left = partition1 + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span> <span class="comment">// 输入数组有误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，返回两个整数中较大的一个</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，返回两个整数中较小的一个</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details class="toggle"><summary class="toggle-button" style="">GPT 的解释</summary><div class="toggle-content"><p>当我们处理两个已排序的数组，要找到它们的中位数时，使用二分查找是一种高效的方法。这个方法的核心思想是在较短的数组上进行二分查找，通过分割线将两个数组划分成左右两部分，并满足一定的条件。让我们详细解释一下这个二分法。</p><ol><li><p>确定较短的数组：为了减少时间复杂度，我们选择在较短的数组上进行二分查找。首先，我们比较两个数组的长度，如果nums1的长度大于nums2的长度，则交换它们，确保nums1是较短的数组。</p></li><li><p>设定二分查找的边界：我们在较短数组nums1上进行二分查找，所以我们设定左边界<code>left</code>为0，右边界<code>right</code>为nums1的长度。</p></li><li><p>二分查找：我们在nums1数组上进行二分查找，每次迭代都计算一个分割线的位置<code>partition1</code>，以及另一个数组nums2中对应的分割线位置<code>partition2</code>。</p></li><li><p>计算分割线两边的最大最小值：我们分别计算两个数组中分割线两边的最大和最小值。设<code>maxLeft1</code>为nums1中左边部分的最大值，<code>maxLeft2</code>为nums2中左边部分的最大值，<code>minRight1</code>为nums1中右边部分的最小值，<code>minRight2</code>为nums2中右边部分的最小值。</p></li><li><p>判断是否找到正确的分割线：如果<code>maxLeft1</code>小于等于<code>minRight2</code>且<code>maxLeft2</code>小于等于<code>minRight1</code>，说明当前的分割线位置是正确的。这是因为我们需要确保左边的元素都小于等于右边的元素，且左边的部分的长度与右边的部分长度相等或相差1（这样才能得到中位数）。如果条件满足，则我们已经找到了正确的分割线。</p></li><li><p>调整分割线位置：如果当前分割线位置不正确，我们需要根据<code>maxLeft1</code>和<code>minRight2</code>之间的关系来调整分割线位置。如果<code>maxLeft1</code>大于<code>minRight2</code>，说明nums1的分割线位置过大，需要将右边界<code>right</code>向左移动；如果<code>maxLeft2</code>大于<code>minRight1</code>，说明nums1的分割线位置过小，需要将左边界<code>left</code>向右移动。然后继续进行二分查找，直到找到正确的分割线位置。</p></li><li><p>返回结果：根据总元素个数是奇数还是偶数，返回相应的结果。如果总元素个数是偶数，则中位数为两个中间值的平均数；如果总元素个数是奇数，则中位数为较长的数组中的中间值。</p></li></ol><p>通过这种方法，我们可以在O(log(min(m, n)))的时间复杂度内找到两个已排序数组的中位数，是一种高效且优雅的解决方案。</p></div></details><h1 id="最长回文子串"><a href="https://leetcode.cn/problems/longest-palindromic-substring/">最长回文子串</a></h1><h2 id="暴力枚举-3">暴力枚举</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    ans := <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(s)+<span class="number">1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> isPaling(s[i:j]) &amp;&amp; <span class="built_in">len</span>(s[i:j]) &gt; <span class="built_in">len</span>(ans) &#123;</span><br><span class="line">                ans = s[i:j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPaling</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s)/<span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] != s[<span class="built_in">len</span>(s)-i<span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举中心并扩展">枚举中心并扩展</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> start, end <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        left1, right1 := expandAroundCenter(s, i, i)</span><br><span class="line">        left2, right2 := expandAroundCenter(s, i, i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> right1-left1 &gt; end-start &#123;</span><br><span class="line">            start, end = left1, right1</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> right2-left2 &gt; end-start &#123;</span><br><span class="line">            start, end = left2, right2</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[start : end+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">expandAroundCenter</span><span class="params">(s <span class="type">string</span>, left, right <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> left &gt;= <span class="number">0</span> &amp;&amp; right &lt; <span class="built_in">len</span>(s) &amp;&amp; s[left] == s[right] &#123;</span><br><span class="line">        left = left - <span class="number">1</span></span><br><span class="line">        right = right + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left + <span class="number">1</span>, right - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划">动态规划</h2><ul><li>$      dp[i][j]$  表示 <code>s[i][j]</code> 是回文</li><li>转移方程： $      dp[i][j]$ = $      dp[i+1][j-1]$ and  $      s[i]==s[j]$</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">bool</span>, n)</span><br><span class="line">    ans := s[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">        dp[i][i] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l := <span class="number">2</span>; l &lt;= n; l++ &#123;</span><br><span class="line">        <span class="keyword">for</span> start := <span class="number">0</span>; start &lt; n-l+<span class="number">1</span>; start++ &#123;</span><br><span class="line">            end := start + l - <span class="number">1</span></span><br><span class="line">            <span class="comment">// 首位是否相同</span></span><br><span class="line">            <span class="keyword">if</span> s[start] == s[end] &#123;</span><br><span class="line">                <span class="keyword">if</span> l == <span class="number">2</span> &#123;</span><br><span class="line">                    dp[start][end] = <span class="literal">true</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[start][end] = dp[start+<span class="number">1</span>][end<span class="number">-1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新答案</span></span><br><span class="line">                <span class="keyword">if</span> dp[start][end] == <span class="literal">true</span> &amp;&amp; (end-start+<span class="number">1</span>) &gt; <span class="built_in">len</span>(ans) &#123;</span><br><span class="line">                    ans = s[start : end+<span class="number">1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="正则表达式匹配"><a href="https://leetcode.cn/problems/regular-expression-matching/">正则表达式匹配</a></h1><p>hard 题，先放弃了</p><p>动态规划，<code>dp[i][j]</code> 表示 <code>s</code> 的前 <code>i</code> 个字符和 <code>p</code> 的前<code>j</code> 个字符是否能匹配</p><details class="toggle"><summary class="toggle-button" style="">转移方程 GPT</summary><div class="toggle-content"><p>对于状态转移方程的解释，我们来具体说明一下在动态规划中如何构建状态转移。</p><p>我们使用 <code>dp[i][j]</code> 来表示 <code>s</code> 的前 <code>i</code> 个字符和 <code>p</code> 的前 <code>j</code> 个字符是否匹配。</p><ol><li><p>当 <code>p[j-1]</code> 是普通字符（小写字母），且与 <code>s[i-1]</code> 匹配时，<code>dp[i][j]</code> 的值由 <code>dp[i-1][j-1]</code> 决定。即：</p> <figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="code"><pre><span class="line">if p[j-1] == s[i-1] {</span><br><span class="line">    dp[i][j] = dp[i-1][j-1]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>当 <code>p[j-1]</code> 是 “.”（匹配任意单个字符）时，<code>dp[i][j]</code> 的值同样由 <code>dp[i-1][j-1]</code> 决定。即：</p> <figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="code"><pre><span class="line">if p[j-1] == '.' {</span><br><span class="line">    dp[i][j] = dp[i-1][j-1]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>当 <code>p[j-1]</code> 是 “*”（匹配零个或多个前面的字符）时，情况稍微复杂一些。</p><ul><li><p>如果 <code>p[j-2]</code> 与 <code>s[i-1]</code> 不匹配，那么 <code>*</code> 只能让 <code>p</code> 的前面两个字符消失，即匹配 0 次，<code>dp[i][j]</code> 的值由 <code>dp[i][j-2]</code> 决定。即：</p>   <figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="code"><pre><span class="line">if p[j-1] == '*' &amp;&amp; p[j-2] != s[i-1] {</span><br><span class="line">    dp[i][j] = dp[i][j-2]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>如果 <code>p[j-2]</code> 与 <code>s[i-1]</code> 匹配，或者 <code>p[j-2]</code> 是 “.”（匹配任意单个字符），那么我们有多种选择：</p><ul><li><code>*</code> 匹配 0 次：<code>dp[i][j]</code> 的值由 <code>dp[i][j-2]</code> 决定。</li><li><code>*</code> 匹配 1 次：<code>dp[i][j]</code> 的值由 <code>dp[i-1][j-2]</code> 决定。</li><li><code>*</code> 匹配多次：<code>dp[i][j]</code> 的值由 <code>dp[i-1][j]</code> 决定。</li></ul><p>综合上述情况，<code>dp[i][j]</code> 的值为这些选择的逻辑或（<code>||</code>）结果。即：</p>   <figure class="highlight plaintext"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">plaintext</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="code"><pre><span class="line">if p[j-1] == '*' &amp;&amp; (p[j-2] == s[i-1] || p[j-2] == '.') {</span><br><span class="line">    dp[i][j] = dp[i][j-2] || dp[i-1][j-2] || dp[i-1][j]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol><p>这就是状态转移方程的具体表达式，通过合理的状态转移，我们可以在动态规划的过程中求解出 <code>dp[m][n]</code> 的值，其中 <code>m</code> 是字符串 <code>s</code> 的长度，<code>n</code> 是字符规律 <code>p</code> 的长度。最终，<code>dp[m][n]</code> 的值即为整个字符串 <code>s</code> 和字符规律 <code>p</code> 是否匹配的结果。</p></div></details><h1 id="盛最多水的容器"><a href="https://leetcode.cn/problems/container-with-most-water/">盛最多水的容器</a></h1><p>经典的二维接雨水，双指针法</p><p>已知：</p><ul><li>相同情况下，两边越远越好</li><li>面积受限于短边</li></ul><p>策略：</p><ul><li>从左右两边开始往中间扫</li><li>尽量保持长边不动，移动短边</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(height)</span><br><span class="line"></span><br><span class="line">    left, right := <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        ans = max(ans, (right-left)*min(height[right], height[left]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> height[left] &gt; height[right] &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三数之和"><a href="https://leetcode.cn/problems/3sum/">三数之和</a></h1><p>排序+双指针，<a href="https://leetcode.cn/problems/3sum/solutions/11525/3sumpai-xu-shuang-zhi-zhen-yi-dong-by-jyd/?envType=featured-list&amp;envId=2cktkvj">这篇题解</a>讲的很好</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; n<span class="number">-2</span>; k++ &#123; <span class="comment">// 第一个数</span></span><br><span class="line">        <span class="keyword">if</span> nums[k] &gt; <span class="number">0</span> &#123; <span class="comment">// 因为 k,i,j 递增，如果 k&gt;0 就直接不可能了</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k<span class="number">-1</span>] &#123;  <span class="comment">// 跳过重复</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        i, j := k+<span class="number">1</span>, n<span class="number">-1</span> <span class="comment">// i,j 从 [k+1,n-1] 向中间走</span></span><br><span class="line">        <span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">            sum := nums[k] + nums[i] + nums[j]</span><br><span class="line">            <span class="keyword">if</span> sum == <span class="number">0</span> &#123;</span><br><span class="line">                ans = <span class="built_in">append</span>(ans, []<span class="type">int</span>&#123;nums[k], nums[i], nums[j]&#125;)</span><br><span class="line">                <span class="keyword">for</span> i &lt; j &amp;&amp; nums[i] == nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">                    i++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> i &lt; j &amp;&amp; nums[j] == nums[j<span class="number">-1</span>] &#123;</span><br><span class="line">                    j--</span><br><span class="line">                &#125;</span><br><span class="line">                i++</span><br><span class="line">                j--</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &gt; <span class="number">0</span> &#123; <span class="comment">// 依据递增性质，调整 i,j</span></span><br><span class="line">                j--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="电话号码的字母组合"><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合</a></h1><p>经典回溯，但是我感觉 BFS 的思路更清晰</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">byte</span>][]<span class="type">string</span>&#123;</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;3&#x27;</span>: &#123;<span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;4&#x27;</span>: &#123;<span class="string">&quot;g&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;i&quot;</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;5&#x27;</span>: &#123;<span class="string">&quot;j&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;l&quot;</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;6&#x27;</span>: &#123;<span class="string">&quot;m&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;o&quot;</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;7&#x27;</span>: &#123;<span class="string">&quot;p&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;s&quot;</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;8&#x27;</span>: &#123;<span class="string">&quot;t&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;v&quot;</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;9&#x27;</span>: &#123;<span class="string">&quot;w&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> digits == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> queue []<span class="type">string</span></span><br><span class="line">    queue = <span class="built_in">append</span>(queue, m[digits[<span class="number">0</span>]]...) <span class="comment">// 把首位数字对应的字母放入队列</span></span><br><span class="line">    digits = digits[<span class="number">1</span>:]                    <span class="comment">// 去掉首位数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> digits != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> tmp []<span class="type">string</span></span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> queue &#123;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp, combination(v, digits[<span class="number">0</span>])...)</span><br><span class="line">        &#125;</span><br><span class="line">        queue = tmp</span><br><span class="line">        digits = digits[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 s 的结尾分别加上 target 的映射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combination</span><span class="params">(s <span class="type">string</span>, target <span class="type">byte</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ans []<span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> m[target] &#123;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, s+v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除链表的倒数第-N-个结点"><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></h1><p>做过了，请见<a href="/posts/275.html#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9">『算法拾遗』链表（Linked List）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/two-sum/?envType=featured-list&amp;amp;envId=2cktkvj&quot;&gt;两数之和&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&quot;暴力枚举&quot;&gt;暴力枚举&lt;/h2&gt;
&lt;p&gt;暴力枚举 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; ，没什么好说的&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『OSPP2023』我与 OSPP 的故事 —— 从听闻到中选</title>
    <link href="https://nickxu.me/2023/06/my-story-with-OSPP-from-hearing-to-being-selected.html"/>
    <id>https://nickxu.me/2023/06/my-story-with-OSPP-from-hearing-to-being-selected.html</id>
    <published>2023-06-30T06:41:59.000Z</published>
    <updated>2023-08-19T09:27:02.901Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://image.nickxu.me/202306301521080.jpeg" alt=""></p><blockquote><p>6月26日下午3点，OSPP2023 中选结果正式发布，<a href="https://summer-ospp.ac.cn/news/data">全球共有 1486 人成功申请，最终中选人数为 504 人</a></p><p>鄙人非常荣幸地成为了这 504 个幸运儿的一份子，特撰此文，记录 <code>我与 OSPP 的故事 —— 从听闻到中选</code></p><p>当然，我也希望这篇博客能够吸引更多人参与开源，为开源项目做出自己的贡献</p></blockquote><details class="toggle" ><summary class="toggle-button" style="">给「杭电助手」打点小广告</summary><div class="toggle-content"><p><img src="https://image.nickxu.me/202306301616858.jpeg" alt="IMG_0166"></p><p>本次开源之夏活动，杭州电子科技大学共中选 13 人，其中 8 人来自杭电助手</p><p>杭助本次共参与 11 人，中选率高达 8/11</p><p>（另外今年另有 1 人中选 GSoC，1 人 LFX Mentorship ）</p><p><img src="https://image.nickxu.me/202306301625148.png" alt="img"></p><blockquote><p>欢迎热爱技术的同学们填报杭州电子科技大学，欢迎同学们选择杭电助手技术部！ <a href="https://mp.weixin.qq.com/s/4hU4m2Y1eH3VfbTU267e1w">查看推文</a></p></blockquote></div></details><hr><h1 id="写在前面">写在前面</h1><p>这里是对不了解开源活动的同学进行一点飞速的补充，简短地谈一下我的理解</p><p>其实已经有很多文章讲的很好了，这里我推荐一篇杭助成员「爱飞的鸟」的 <a href="https://blog.aflybird.cn/2023/01/before-good-first-issue/">Before Good First Issue</a></p><h2 id="开源活动是什么">开源活动是什么</h2><p>开源活动通常是由开源社区、组织或公司组织的活动，目的在于吸引更多的人（特别是学生）参与开源，帮助构建开源项目，增加开源社区热度，推广开源文化与价值观，为开源事业作出贡献</p><p>比较有名的比如 LFX Mentorship、谷歌的 GSoC、国内的 OSPP、GLCC 等</p><p>一般的形式是这样的：由活动主办方提供平台与资金，吸引各路开源社区/组织入驻，社区挑选目前要做的一些活作为若干子项目（写清楚具体要做什么事情，最终达成什么目的），并且分配至少一个导师专门负责这个项目（大多数是一个）</p><p>学生呢需要给导师写 Proposal（申请书），阐述自己对这个项目的想法（如何实现），并努力让导师相信自己能够很好地完成这个项目</p><p>最终每个项目的导师会在所有申请的学生中挑选一个来做这个项目，并进行一对一的指导，帮助学生最终完成任务</p><p>这时候你就会发现，这里是存在竞争的，并且是零和博弈，赢者通吃，不过你也可以同时尝试多个项目，这样最终中选的可能就大一些</p><h2 id="为什么要参加开源活动">为什么要参加开源活动</h2><p>TL;DR，主要有下面几个吸引你的理由</p><ol><li><p>钱</p><img src="https://image.nickxu.me/202306302249043.png" alt="image-20230630下午104907011" style="zoom:50%;" /><blockquote><p>OSPP 文档中关于奖金的说明</p></blockquote><p>哈哈哈谁会和钱过不去呢？吸引别人参与活动最直接的方法就是物质奖励</p><p>一般来说是 6000 起步（GLCC），OSPP 是 8000 和 12000 两档，而 GSoC 则是 3000 刀起步（国内学生，不同地区奖金不同）</p><p><s>开源之夏也被叫做 mac 之夏，因为很多人都会去拿钱买 mac</s></p><p>当然，钱可能是最开始吸引你地方，但是你日后会发现下面的理由是更加吸引你的地方</p><p>甚至会觉得让你觉得倒贴钱你也愿意</p></li><li><p>接触顶级项目</p><img src="https://image.nickxu.me/202306302242256.png" alt="image-20230630下午104203209" style="zoom: 50%;" /><blockquote><p>杭助今年中了 GSoC 的 daidr，参加的是 chromium，他被邀请旁听内部会议</p></blockquote><p>参加开源活动的不乏一些顶级的开源项目，比如说 git，又比如说 chromium，你将有机会给它们贡献自己的代码</p><p>以后，你就可以自豪地和别人说</p><ul><li>不会用 git？我可以教你，我也是开发者之一哦</li><li>你知道吗，你用的浏览器里面有我的代码哦</li></ul><p>是不是非常的让人刮目相看？</p></li><li><p>结交朋友，积累人脉</p><img src="https://image.nickxu.me/202306302246602.png" alt="image-20230630下午104639571" style="zoom:50%;" /><blockquote><p>我的导师说他看了我的博客，居然主动问我最近是不是对找实习有些焦虑（</p><p>然后给我的简历提意见，跟我聊了很多求职就业的内容</p></blockquote><p>在社区中参与项目能让你积累很多大牛的人脉，并且参与社区内部事务</p><p>而且甚至导师们可能会主动和你交朋友</p><p>我前天也和 MOSN 里的大佬一起连麦开会，主要内容开完后和我一起聊天，有机会和阿里、蚂蚁、京东的大牛一起聊天，这真的是非常宝贵的经历</p></li><li><p>提升个人能力</p><p>正如前文所说，开源活动的目的是吸引更多的人来参与开源</p><p>所以这个活动并不是一个「我给你钱，你给我干活」的雇佣关系，而是「欢迎你来，我培养你」的关系</p><p>导师会为你的开发提供指导，你可以围绕项目向导师与社区提出自己的问题</p><p>在开发过程中，你可以学到很多知识，丰富个人经验，提升个人能力</p><p>（当然，也不是所有的导师和社区都有这么好，这也是我后文会讲的内容）</p></li><li><p>丰富简历</p><p>能参与到开源活动中肯定是能写进简历的，以后肯定也能作为与他人的谈资</p></li></ol><h2 id="关于开源之夏（OSPP）">关于开源之夏（OSPP）</h2><p><img src="https://image.nickxu.me/202307012225862.png" alt="image-20230701下午102543373"></p><blockquote><p>今年是 OSPP 的第四个年头，不知道明年会有多少人</p></blockquote><p><a href="https://summer-ospp.ac.cn/">OSPP (Open Source Promotion Plan)</a> 应该是中科院对标谷歌的 GSoC 举办的活动，在国内算是含金量最高的了</p><p>贴几段比较正式的介绍：</p><ul><li>“开源之夏（英文简称 OSPP）”是中科院软件所“开源软件供应链点亮计划”指导下的系列暑期活动，由软件所与 openEuler 社区共同主办、中科南京软件技术研究院承办，旨在鼓励在校学生积极参与开源软件的开发维护，培养和发掘更多优秀的开发者，促进优秀开源软件社区的蓬勃发展，助力开源软件供应链建设</li><li>活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。学生可自主选择感兴趣的项目进行申请，中选后在项目资深开发者（社区导师）的指导下进行开发。根据项目的难易程度和完成情况，结项者将获取开源之夏活动奖金和结项证书</li><li>开源之夏活动已迈入第四个年头。在过去的三年中，开源之夏与众多蓬勃发展的开源社区携手并进，不断推动开源技术在高校学生中的普及和推广，使得越来越多的学生参与到开源项目中来，更多优秀的开源贡献者和开源项目应运而生，为推动开源生态发展提供了有力的支持</li></ul><p>整体活动流程同 GSoC，社区报名-官方发布社区入选名单-社区发布项目-学生开始申请-社区发布学生名单-学生开始贡献，每个人可以提交三份申请，只能中选一个项目</p><p>难度上感觉比 GSoC 简单不少，GSoC 阿三的确是真的多</p><img src="https://image.nickxu.me/202307012239237.png" alt="image-20230701下午103928213" style="zoom: 67%;" /><blockquote><p>iyear 对于 OSPP 难度的评价，我感觉挺中肯的</p></blockquote><hr><h1 id="个人经历">个人经历</h1><h2 id="开始的开始">开始的开始</h2><p>在我的印象中，应该是「iyear」和「鸟」最开始在社团里说 OSPP 和 GSoC 这些事情</p><p>于是去年我就开始慢慢关注了，但当时 2022 年的都已经快结束了，所以我开始搜集信息，为明年准备</p><p>我要找哪些东西呢？</p><ul><li>第一个，我要看看过去都是些什么项目</li><li>第二个，我要去看 timeline ，熟悉里面几个比较重要的时间节点</li><li>最重要的是，我要知道竞争的激烈程度，中选率大概是个什么情况</li></ul><p>首先我去了 <a href="https://summerofcode.withgoogle.com/">GSoC 的官网</a>，然后开始翻，然后发现怎么这么多出名的项目哇，什么 VLC，什么 Electron，还有 Chromium，还有 git 、GUN，我怎么配的上这些项目哇（</p><p>然后我去翻了翻申请人和中选人数，大概有四分之一的概率中选</p><p>感觉还行吧，说不定可以试试，虽然我知道从 22 年开始，GSoC 的申请不再局限学生，人肯定一年比一年多</p><p><img src="https://image.nickxu.me/202307012352421.png" alt=""></p><blockquote><p>现在又翻了翻今年的，真的吓人，我只能说今年能中 GSoC 的都是神仙</p><p>而且今年的申请人数是什么鬼哇（</p></blockquote><p>然后我去看了 <a href="https://developers.google.com/open-source/gsoc/timeline?hl=zh-cn">timeline</a> ，关注了几个时间点</p><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>GSoC 2023</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2 月 22 日</p></div></div><div class='timeline-item-content'><p>社区、项目名单公布</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>3 月 20 日</p></div></div><div class='timeline-item-content'><p>开始接受申请</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>4 月 4 日</p></div></div><div class='timeline-item-content'><p>截止申请</p></div></div></div><p>看完了 GSoC，我接着去看 OSPP 的项目</p><p>虽然项目感觉也都很高大上，但是竞争压力看上去更小</p><p><img src="https://image.nickxu.me/202307022303147.png" alt="image-20230702下午110331878"></p><blockquote><p>OSPP2022，只能说从申请与中选的比率来看，其实还行</p></blockquote><p>然后是 2023 的 timeline</p><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>OSPP 2023</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>4 月 4 日</p></div></div><div class='timeline-item-content'><p>社区开始上线项目</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>4 月 29 日</p></div></div><div class='timeline-item-content'><p>开始接受申请</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>6 月 4 日</p></div></div><div class='timeline-item-content'><p>截止申请</p></div></div></div><p>最后，我去翻了翻 iyear 2022 年的项目，真的强哇，我大一在干什么，别人大一在干什么</p><p><s>大一参加 OSPP 进阶，我只能说人与人的差距真的比人与狗的差距还大（</s></p><p>我只能说接下来走一步看一步吧</p><h2 id="没下手的-GSoC">没下手的 GSoC</h2><p>转眼间到了 GSoC 项目公布的日子，iyear 在群里也提了一嘴</p><img src="https://image.nickxu.me/202307030014383.png" alt="image-20230703上午121444324"  /><blockquote><p>群友消息太多了，我就截了几个 iyear 的</p></blockquote><p>然后我就去看有什么项目</p><p>看的第一感觉就是：<code>我不配啊！</code></p><p>我去我怎么参加的了这些项目，我真的配不上</p><p>更关键的是，Golang 是真的不多</p><p>我在 Golang 的项目里兜兜转转，看见了一个 Keploy  ，是做 API 测试工具的</p><p><img src="https://image.nickxu.me/202307022329223.png" alt="image-20230702下午112950192"></p><p>看了看项目，只感觉这个重构命令行工具的我可能会做</p><p>当然，我肯定知道这东西肯定一堆人来抢，我只能说先看看，先研究一下</p><img src="https://image.nickxu.me/202307022334237.png" alt="image-20230702下午113446200" style="zoom:50%;" /><blockquote><p>哈哈，你可以看看现在有几个 star，人真的多</p></blockquote><p><img src="https://image.nickxu.me/202307030010605.png" alt="image-20230703上午121003545"></p><p>然后，很快啊，这东西已经寄了</p><p>我只能说阿三真的 nb，GSoC 怎么这么多阿三</p><p>之后我就真的找不到我有能力参加的项目了~~，游戏也不能一上来就是最终 BOSS 吧，我想（~~</p><p>最终的结果是可以预见的，GSoC 2023 我还是没下得去手</p><h2 id="克服恐惧">克服恐惧</h2><p>后面很长一段时间，我都是不相信自己的</p><p>我真的不见得能有能力参加这种活动，真的这样</p><p>即使后面 iyear 专门讲了一节例会，举了好几个例子，我心里也没什么信心</p><p><img src="https://image.nickxu.me/202307030018312.png" alt="image-20230703上午121828262"></p><blockquote><p>例会上的 md，iyear 讲了一个多小时，后面的内容有点隐私就不放出来了</p></blockquote><p>直到那句话，让我振聋发聩</p><p><img src="https://image.nickxu.me/202307022356272.png" alt="image-20230702下午115636218"></p><blockquote><p>要有阿三的自信😎</p></blockquote><p>对哇，为什么印度阿三都能在 GSoC 上主动出击，我一个中国人怎么能一点信心都没有</p><p>印度老哥技术上应该也会太强，但是他们自信哇，你至少要相信自己能做到，这样才有希望</p><p>然后 OSPP 毕竟我们有主场优势，基本都是国人，我下定决心，不管中没中，至少至少，我要投个项目吧</p><h2 id="OSPP-开始">OSPP 开始</h2><p>很快 OSPP 就要开始了，已经到了社区开始上线的日子</p><p>但是我记得前几天是没什么动静的，后面开始慢慢放出社区，是一点一点放的</p><p>所以我每天起来第一件事就是去 <a href="https://summer-ospp.ac.cn/org/orglist">https://summer-ospp.ac.cn/org/orglist</a> 上看今天又多了什么社区，有什么项目</p><p>当然了，我很早也把去年的项目都看了一遍</p><p>讲真每天都去看看是很有效的，就像高中的时候背文言文一样，看上去很长很恐怖，但是同学告诉我，只要每节课一下课就飞快地读一遍，很快就熟了</p><p>的确如此，过去我看着这些项目都很不自信</p><p>但是现在，我能很平静地说：</p><p>“也没什么，这里的每个项目我都看过”</p><h2 id="感谢-yeebing-！">感谢 yeebing ！</h2><p>看了很久的项目，但是感觉还是没找到比较适合我的</p><p>其他领域就不说了，我目前比较能拿得出手感觉只有 Golang 后端</p><p>而逛了一圈，感觉对前端真的很友好，在看去年项目的时候居然有不少官网设计和文档优化的</p><div class="gallery">    <div class="fj-gallery  data" data-rowHeight="220" data-limit="10">    <span class="gallery-data">[{"url":"https://image.nickxu.me/202307041603566.png","alt":"1c508ec5077eff3f9b366938e43a1cba"},{"url":"https://image.nickxu.me/202307041607998.png","alt":"334dcddce604b196fea8bd4be4126ac1"},{"url":"https://image.nickxu.me/202307041603661.png","alt":"6f4f10146ff20cb15aa25bc522584e3e"}]</span>    </div>    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>    </div><p>相比之下，Golang 的低难度项目很稀缺， 我看着基本都是云原生的，毕竟 Golang 目前最大的用途基本也就是写云原生的基础设施</p><p>但是云原生我是真的不会哇，kubernetes 我都不是很熟，那些项目我也看不太懂</p><p>只能说再看看会有什么项目了</p><p>然后突然有一天，yeebing 突然找到我</p><img src="https://image.nickxu.me/202307041617977.png" alt="image-20230704下午41722930" style="zoom:50%;" /><blockquote><p>还得是杭助的人脉哈哈哈</p></blockquote><p>看了一眼，后端我的确没问题，但是有个问题就是我不会前端哇</p><p>但是转念一想，来 OSPP 就是要学新东西的，而且杭助这么多前端的佬，我速成一波前端应该也不是不可以</p><p>毕竟我目前也找不到比这个更好的项目了，于是我开始冲这个项目</p><h2 id="开始迭代">开始迭代</h2><p>yeebing 帮我占了个沙发，我翻了翻文档，大概知道是个什么东西之后，我就开始冲了</p><p><img src="https://image.nickxu.me/202307041637634.png" alt="image-20230704下午43727576"></p><p>前期是很关键的，只要你能在 issue 里跟导师来回说一堆话，那别人也就能知道这个项目已经有人了，至少能让一部分人知难而退</p><p>之后就开始迭代了，我们在 issue 下交流，之后是深入的思考，感觉差不多了就开始搓 Proposal 发邮件</p><p>导师给我纠正了一些方向上的问题，于是我调研后重新思考设计</p><p>没想到出到第二版跟我说可以去提交了（</p><p><img src="https://image.nickxu.me/202307041645144.png" alt="image-20230704下午44538074"></p><p>然后突然有一天晚上，导师突然来加我好友</p><p><img src="https://image.nickxu.me/202307041708059.png" alt="d1a99451107484673017aae5d322e672_0"></p><p>才想起来我之前翻文档的时候顺手加了个用户群（感觉有点猝不及防</p><p>然后我们后面就开始聊，根据我的简历给我提了好多建议</p><p><img src="https://image.nickxu.me/202307041704047.png" alt="image-20230704下午50425978"></p><blockquote><p>对比其他群友，我感觉我这真的是个神仙导师（</p></blockquote><h2 id="OSPP-线下会">OSPP 线下会</h2><p><img src="https://image.nickxu.me/202307041719852.webp" alt="图片"></p><blockquote><p>线下会杭州站，可以看 <a href="https://www.bilibili.com/read/cv23843608">cv23843608</a> ，三咲智子居然也去了</p></blockquote><p>OSPP 当时也在全国各地开线下会，在杭州也有</p><p>我的确报名了，也进了群，杭助也有不少人去了</p><p>但可惜的是我那天阳了在隔离，想着阳了就别出去祸害别人了，而且精力也不是很好，就没去</p><img src="https://image.nickxu.me/202307041723785.png" alt="image-20230704下午52338719" style="zoom:50%;" /><p>再贴点找到的当时的照片吧哈哈哈</p><div class="gallery">    <div class="fj-gallery  data" data-rowHeight="220" data-limit="10">    <span class="gallery-data">[{"url":"https://image.nickxu.me/202307041731134.png","alt":"image-20230704下午53115061"},{"url":"https://image.nickxu.me/202307041733694.png","alt":"image-20230704下午53327596"},{"url":"https://image.nickxu.me/202307041733568.png","alt":"image-20230704下午53305500"},{"url":"https://image.nickxu.me/202307041731500.png","alt":"image-20230704下午53132438"},{"url":"https://image.nickxu.me/202307041731435.png","alt":"image-20230704下午53150368"},{"url":"https://image.nickxu.me/202307041732513.png","alt":"image-20230704下午53245428"}]</span>    </div>    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>    </div><h2 id="大受震撼">大受震撼</h2><p>日子一天天地过去，我还在为好像还没有人和我抢项目而沾沾自喜</p><p>突然有一天收到了 GitHub 的邮件，一开始我以为是哪个社团项目谁 PR 了，结果一看居然有人来抢我的 OSPP 项目了 ？！</p><p><img src="https://image.nickxu.me/202307041750442.png" alt="image-20230704下午55052373"></p><blockquote><p>卧槽我直接大受震撼</p></blockquote><p>然后我一看，卧槽，酒吧舞✌️，ACM✌️，然后一看博客，大一华为实习</p><p>卧槽这是什么神仙</p><p><s>真的是人与人的差距比人与狗的差距都大（</s></p><p>然后 iyear 就来安慰我，还得是 iyear 够自信</p><p><img src="https://image.nickxu.me/202307041823065.png" alt="image-20230704下午62305997"></p><p>其实还不算太慌，毕竟都最后几天了，导师应该也不会再换人了</p><h2 id="预知结果">预知结果</h2><p>提交截止了，后面的就是等结果</p><p>之后突然有一天</p><p><img src="https://image.nickxu.me/202307041831306.png" alt="image-20230704下午63127228"></p><p>于是我就去看</p><p><img src="https://image.nickxu.me/202307041853830.png" alt="6b3cc9b5bf5949f6cba2901034ba9cda"></p><blockquote><p>还是羡慕 daidr 的 GSoC 哈哈哈</p></blockquote><p>我感觉基本算是稳了，反正期末考了也干不了什么了，那就等通知吧</p><h2 id="正式通知-杭助喜报">正式通知 &amp; 杭助喜报</h2><p>6 月 26 日，结果下来了，我也收到了邮件</p><p><img src="https://image.nickxu.me/202307042134321.png" alt="86e87455433bb7b1b9f5e14e3f38f591_0"></p><blockquote><p>终于等到你！</p></blockquote><p>然后在杭助里统计了一下，感觉真的挺开心的，杭助的技术氛围真的不错</p><img src="https://image.nickxu.me/202307042135884.png" alt="image-20230704下午93502834" style="zoom: 50%;" /><blockquote><p>也希望能吸引更多人加入杭电助手技术部的大家庭</p></blockquote><h2 id="继续开发">继续开发</h2><p><img src="https://image.nickxu.me/202307042152919.png" alt="image-20230704下午95240872"></p><p>中选之后，导师拉着我参加了内部的会议，对一部分内容提出了修改意见</p><p>毕竟我对这个插件市场的定位没有 MOSN 的 maintainers 那么深入，而且我感觉真的挺合理的，想的问题都考虑的非常周到</p><p>主要内容讨论完之后，说开的这么好居然没有录下来（</p><p>然后又聊到我多大了，我说我 03 年的，就感觉挺年轻吧，一旁有人说现在连研究生都是 00 后了，哈哈哈</p><p>我就感觉，哇，我感觉我就是开源的新鲜血液，我的确能「为其他人做一些，有意义的事情」</p><hr><h1 id="经验总结">经验总结</h1><p>一直拖拖拖，感觉写的有点虎头蛇尾了，下面就分享几点中选的经验吧</p><h2 id="滚雪球-现在就开始">滚雪球 现在就开始</h2><p>别一开始就说做不到，没有人是一口吃成胖子的，都是一个成长的过程</p><p>其实很多事情都是「你之前做了一个什么事」，一步步进步的，就像滚一个雪球的过程</p><p>比如说我</p><ul><li>如果不是初中对计算机感兴趣，开始折腾计算机，高中也不会去 Noip，也不会去玩树莓派</li><li>如果高中没有一定的积累，大一也没那么容易进杭电助手，也不会在杭助融入的那么快</li><li>如果没进杭电助手， 也就没有后面的事情了，我也没法在字节青训营取得那样的成绩，更不会听说 OSPP 这种东西</li></ul><p>所以说不管那么多，先让自己滚起来再说，等于说是有一个正向的循环，能让你不断的进步</p><p>而且是越早越好，别明天，现在就开始，像 iyear，初中就在打 oi，比我早了一个阶段，所以大一就参加了 OSPP，今年更是去了 LFX Mentorship</p><h2 id="要有阿三的自信">要有阿三的自信</h2><img src="https://image.nickxu.me/202307042244857.png" alt="image-20230704下午104441787" style="zoom:67%;" /><blockquote><p>另外一个就是要记住 iyear 的话：「要有阿三的自信」</p></blockquote><p>讲的就是一个自信好吧，<strong>你不自信，你就已经输了</strong></p><h2 id="双向选择">双向选择</h2><p>讲真现在有些开源社区也挺离谱的，下面的开源乱象也会说</p><p>简单的说就是要记住双向选择，就像面试企业一样，不仅是社区选择你，也是你选择社区</p><p>不能白白被别人 PUA，不能被白白养鱼</p><h2 id="主动出击-快速占领-前期很重要">主动出击 快速占领 前期很重要</h2><p>如果你已经确定看中了一个项目，那就尽快出击，去交流讨论，同时最好让别人也看见</p><p>一般来说，前期是最重要的，如果别人已经先你一步和导师聊了很多，那你中选的几率也不会太高</p><p>也就是说别想着自己一直闭门造车，然后在提交截止那天交上去就完了，如果导师有另一个跟他讨论很久的学生，你觉得他会选哪个</p><h2 id="让别人能了解自己">让别人能了解自己</h2><p>要维护自己的个人形象，像 GitHub 头像都没换的，主页一点进去啥都没有的，怎么让别人相信你有能力参与开发</p><p>要给导师一些渠道来了解自己，比如能让导师知道你之前有什么什么项目经历，能力强的话之前在哪些开源社区混过</p><p>又或者是和我一样有个博客可以让别人看，这也是让导师了解你的很好的方法</p><p>总之一句话，你已经看上了别人，那也要让别人看的上你，为此你就需要做一些事情让自己显得专业</p><p>就像我这次还特地折腾了个自定义域名的邮箱，以后面试工作也是一样的，别人用个谷歌邮箱去面试，你简历上写个 QQ 邮箱，你觉得呢？</p><p>即使你说 gmail 没 QQ 方便，还要翻墙，其实你可以设置自动转发，我就是这么弄的</p><h2 id="统一命名空间-别撞车">统一命名空间 别撞车</h2><p>和社团的其他伙伴一起的时候要注意别撞车了，不然就会是很尴尬的局面🥲</p><p><img src="https://image.nickxu.me/202307050022196.png" alt="image-20230705上午122240143"></p><p>像这次就碰见了不少撞车的情况</p><p><img src="https://image.nickxu.me/202307050030677.png" alt="image-20230705上午123051615"></p><h2 id="不利形势-及时放弃">不利形势 及时放弃</h2><p>如果发现自己希望不大（比如导师好像根本不想理你、委婉拒绝，或者已经有谈的很好的人了），就应该及时放弃，转移阵地</p><p>如果你精力够的话还可以尝试多开，叶师傅这次就是这么干的</p><h2 id="一点点运气">一点点运气</h2><p>导师真的得看运气我感觉</p><p>讲真我这真的是神仙导师，每次发信息基本都是秒回，我真的太感动了（</p><p><img src="https://image.nickxu.me/202307050024196.png" alt="image-20230705上午122453142"></p><h2 id="其他因素">其他因素</h2><p>还要很多其他因素，下面的图你就可以看得出来</p><p><img src="https://image.nickxu.me/202307052132207.png" alt="image-20230705下午93257160"></p><blockquote><p>一个是被骑士，另一个是社区排名不够，骑士就不说了，下面说一下社区排名</p></blockquote><p>GSoC 和 OSPP 不同，GSoC 还有一个社区的排名</p><p>也就是导师选中你之后，还没有完全结束</p><p>一般来说 GSoC 会给每个社区分配项目名额，当你和导师结对之后，要一起参与社区内的排名，只有在名额内的才能算真正的中选</p><p>举个例子，你在 GSoC 上看中了一个社区，里面有 10 个项目，你申请了一个，并且导师也选你了</p><p>但是 GSoC 给你的社区只有 5 个名额，之后 10 个项目一起参与排名，但是你的项目不幸排在了第 6 名，于是很可惜还是寄了</p><p>社区排名会看项目对社区短期内效益大不大，还有你和社区的关系，关系好的直接安排了</p><p>还有看导师好不好，导师可能会跟你明说排名估计难，让你换项目，不会浪费你太多时间</p><p>这方面还是有些主观能动性的</p><p>今年的 OSPP 也出现了类似的情况</p><img src="https://image.nickxu.me/202307052109365.jpeg" alt="8e7fea2cafb89ce17eba2af1296378e5" style="zoom:50%;" /><p>具体来说就是之前都是社区报几个主办方都出资支持，但是这一届会给社区名额，超出名额的项目资金必须社区自己解决</p><p>然后就出现了一些尴尬的情况，iyear 今年就是这么寄的</p><p><img src="https://image.nickxu.me/202307052119319.png" alt="9d385ce046b1665e3fb931dd5bd35801"></p><blockquote><p>导师直接改名有点草（</p></blockquote><p>就是社区一开始不清楚这个规则，报了很多项目，然后后来突然发现只给了两个名额，其他的要自己花钱</p><p>于是很多项目就被砍了，你可以看见这个社区只有两个学生最终中选</p><hr><h1 id="未来展望">未来展望</h1><p><s>明天早八，好困，明天写</s></p><p>简单写一下吧</p><h2 id="开源乱象">开源乱象</h2><p>有人一直认为国内的开源是个笑话，我感觉也不是完全没有道理</p><p>这届 OSPP 出现了一些抽象事件，我在官方群里也感受到了</p><p>具体可以看「鸟」写的博客，<a href="https://blog.aflybird.cn/2023/06/please-stop-fucking-open-source-activities-in-china/">请还国内开源活动一片净土</a> （注意看评论区，有事情不好明话说</p><p>鉴于目前国内学术圈的某些操作，我感觉未来出现「开源刘禅」也不是不可能</p><p>另外可以看看另一位杭助成员的博客：<a href="https://marlene.top/index.php/develop/85.html">开源之旅——OSPP</a></p><h2 id="要把人留下来">要把人留下来</h2><p>还记得我开头说的，开源活动的目的是吸引更多的人（特别是学生）参与开源</p><p>但是现在就感觉，很多人都把利益看的太重了</p><p>结果就是，我来了，我完成了项目，我走了，人没留下来</p><p>讲真这最后还是没把社区做起来，我只能说，我这次做的这个项目，我以后肯定会一直维护迭代的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.nickxu.me/202306301521080.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;6月26日下午3点，OSPP2023 中选结果正式发布，&lt;a href=&quot;https://summer-ospp.ac.cn/news/data&quot;&gt;全球共有 1486 人成功申请，最终中选人数为 504 人&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;鄙人非常荣幸地成为了这 504 个幸运儿的一份子，特撰此文，记录 &lt;code&gt;我与 OSPP 的故事 —— 从听闻到中选&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当然，我也希望这篇博客能够吸引更多人参与开源，为开源项目做出自己的贡献&lt;/p&gt;
&lt;/blockquote&gt;
&lt;details class=&quot;toggle&quot; &gt;&lt;summary class=&quot;toggle-button&quot; style=&quot;&quot;&gt;给「杭电助手」打点小广告&lt;/summary&gt;&lt;div class=&quot;toggle-content&quot;&gt;&lt;p&gt;&lt;img src=&quot;https://image.nickxu.me/202306301616858.j</summary>
      
    
    
    
    <category term="OSPP" scheme="https://nickxu.me/categories/OSPP/"/>
    
    
    <category term="OSPP" scheme="https://nickxu.me/tags/OSPP/"/>
    
  </entry>
  
  <entry>
    <title>『算法拾遗』重学主流排序算法</title>
    <link href="https://nickxu.me/posts/sorting-algorithm.html"/>
    <id>https://nickxu.me/posts/sorting-algorithm.html</id>
    <published>2023-06-13T04:21:54.000Z</published>
    <updated>2023-07-21T11:18:11.216Z</updated>
    
    <content type="html"><![CDATA[<details class="toggle" ><summary class="toggle-button" style="">衡量排序算法的好坏</summary><div class="toggle-content"><p>时间复杂度</p><ul><li>包含最好情况、最坏情况和平均情况</li><li>数据有序度不同的影响</li></ul><p>空间复杂度</p><ul><li>是否是原地排序</li></ul><p>稳定性</p><ul><li>排序后，相同元素之间的顺序是否会改变</li></ul></div></details><h1 id="O-n-2">O( n^2 )</h1><h2 id="冒泡排序（Bubble-Sort）">冒泡排序（Bubble Sort）</h2><blockquote><p>依次比较相邻的元素，如果顺序错误，则交换它们。每轮排序将最大（或最小）的元素“冒泡”到正确的位置</p><p>简单易懂，但效率较低，不适用于大规模数据排序</p></blockquote><ul><li><p>过程</p><ol><li>初始化待排序数组，设为 <code>arr</code> ，数组长度为 <code>n</code></li><li>外层循环：重复 <code>n-1</code> 次（即 <code>i</code> 从 <code>0</code> 到 <code>n-2</code> ） <mark class="hl-label green">思考：为什么外层是n-1次</mark> <ol><li>内层循环：重复 <code>n-i-1</code> 次（即 <code>j</code> 从 <code>0</code> 到 <code>n-i-2</code> ）  <mark class="hl-label green">思考：为什么内层是n-i-1次</mark> <ol><li>比较 <code>arr[j]</code> 和 <code>arr[j+1]</code> ，如果 <code>arr[j]</code> 大于 <code>arr[j+1]</code> ，执行下一步，否则继续内层循环</li><li>交换 <code>arr[j]</code> 和 <code>arr[j+1]</code> 的位置</li></ol></li><li>判断是否在本轮内层循环中进行了交换操作：<ul><li>如果没有进行交换，说明数组已经有序，提前结束排序</li></ul></li></ol></li><li>冒泡排序结束，数组 <code>arr</code> 已经按升序排列</li></ol></li><li><p>性质</p><ol><li>在排序没有完成之前，小的数会逐步往前移，大的数会逐步往后移动</li><li>每轮排序至少会让一个最大元素放置在正确位置，重复 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 次，就完成了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个元素的排序</li><li>是稳定的排序算法</li><li>空间复杂度：冒泡排序的空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，它在原地进行排序，不需要额外的内存空间。</li><li>最优情况：冒泡排序的最优情况是输入数组已经有序。在这种情况下，只需要进行一次遍历，没有元素交换，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>最坏情况：冒泡排序的最坏情况是输入数组完全逆序。在这种情况下，需要进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 轮遍历，每轮遍历需要进行元素比较和交换，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>平均情况：冒泡排序的平均时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。因为每一对元素在排序过程中都有可能发生交换，所以平均时间复杂度较高</li></ol></li><li><p>代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ &#123; <span class="comment">// 一共要排序 n-1 轮（因为每 1 轮至少能让 1 个元素放在正确的位置）</span></span><br><span class="line">        <span class="comment">// 标记是否进行了交换，如果在某轮遍历中没有发生交换，则说明数组已经有序，可以提前结束排序。</span></span><br><span class="line">        swapped := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++ &#123; <span class="comment">// 每轮比较 n-i-1 次（因为前面 i 轮已经让 i 个元素有序了）</span></span><br><span class="line">            <span class="comment">// 比较相邻的元素，如果顺序错误则交换它们</span></span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">                swapped = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在某轮遍历中没有发生交换，则说明数组已经有序，可以提前结束排序。</span></span><br><span class="line">        <span class="keyword">if</span> !swapped &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 待排序的整数数组</span></span><br><span class="line">    arr := []<span class="type">int</span>&#123;<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;原始数组：&quot;</span>, arr)</span><br><span class="line">    bubbleSort(arr)</span><br><span class="line">    fmt.Println(<span class="string">&quot;排序后数组：&quot;</span>, arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><details class="toggle" ><summary class="toggle-button" style="">冒泡排序的例子（GPT）</summary><div class="toggle-content"><p>好的，让我们来看一个冒泡排序的例子。假设我们要对一个整数数组进行升序排序，下面是冒泡排序的步骤：</p><p>初始数组：[5, 2, 9, 1, 5, 6]</p><p>第一轮冒泡：</p><ul><li>比较 5 和 2：需要交换位置，数组变为 [2, 5, 9, 1, 5, 6]</li><li>比较 5 和 9：位置正确，不需要交换，数组保持不变 [2, 5, 9, 1, 5, 6]</li><li>比较 9 和 1：需要交换位置，数组变为 [2, 5, 1, 9, 5, 6]</li><li>比较 9 和 5：需要交换位置，数组变为 [2, 5, 1, 5, 9, 6]</li><li>比较 9 和 6：需要交换位置，数组变为 [2, 5, 1, 5, 6, 9]</li></ul><p>第一轮冒泡结束后，最大的元素 9 已经被“冒泡”到正确的位置末尾。</p><p>第二轮冒泡：</p><ul><li>比较 2 和 5：位置正确，不需要交换，数组保持不变 [2, 5, 1, 5, 6, 9]</li><li>比较 5 和 1：需要交换位置，数组变为 [2, 1, 5, 5, 6, 9]</li><li>比较 5 和 5：位置正确，不需要交换，数组保持不变 [2, 1, 5, 5, 6, 9]</li><li>比较 5 和 6：位置正确，不需要交换，数组保持不变 [2, 1, 5, 5, 6, 9]</li></ul><p>第二轮冒泡结束后，第二大的元素 5 也已经被“冒泡”到正确的位置。</p><p>第三轮冒泡：</p><ul><li>比较 2 和 1：需要交换位置，数组变为 [1, 2, 5, 5, 6, 9]</li><li>比较 2 和 5：位置正确，不需要交换，数组保持不变 [1, 2, 5, 5, 6, 9]</li><li>比较 5 和 5：位置正确，不需要交换，数组保持不变 [1, 2, 5, 5, 6, 9]</li></ul><p>第三轮冒泡结束后，第三大的元素 2 也已经被“冒泡”到正确的位置。</p><p>第四轮冒泡：</p><ul><li>比较 1 和 2：位置正确，不需要交换，数组保持不变 [1, 2, 5, 5, 6, 9]</li><li>比较 2 和 5：位置正确，不需要交换，数组保持不变 [1, 2, 5, 5, 6, 9]</li></ul><p>第四轮冒泡结束后，第四大的元素 1 也已经被“冒泡”到正确的位置。</p><p>最后一轮冒泡：</p><ul><li>比较 1 和 2：位置正确，不需要交换，数组保持不变 [1, 2, 5, 5, 6, 9]</li></ul><p>最后一轮冒泡结束后，第五大的元素 1 也已经被“冒泡”到正确的位置。</p><p>现在数组已经完全有序：[1, 2, 5, 5, 6, 9]。整个冒泡排序过程完成。</p><p>冒泡排序的基本思想是通过相邻元素的比较和交换来逐步“冒泡”最大元素至正确位置。这个过程持续执行直至所有元素都排好序。请注意，冒泡排序可能需要多次遍历数组来确保所有元素都在正确的位置。虽然冒泡排序简单易懂，但它的效率较低，不适用于大规模数据的排序。</p></div></details></li><li><details class="toggle" ><summary class="toggle-button" style="">可能会问的问题（GPT）</summary><div class="toggle-content"><p>在面试中，关于冒泡排序，面试官可能会问您以下几类问题：</p><ol><li><p>冒泡排序的原理和思想是什么？</p><ul><li>回答要点：冒泡排序是一种简单的排序算法，它通过相邻元素的比较和交换来逐步“冒泡”最大元素至正确的位置。它的核心思想是重复遍历数组，每次遍历将当前最大元素放到未排序部分的末尾。</li></ul></li><li><p>冒泡排序的时间复杂度是多少？</p><ul><li>回答要点：冒泡排序的平均时间复杂度为O(n^2)，最好情况下（数组已经有序）为O(n)，最坏情况下（数组完全逆序）为O(n^2)。平均情况下，需要进行n-1轮外层循环，每轮循环需要比较n-i-1次，共进行(n-1) + (n-2) + … + 1 = n*(n-1)/2次比较。</li></ul></li><li><p>冒泡排序是稳定排序算法吗？</p><ul><li>回答要点：是的，冒泡排序是一种稳定的排序算法。在冒泡排序的过程中，只有在相邻元素需要交换时才改变相等元素的顺序，所以相等元素的相对位置在排序前后保持不变。</li></ul></li><li><p>如何优化冒泡排序的时间复杂度？</p><ul><li>回答要点：可以使用一个标志位来判断在某一轮外层循环中是否进行了交换操作，如果没有交换，说明数组已经有序，可以提前结束排序，从而优化最好情况下的时间复杂度为O(n)。</li></ul></li><li><p>冒泡排序和其他排序算法的比较？</p><ul><li>回答要点：冒泡排序是一种简单易懂的排序算法，但其时间复杂度较高，不适合大规模数据的排序。相比之下，快速排序、归并排序和堆排序等排序算法在平均情况下有更高效的时间复杂度，并且更常用于实际应用。</li></ul></li><li><p>你能实现冒泡排序的代码吗？</p><ul><li>回答要点：您需要在面试中展示您对冒泡排序的理解，然后根据编程语言要求编写冒泡排序的代码实现。</li></ul></li></ol><p>在面试过程中，除了理解冒泡排序的原理和性质外，您还应该能够清晰地表达答案，展示您对算法的理解和编程能力。如果需要，可以使用示例或画图来帮助说明。同时，与面试官保持良好的沟通，如果有任何不清楚的地方，随时请教面试官。</p></div></details></li></ul><h2 id="插入排序（Insertion-Sort）">插入排序（Insertion Sort）</h2><blockquote><p>将未排序的元素逐个插入到已排序部分的正确位置，形成有序序列。</p><p>适用于小型数据集和基本有序的数据，效率较冒泡排序稍高。<mark class="hl-label green">思考：时间复杂度相同，为什么说插入比冒泡效率高</mark> </p></blockquote><h2 id="选择排序">选择排序</h2><h1 id="O-n-logn">O( n*logn )</h1><h2 id="归并排序">归并排序</h2><h2 id="快速排序">快速排序</h2><h2 id="堆排序">堆排序</h2><h1 id="O-n">O( n )</h1><h2 id="计数排序">计数排序</h2><h2 id="基数排序">基数排序</h2><h2 id="桶排序">桶排序</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;details class=&quot;toggle&quot; &gt;&lt;summary class=&quot;toggle-button&quot; style=&quot;&quot;&gt;衡量排序算法的好坏&lt;/summary&gt;&lt;div class=&quot;toggle-content&quot;&gt;&lt;p&gt;时间复杂度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包含最好情况、最坏情况和平均情况&lt;/li&gt;
&lt;li&gt;数据有序度不同的影响&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;空间复杂度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否是原地排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;稳定性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排序后，相同元素之间的顺序是否会改变&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/details&gt;
&lt;h1 id=&quot;O-n-2&quot;&gt;O( n^2 )&lt;/h1&gt;
&lt;h2 id=&quot;冒泡排序（Bubble-Sort）&quot;&gt;冒泡排序（Bubble Sort）&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;依次比较相邻的元素，如果顺序错误，则交换它们。每轮排序将最大（或最小）的元素“冒泡”到正确的位置&lt;/p&gt;
&lt;p&gt;简单易懂，但效率较低，不适用于大规模数据排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;过程&lt;/p</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://nickxu.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法拾遗" scheme="https://nickxu.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97/"/>
    
    <category term="排序" scheme="https://nickxu.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
</feed>
