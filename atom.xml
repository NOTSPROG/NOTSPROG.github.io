<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NX の 博客</title>
  <icon>https://nickxu.me/static/favicon.jpg</icon>
  
  <link href="https://nickxu.me/atom.xml" rel="self"/>
  
  <link href="https://nickxu.me/"/>
  <updated>2023-10-26T04:26:57.354Z</updated>
  <id>https://nickxu.me/</id>
  
  <author>
    <name>Nick Xu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>『代码随想录』DAY1|数组：704.二分查找 27.移除元素</title>
    <link href="https://nickxu.me/post/programmercarl-day1.html"/>
    <id>https://nickxu.me/post/programmercarl-day1.html</id>
    <published>2023-10-25T15:35:00.000Z</published>
    <updated>2023-10-26T04:26:57.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="704-二分查找"><a href="https://leetcode.cn/problems/binary-search/">704.二分查找</a></h1><details class="toggle" ><summary class="toggle-button" style="">相关链接</summary><div class="toggle-content"><ul><li><a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#_704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">代码随想录</a></li><li><a href="https://www.bilibili.com/video/BV1fA4y1o715/?vd_source=e2613baf768b2432fcb2b9edd79c0c68">视频讲解</a></li></ul></div></details><div class="tabs" id="样例"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#样例-1">左闭右闭区间</button></li><li class="tab"><button type="button" data-href="#样例-2">左边右开区间</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    left, right := <span class="number">0</span>, n<span class="number">-1</span> <span class="comment">// 左闭右闭</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123; <span class="comment">// [1,1] 可以是一个合理区间，所以要有等号</span></span><br><span class="line">        mid := (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span> <span class="comment">// 这里要减一，区间是左闭右闭，不应该再包括 mid</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span> <span class="comment">// 这里要加一，区间是左闭右闭，不应该再包括 mid</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    left, right := <span class="number">0</span>, n <span class="comment">// 左闭右开</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123; <span class="comment">// [1,1) 不是一个合理区间，所以不能有等号</span></span><br><span class="line">        mid := (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            right = mid <span class="comment">// 右开</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span> <span class="comment">// 左闭</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="边界条件注意">边界条件注意</h2><p>主流的就是两种写法，左闭右闭和左闭右开，如果你选择了一种写法，就应该全程保持这一种写法</p><ul><li><p>左闭右闭</p><p>起始区间为 <code>[0,n - 1]</code> ，继续循环的条件是区间合法，也就是 <code>left &lt;= right</code></p><p>更新左右边界值时，由于 <code>mid</code> 已经被排除，所以更新为 <code>mid + 1</code> 与 <code>mid - 1</code></p></li><li><p>左闭右开</p><p>起始区间为 <code>[0,n]</code> ，因为 <code>[1,1)</code> 不是一个合法的区间（左右不能相等），所以 <code>left &lt; right</code></p><p>更新左右边界值时，因为左闭所以 <code>mid + 1</code> ，而右开所以 <code>mid</code> （已经排除了但是右边界是开的）</p></li></ul><h2 id="整数溢出问题">整数溢出问题</h2><p>计算 <code>mid</code> 通常使用 <code>(left + right) / 2</code></p><p>但是如果 <code>left</code> 和 <code>right</code> 很大，就可能溢出，可以使用 <code>left + (right - left) / 2</code></p><h1 id="27-移除元素"><a href="https://leetcode.cn/problems/remove-element/">27.移除元素</a></h1><details class="toggle" ><summary class="toggle-button" style="">相关链接</summary><div class="toggle-content"><ul><li><a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html">代码随想录</a></li><li><a href="https://www.bilibili.com/video/BV12A4y1Z7LP/">视频讲解</a></li></ul></div></details><p>经典双指针</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="type">int</span>, val <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right &lt; n &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[right] != val &#123;</span><br><span class="line">            nums[left] = nums[right]</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        right++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34.在排序数组中查找元素的第一个和最后一个位置</a></h1><p>解法很多，我选择分别查找第一个和最后一个位置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;findFirst(nums, target), findLast(nums, target)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findFirst</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    left, right := <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> nums[left] == target &#123;</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := (left + right) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target &amp;&amp; mid+<span class="number">1</span> &lt; n &amp;&amp; nums[mid+<span class="number">1</span>] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt;= target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLast</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    left, right := <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> nums[right] == target &#123;</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := (left + right) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target &amp;&amp; mid<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[mid<span class="number">-1</span>] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt;= target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了眼题解，发现另一种写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;findFirst(nums, target), findLast(nums, target)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findFirst</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    left, right := <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">    ans := <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := (left + right) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">            ans = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLast</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    left, right := <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">    ans := <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := (left + right) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">            ans = mid</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="35-搜索插入位置"><a href="https://leetcode.cn/problems/search-insert-position/">35.搜索插入位置</a></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    left, right := <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := (left + right) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;704-二分查找&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/binary-search/&quot;&gt;704.二分查找&lt;/a&gt;&lt;/h1&gt;
&lt;details class=&quot;toggle&quot; &gt;&lt;summary class=&quot;toggle-button&quot; style=&quot;&quot;&gt;相关链接&lt;/summary&gt;&lt;div class=&quot;toggle-content&quot;&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#_704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE&quot;&gt;代码随想录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1fA4y1o715/?vd_source=e2613baf768b2432fcb2b9edd79c0c68&quot;&gt;视频讲解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/details&gt;
&lt;div class=&quot;ta</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『OSPP2023』我与 OSPP 的故事 —— 项目经验分享</title>
    <link href="https://nickxu.me/post/my-story-with-OSPP-project-experience-sharing.html"/>
    <id>https://nickxu.me/post/my-story-with-OSPP-project-experience-sharing.html</id>
    <published>2023-10-15T12:58:06.000Z</published>
    <updated>2023-10-17T14:46:20.368Z</updated>
    
    <content type="html"><![CDATA[<p>书接上文 <a href="https://nickxu.me/2023/06/my-story-with-OSPP-from-hearing-to-being-selected.html">『OSPP2023』我与 OSPP 的故事 —— 从听闻到中选</a> ，本文注重于描写项目开发的经历</p><hr><h1 id="项目基本信息">项目基本信息</h1><ul><li><p>项目名称：为 Envoy Go 扩展建设插件市场</p></li><li><p>项目导师：纪卓志</p></li><li><p>项目描述：</p><p>Envoy 是当前最流行的网络代理之一，Go 扩展是 MOSN 社区为 Envoy 增加的 Go 生态基础，也是 MOSN 社区 MoE 框架的基础。</p><p>受益于Golang生态系统，研发可以轻松在 Envoy 实现插件用于更多的长尾场景，其中很多场景都是通用的。</p><p>本项目是为Envoy Go 扩展构建插件市场。在插件市场中，人们可以在插件市场中分享插件，选用已经存在的插件。通过插件市场，可以让 Envoy、MoE 生态变得更加开放、共享、丰富。</p></li><li><p>项目链接：</p><p><a href="https://summer-ospp.ac.cn/org/prodetail/23f080259?lang=zh&amp;list=pro">https://summer-ospp.ac.cn/org/prodetail/23f080259?lang=zh&amp;list=pro</a></p></li></ul><h1 id="项目迭代经历">项目迭代经历</h1><p>首先我想说这个项目的架构设计经历了多次变动，发现最后做出来的和最开始想的根本不是一个东西（笑）</p><p>一开始 OSPP 上简短的描述并不能让我了解太多，于是我开始翻 MOSN 的文档，并且和导师在 <a href="https://github.com/mosn/envoy-golang-filter-hub/issues/1">Issue</a> 下交流更为详细的需求</p><p>需要实现的是一个插件市场，也就是类似于 <a href="https://marketplace.visualstudio.com/vscode">VSCode Marketplace</a> 或者 <a href="https://github.com/marketplace?type=actions">GitHub Marketplace</a> 的效果，含插件提交、审核、版本管理和二进制构建分发等</p><p><img src="https://image.nickxu.me/202310171527416.png" alt="image-20231017下午32737287"></p><p>我的构想是分为三个部分，GitHub、后端本体还有镜像仓库</p><p>开发者在自己的仓库里开发，如果要上架的话需要移交仓库权限到官方组织里，发布新版本就正常 Release，可以通过 GitHub Actions 通知后端或者由后端来轮询同步</p><p>后端同步仓库情况，维护插件列表与各自的历史版本，同时对每个版本都编译并推送镜像</p><p><img src="https://image.nickxu.me/202310171109975.png" alt="v1.全局设计"></p><p>而对于后端内部，我当初打算搓一套微服务，还画了微服务拆分与架构图（</p><p><img src="https://image.nickxu.me/202310171200663.png" alt="v1.微服务拆分"></p><p><img src="https://image.nickxu.me/202310171109179.png" alt="v1.后端架构"></p><p>然而项目的难点实际上不在于要用什么什么复杂的技术，而在于整体的面向用户的设计，能有一套实际落地可执行的方案</p><p><img src="https://image.nickxu.me/202310172246309.png" alt="image-20231017下午104608175"></p><blockquote><p>感谢导师及时为我指明方向 ❤️</p></blockquote><p>我觉得导师说的的确很有道理，需要交付 MVP 最小价值产品，它指的是产品在满足基本功能需求的前提下，具有的最小的功能集合</p><p>于是，后端肯定是一个简单单体了，并且仓库变成了各自独立开发，目前主要的工作放在细化整个链路上的各个环节</p><p>OK，我们的目标是搭建一个插件市场，插件本体作为 Docker Image 的形式分发，为了达到这个目标，我们需要解决几个子问题</p><ul><li>提交流程该如何设计<ul><li>上架一个插件，用户需要提交哪些内容？</li></ul></li><li>审核流程该如何设计<ul><li>哪些行为需要审核？</li><li>如何审核，自建审核系统，还是依托其他服务？</li></ul></li><li>如何进行版本管理<ul><li>如何上架新版本</li><li>如何下架一个版本</li></ul></li><li>元信息（名称描述分类等）如何存储<ul><li>是全部都存在插件本体中，然后平台后端全量缓存</li><li>还是一部分打包在插件中，另一部分单独在后端保存</li></ul></li><li>插件本体（Docker镜像）该如何构建，存储与分发<ul><li>是我们负责构建存储分发一条龙</li><li>还是交给用户存储在第三方（如 Docker Hub），我们只保存地址？</li></ul></li></ul><p>自己摸索无异于闭门造车，我认为可以参考一下其他平台的做法</p><p>因此，我研究了 8 个类似的或者可以提高参考价值的平台，观察他们是如何解决这些问题的，总结为下表：</p><table><thead><tr><th>平台/市场</th><th>提交流程</th><th>审核机制</th><th>版本管理</th><th>验证官方发布</th><th>元信息保存</th><th>官方文档</th></tr></thead><tbody><tr><td><a href="https://marketplace.visualstudio.com/vscode">Visual Studio Code Marketplace</a></td><td>1. 将插件打包为 <code>.vsix</code> 文件<br>2. 在 <a href="https://azure.microsoft.com/services/devops/">Azure DevOps</a> 使用Microsoft 帐户创建账号并获取 Token<br />3. 使用同一Microsoft 帐户在 <a href="https://marketplace.visualstudio.com/manage">Visual Studio Marketplace</a> 创建发布者 <br />4. 使用 <code>vsce login</code> 与  <code>vsce publish</code> 命令发布插件</td><td>在 Visual Studio Marketplace 上由 Marketplace 团队进行审核</td><td>1. 更新 <code>package.json</code> 的版本号<br>2. 使用 <code>vsce publish</code> 发布新版本<br />3. 无法直接删除特定版本，需要联系官方支持团队进行处理</td><td><a href="https://code.visualstudio.com/api/working-with-extensions/publishing-extension#verify-a-publisher">通过验证是否持有该公司/组织的域名</a></td><td>保存在项目的 <code>package.json</code> 中<br />包含唯一标识、名称、描述、版本号、发布者名称、兼容的 VSC 版本、分类、关键词等</td><td><a href="https://code.visualstudio.com/api/working-with-extensions/publishing-extension">Publishing Extensions | Visual Studio Code Extension API</a></td></tr><tr><td><a href="https://plugins.jetbrains.com/">JetBrains Plugin Repository</a></td><td>1. 在官网上创建账号<br>2. 在创建插件页面上传插件 JAR/ZIP 文件并发布</td><td>由 JetBrains 团队进行审核</td><td>1. 上传新的插件文件<br>2. 在“Versions”选项卡中删除旧版本</td><td>暂无明确的官方验证机制</td><td>大部分保存在项目的 <code>plugin.xml</code> 中，但分类是在发布的页面手动指定</td><td><a href="https://plugins.jetbrains.com/docs/marketplace/uploading-a-new-plugin.html">Uploading a new plugin | JetBrains Marketplace Documentation</a></td></tr><tr><td><a href="https://github.com/marketplace?type=actions">GitHub Actions</a></td><td>1. 在 GitHub 仓库中完成开发，并编写 <code>action.yml</code><br />2. 创建一个 release ，勾上发布到市场，同时填写分类等信息</td><td>无审核机制，发布后即可使用</td><td>1. 创建新的 release， 并勾上发布到市场<br />2. 如要删除发布，取消勾选并保存即可</td><td>仓库属于哪个组织，就是由哪个组织发布的</td><td>大部分保存在项目的 <code>action.yml</code> 中，但分类是在发布的页面手动指定</td><td><a href="https://docs.github.com/zh/actions/creating-actions/publishing-actions-in-github-marketplace">在 GitHub Marketplace 中发布操作 - GitHub 文档</a></td></tr><tr><td><a href="https://chrome.google.com/webstore/category/extensions">Chrome Web Store</a></td><td>1. 在 Chrome 开发者仪表盘创建新项目<br>2. 上传 <code>.zip</code> 文件包含扩展的所有代码<br>3. 填写项目详情，如名称、描述、图标、预览图等<br>4. 提交审核并支付开发者注册费用</td><td>由 Google 团队进行人工审核，内容涵盖性能、安全、隐私等方面</td><td>1. 在开发者仪表盘提交新的 <code>.zip</code> 文件<br>2. 旧版本不会被自动删除，用户可以在商店中查看所有版本</td><td>通过 Google 账户验证</td><td>一部分保存在项目的 <code>manifest.json</code> 中，如名称、版本号、描述等<br />其余信息如图标、预览图、详细描述在开发者仪表盘填写</td><td><a href="https://support.google.com/chrome/a/answer/2714278?hl=zh-Hans">创建和发布自定义 Chrome 应用和扩展程序 - Chrome Enterprise and Education帮助</a></td></tr><tr><td><a href="https://www.apple.com/app-store/">Apple App Store</a></td><td>1. 注册成为 Apple 开发者并支付年费<br>2. 使用 Xcode 开发应用并配置相关信息<br>3. 在 App Store Connect 上创建应用并上传<br>4. 提交审核请求</td><td>由 Apple 团队进行严格审核，包括功能、安全性、隐私、设计等方面</td><td>1. 在 Xcode 中更新版本号和构建号<br>2. 在 App Store Connect 上上传新版本并提交审核<br>3. 旧版本自动下架</td><td>通过 Apple Developer Program 验证身份</td><td>最基础的部分保存在项目的  <code>Info.plist</code> 中，如版本号，构建号，唯一标识，设备上显示的名称<br />另一部分是在 App Store Connect 上，包括在App Store上的应用名称、描述、版本号、类别、预览截图等</td><td><a href="https://developer.apple.com/cn/ios/submit/">将 iOS App 提交至 App Store - Apple Developer</a></td></tr><tr><td><a href="https://cn.wordpress.org/plugins/">WordPress Plugin Repository</a></td><td>1. 在官网上注册账号<br>2. 在 SVN 仓库中添加插件代码<br>3. 使用 Readme Validator 验证 <code>readme.txt</code><br>4. 在官网上提交插件并等待审核</td><td>由 WordPress 团队进行审核，主要关注插件的功能和安全性</td><td>1. 在 SVN 仓库中更新插件和 <code>readme.txt</code> 的版本号<br>2. 在官网上标记新版本的发布<br>3. 旧版本仍然可用</td><td>没有明确的官方验证机制</td><td>保存在项目的 <code>readme.txt</code> 中，包括名称、描述、版本号、作者、标签等</td><td><a href="https://codex.wordpress.org/zh-cn:%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6">zh-cn:开发一个插件 « WordPress Codex</a></td></tr><tr><td><a href="https://hub.docker.com/search?q=&amp;type=extension">Docker Extension</a><br /></td><td>1. 在Docker Hub上注册账号<br>2. 构建好你的扩展镜像，并提交到 Docker Hub<br />3. 选择一种发布方式并等待审核</td><td>可以选择<a href="https://github.com/docker/extensions-submissions/issues/new?assignees=&amp;labels=&amp;template=1_automatic_review.yaml&amp;title=%5BSubmission%5D%3A+">自行发布</a>或者<a href="https://www.docker.com/products/extensions/submissions/">请求官方审核</a></td><td>1. 推送新版本的扩展 Docker Image ，并带有递增的版本标记<br />2. 像管理你的镜像版本一样管理你的扩展版本</td><td><a href="https://docs.docker.com/docker-hub/publish/">加入 Docker Verified Publisher Program</a></td><td>保存在扩展镜像中的 <code>metadata.json</code> 中，当然官方肯定也会缓存一部分</td><td><a href="https://docs.docker.com/desktop/extensions-sdk/extensions/publish/">Publish your extension to the marketplace</a></td></tr><tr><td><a href="https://openai.com/blog/chatgpt-plugins">ChatGPT Plugins</a></td><td>1. 搭建好你的 API 服务<br />2. 以官方的格式创建 JSON/YAML 文件描述你的插件，并保存在域名下</td><td>目前是在官网通过机器人递交表单，然后人工审核</td><td>1. 更新你部署即可<br />2. 不需要维护多版本，访问到的就是你部署的最新版本</td><td>暂无明确的官方验证机制</td><td>大部分保存在你部署的 API 的域名下的 YAML/JSON 文件中，官方服务器仅保存名称，描述及域名等基本信息</td><td><a href="https://platform.openai.com/docs/plugins/getting-started">Getting Started - OpenAI API</a></td></tr></tbody></table><p>依此，我进行以下设计（下面节选自 Proposal）</p><blockquote><ul><li><p>在提交流程这一步来看，我感觉 GitHub Actions 的流程和我们的项目是最贴切的，毕竟我们希望尽可能地利用 GitHub 的基础设施，我认为我们也可以将仓库的一个 Release 关联到插件的一个版本</p></li><li><p>审核机制来看，大部分都是平台自建审核功能，而我也注意到了Docker Extension 的 <a href="https://github.com/docker/extensions-submissions/issues/new?assignees=&amp;labels=&amp;template=1_automatic_review.yaml&amp;title=%5BSubmission%5D%3A+">自行发布</a> 的做法，我认为可以借鉴他的做法：他是一个 Issue Form 对应一个申请，然后，用 tag 标记状态，并由 GitHub Actions 自动检查是否符合条件，这种做法让我想起来社团里有学长加友链也是<a href="https://github.com/aFlyBird0/blog-friends/issues/new/choose">这么</a>搞的， Issue Form 真的可玩性挺高的</p><p>而对于我们来说，可以根据审核的事件类型自定义要不要加人工审核，比如说上架，机器人检查通过之后（这个 repo 的确按照我们规定的格式编写好了插件，可以编译成 Docker Image），可以自动 @ 管理员来人工审核并通过（更改 tag 并关闭 issue），如果有问题则可以在这个 issue 下面继续交流</p></li><li><p>版本管理来看，可以使用与 GitHub Actions 一样的关联 Release 的做法，然后上架或者下架新版本都需要提交审核申请，添加/解除与一个 Release 的关联</p></li><li><p>验证官方发布来看，也可以和 GitHub Actions 一样，仓库在谁手里就是谁发布的，当然还可以以提交审核的方式认证一些别的 tag</p></li><li><p>关于元信息存储，我的看法是与 Visual Studio Code 一样在本体中全量存储（比如在根目录的 <code>metadata.json</code> ） ，然后后端数据库缓存一份，并且始终缓存最新版的信息，这种做法对后端应该最方便，但是对用户来说可能有点麻烦，毕竟你要改描述或者分类这种信息也需要再发布一个新版本</p><p>也就是说，只要插件的仓库中有一个能编译出来镜像的 <code>Dockerfile</code> ，以及一个符合规范的 <code>metadata.yaml</code> ，就够了</p></li><li><p>插件本体存储来看，除去 ChatGPT Plugins 提交的是 API 之外，其他的都是提交并分发一个能离线运行的实体，有些实体是不需要编译的，直接提交源码即可，有些是提交了编译后的产物（如 JAR 包），而在这些案例中大多数都是直接提交编译后的二进制，但是 Docker Extension 有所不同，他是让用户自行将 Docker Image 提交到 Docker Hub ， 然后提交扩展的时候就上交一个链接就好了，如果我们也这样做的话就是把存储成本转嫁给用户，但是从稳定性来看感觉不妥，当然你也可以说 Docker Hub 是他们自家的存储设施，我的结论就是由我们自己负责编译和存储</p></li></ul><p>另外，作为一个市场还可以有评分和评论的功能，但是我感觉没什么必要，评分的话看仓库的 star 应该就可以了，如果对插件有什么看法的话也可以直接去提一个 issue，当然如果要做的话也可以用 <a href="https://giscus.app/zh-CN">giscus</a> 这种解决方法，直接依托 GitHub 的基础设施</p><p>…</p></blockquote><p>而核心的上架流程是这样的</p><blockquote><ol><li><p>在自己的 GitHub 仓库中开发好插件，包含 <code>Dockerfile</code> 与 <code>metadata.yaml</code></p></li><li><p>使用 Issue Form 提交申请，包括自己的仓库地址，同意服务条款</p></li><li><p>使用 GitHub Actions 检查是否接收了服务条款</p></li><li><p>使用 GitHub Actions 找到该项目的 Latest Release ，检查是否合规</p><ol><li><p>元数据是否符合规范、完整</p><ol><li>询问后端是否重名</li><li>是否填写了分类、分类是否在预定义的种类中</li><li>如果定义了 icon、color ，定义是否合规</li></ol></li><li><p>是否能够编译</p><p>使用 <code>docker build</code> 试编译</p></li></ol></li><li><p>自动检测通过，打上 tag ， 等待人工审核</p><p>若未通过，告知原因，并告知需要发布新版本并使用 <code>/validate</code> 重新检测</p></li><li><p>人工审核并更新 tag</p></li><li><p>GitHub Actions 识别到通过的 tag， 向后端上报要关联到的 release 版本</p></li><li><p>上架完成后自动关闭 issue</p></li></ol><p>…</p></blockquote><p>前文所说的 Docker Extension 的 <a href="https://github.com/docker/extensions-submissions/issues/new?assignees=&amp;labels=&amp;template=1_automatic_review.yaml&amp;title=%5BSubmission%5D%3A+">自行发布</a> 我感觉设计的真的很好，最大的特点就是使用 Issue Form 进行申请，然后 GitHub Actions 会自动跑一遍检查，并在 Issue 页面使用对话的形式与用户交互，如果有错误也会指出，并使用 tag 追踪状态</p><p><img src="https://image.nickxu.me/202310171132528.png" alt="image-20231017上午113215497"></p><p><img src="https://image.nickxu.me/202310171131340.png" alt="image-20231017上午113155311"></p><p><img src="https://image.nickxu.me/202310171131472.png" alt="image-20231017上午113133442"></p><p>这一设计最大的好处就是公开透明，所有与用户的交互都是公开的，并且就在 GitHub</p><p>很巧的是我们社团的 <a href="https://blog.marlene.top/index.php/develop/93.html">Marlene</a> 同学的 OSPP 项目也是做插件市场，我和他在私下讨论了这种做法，他也表示很认同，并打算借鉴这种方案</p><p>于是总体设计就变成了这个样子</p><p><img src="https://image.nickxu.me/202310171110193.png" alt="v4.全局设计"></p><p>差别不算大，但是变成了每次发版都要新增一个 Issue 并进行两段式审核，一次机审是看符不符合规范，第二次是人工审核，也就是要求中的「经过社区 review」</p><p>之后就是 OSPP 中选了，中选后被社区拉着开了次会</p><img src="https://image.nickxu.me/202310171626988.png" alt="image-20231017下午42651938" style="zoom:50%;" /><blockquote><p>有点后悔没录像，感觉开的挺好的</p></blockquote><p>会上我讲解了现在的方案，有一个问题被重点讨论，就是不再使⽤分库的形式（开发者在各⾃的仓库维护项⽬），⽽是⼤库（所有⼈向主仓库提交 PR）</p><p>这个改变有几个原因，我记得一方面能增加开发者的认同感（我给官方仓库贡献了一个插件），另一方面这个平台应该是我们与开发者共建，而不是我们去服务开发者（有点怪，但大概是这个意思）</p><p>于是，使用大库的话很多逻辑就又要改了，比方说版本管理要自己设计一套方案，我当时设计的是在元数据里记录版本，然后版本变动的时候就通知后端更新数据，把本次 commit hash 和这个插件的这个版本关联起来，再去做 bulid</p><p>为什么要做版本管理呢？这个在会上我也讨论过，比如 VSCode 的插件就有版本管理，它每个插件版本都在元数据写上能支持哪些 VSCode 版本，我觉得我们这个 MoE 的基座也会存在类似的问题</p><p>项目结构大概就是这个样子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── plugins # 插件⽬录，存储所有插件</span><br><span class="line">│   ├── example</span><br><span class="line">│   ├── example2</span><br><span class="line">│   ├── example3</span><br><span class="line">│   └── example4</span><br><span class="line">└── web</span><br><span class="line"> ├── frontend # 前端</span><br><span class="line"> └── backend  # 后端</span><br></pre></td></tr></table></figure><p>每个插件目录的必须内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">example</span><br><span class="line">├── changelog.md # 开发者⾃⼰维护的 Markdown</span><br><span class="line">├── config.proto # 配置参数定义</span><br><span class="line">├── metadata.yaml # 插件元数据，包括名称描述分类版本等</span><br><span class="line">└── readme.md # 开发者⾃⼰维护的 Markdown</span><br></pre></td></tr></table></figure><p>这样一来，后端就需要 clone 和 pull 这个仓库，再深挖 git 历史，分析各个插件的历史版本，有点费力</p><p>为什么要这么搞呢？有没有更简单的方法，可能吧，但是我没找到</p><ul><li>Docker Extension 交的本来就是 Docker Image 的地址，Docker Hub 能给他做版本管理</li><li>而 Marlene 那是 PyPI ，版本管理那边已经做好了</li></ul><p>当然大库也不是全然没好处，我感觉这样就可以省一些逻辑，比方说貌似不需要 Issue Form 来处理各个发版事件了，也不需要维护一堆 tag，每个人直接对着仓库 PR 就行，只需要一个 Actions 里有一个简单的检查，不需要糊交互</p><p>想好了之后我开始想前后端了，MVP 的话，感觉两个接口就行，一个列表一个详情即可</p><p>而后端还需要数据库吗？啊，貌似数据库也不需要了，可以每次更新的时候直接生成 JSON 缓存，然后直接返回给前端，而查询的话至少近期可以在前端进行，这样貌似根据稳定</p><p>而 build 的话，我打算暂时先放一放吧，做最简单的打包某版本的源代码，至于编译上传 S3，或者使用 Docker Image 可以后面再说</p><p>同时，我开始糊前端，先画设计图</p><img src="https://image.nickxu.me/202310171411499.png" alt="429cdbfb0271c2ced239bae81e6748fc" style="zoom:50%;" /><p>主⻚包含列出，搜索、分类功能，详情页包含 Overview、Config、Version和 Changlog 四个 Tab</p><p>后端感觉没什么问题我就开始搓前端了，但前端我其实不是很会，但是还是在前端大佬 daidr 的帮助下完成了</p><p><img src="https://image.nickxu.me/202309281924384.png" alt=""></p><blockquote><p>首页</p></blockquote><p><img src="https://image.nickxu.me/202309281928905.png" alt=""></p><blockquote><p>详情页的 Overview ，是原 <code>readme.md</code> 的渲染</p><p>但这个渲染并不是简单的渲染，我是调用了 GitHub 的  <a href="https://docs.github.com/zh/rest/markdown/markdown?apiVersion=2022-11-28#render-a-markdown-document">Render a Markdown document</a> 接口，结合了仓库的上下文</p><p>（⽐如 <code>#1</code> 会被正确指向对应的 Issue 或者 PR）</p></blockquote><p><img src="https://image.nickxu.me/202309281926402.png" alt=""></p><blockquote><p>Config 是原 <code>config.proto</code> 的渲染</p></blockquote><p><img src="https://image.nickxu.me/202309281926047.png" alt=""></p><blockquote><p>Changelog 是原 <code>changelog.md</code> 的渲染</p></blockquote><p><img src="https://image.nickxu.me/202309281928369.png" alt=""><img src="https://image.nickxu.me/202309281927210.png" alt=""></p><blockquote><p>Versions 包含插件的所有历史版本，这个在 GitHub 直接发一个 Release 是社区里其他导师建议的</p></blockquote><p>而调试到了最后，居然感觉连后端都可以不要了（</p><p>首先由于域名备案等考虑需要，⽬前不需要有评论等交互功能，OAuth 登陆⽬前没有意义，有也可以使用静态博客的评论系统，而流量统计使用第三方服务也可以做到，至于编译推送，也可以在 GitHub Actions 中完成（我之前感觉从公网推送到内网不是很合适，但现在感觉应该也就是推到某些第三方服务上了）</p><p><img src="https://image.nickxu.me/202310172115508.png" alt="image-20231017下午91551486"></p><blockquote><p>好好好</p></blockquote><p>于是我开始把原来后端的逻辑塞到 GitHub 工作流中再重构，再进行若干修改</p><p>我想到了可以直接以 RAW 的形式直接读取仓库里的 JSON 文件，就像我的一个玩具项目一样</p><p><img src="https://image.nickxu.me/202310171410304.png" alt="7a6ab5853fd4d20854d3bdc491a72fd4"></p><p>其实没后端反而更方便了，因为我大概只需要执行这段伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 插件 := <span class="keyword">range</span> 所有插件 &#123;</span><br><span class="line">   <span class="keyword">if</span> 当前插件的版本没有打过tag &#123;</span><br><span class="line">       发布并更新缓存</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有些小改动，就是把生成的缓存移到其他分支中，因为 <code>main</code> 分支大概会有保护规则，不允许直接提交</p><p>于是我将缓存移到 <code>cache</code> 分支，并用将前端用 GitHub Page 发布，这下是真不要钱了（</p><p>再不断的调试后，到这一步，整个项目其实已经应该能跑了，而令我没想到的是，回看最开始的产出要求，我其实一个都没做到（笑）</p><ol><li>提供一个Envoy Go 插件的内容平台，在这里可以发布经过社区review的优秀插件，需要拥有服务端与前端页面</li><li>不自建账号体系，通过GitHub OAuth2.0完成用户认证与授权</li><li>进阶 - 对接GitHub OpenAPI，支持动态获取插件所在仓库信息，包括README，分支版本以及star数</li></ol><p><s>乐，只能说计划没法赶上变化</s></p><p>除此之外，还令我没想到的是导师会提那么多 LICENSE 相关的问题（</p><p><img src="https://image.nickxu.me/202310172122478.png" alt="08b0a845b2c2c0a642d8116684a9e502"></p><img src="https://image.nickxu.me/202310172123143.png" alt="397e42e1900775a5c99f0cfc6f6428ed" style="zoom:50%;" /><img src="https://image.nickxu.me/202310172123387.png" alt="86a757d0c923feb50298e40519ea5223" style="zoom: 67%;" /><p>我大概了解各自开源协议的含义，但还从没认真对待过</p><p>至于未来这个项目会怎么发展，导师说还可以用 <a href="https://docusaurus.io/zh-CN/">Docusaurus</a> 做生成的静态前端，我想也是，这样就不用生成 cache 了，直接更新前端，能少一次请求</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;书接上文 &lt;a href=&quot;https://nickxu.me/2023/06/my-story-with-OSPP-from-hearing-to-being-selected.html&quot;&gt;『OSPP2023』我与 OSPP 的故事 —— 从听闻到中选&lt;/a&gt; ，本文注重于描写项目开发的经历&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;项目基本信息&quot;&gt;项目基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;项目名称：为 Envoy Go 扩展建设插件市场&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;项目导师：纪卓志&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;项目描述：&lt;/p&gt;
&lt;p&gt;Envoy 是当前最流行的网络代理之一，Go 扩展是 MOSN 社区为 Envoy 增加的 Go 生态基础，也是 MOSN 社区 MoE 框架的基础。&lt;/p&gt;
&lt;p&gt;受益于Golang生态系统，研发可以轻松在 Envoy 实现插件用于更多的长尾场景，其中很多场景都是通用的。&lt;/p&gt;
&lt;p&gt;本项目是为Envoy Go 扩展构建插件市场。在插件市场中，人们可以在插件市场中分享插件，选用已经存在的插件。通过插件市场，可以让 Envoy</summary>
      
    
    
    
    <category term="OSPP" scheme="https://nickxu.me/categories/OSPP/"/>
    
    
    <category term="OSPP" scheme="https://nickxu.me/tags/OSPP/"/>
    
  </entry>
  
  <entry>
    <title>你还惦记着你那二面呢｜Allow Everything to Happen</title>
    <link href="https://nickxu.me/post/allow-everything-to-happen.html"/>
    <id>https://nickxu.me/post/allow-everything-to-happen.html</id>
    <published>2023-10-12T16:56:14.000Z</published>
    <updated>2023-10-12T17:20:59.012Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://image.nickxu.me/202310130057300.png" alt="f6d2c2d5852e153218a05493c7948488"></p><blockquote><p>「你还惦记着你那二面呢」</p></blockquote><p>我真的好累，今天还吐了，感觉病了</p><p>我消失了很长一段时间，本来我想写一篇长文，记录我从 8 月 22 号返校到现在发生的所有事情</p><p>但是我真的好累，简单地说，就是诸事不顺，面试、亚运、学业…我不想写</p><p>我总是想在最后来一波升华，但是我其实并没有走出来，架构不出，我写不出来</p><p>我太想成功了，但这正是我没法成功的原因</p><p>就像你找东西，你越找就越找不到，经常是后面不经意的时候突然就冒出来了</p><p>就我现在这个状态，我想留一句话，与君共勉吧</p><blockquote><p>Allow everything to happen｜允许所有事情发生</p></blockquote><p>最后，我还想说</p><p>爸爸妈妈，我永远爱你们❤️</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1979375472&auto=1&height=66"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.nickxu.me/202310130057300.png&quot; alt=&quot;f6d2c2d5852e153218a05493c7948488&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「你还惦记着你那二面呢」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我真的好累，今天还吐了，感觉病了&lt;/p&gt;
&lt;p&gt;我消失了很长一段时间，本来我想写一篇长文，记录我从 8 月 22 号返校到现在发生的所有事情&lt;/p&gt;
&lt;p&gt;但是我真的好累，简单地说，就是诸事不顺，面试、亚运、学业…我不想写&lt;/p&gt;
&lt;p&gt;我总是想在最后来一波升华，但是我其实并没有走出来，架构不出，我写不出来&lt;/p&gt;
&lt;p&gt;我太想成功了，但这正是我没法成功的原因&lt;/p&gt;
&lt;p&gt;就像你找东西，你越找就越找不到，经常是后面不经意的时候突然就冒出来了&lt;/p&gt;
&lt;p&gt;就我现在这个状态，我想留一句话，与君共勉吧&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Allow everything to happen｜允许所有事情发生&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，我还想说&lt;/p&gt;
&lt;p&gt;爸爸妈</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>浅析 JWT Refresh Token</title>
    <link href="https://nickxu.me/post/jwt-refresh-token.html"/>
    <id>https://nickxu.me/post/jwt-refresh-token.html</id>
    <published>2023-10-10T03:31:24.000Z</published>
    <updated>2023-10-11T04:40:27.865Z</updated>
    
    <content type="html"><![CDATA[<p>最近<a href="https://www.v2ex.com/t/979326">逛 V 站</a>又看见有人在讨论 JWT，感觉很多人讲的很乱，我想简单记录下我印象中的理解</p><h2 id="Session">Session</h2><p>最开始应该是 session 方案，就是用户登陆后服务器返回客户端一个存根（token）来标识当前的会话</p><p>服务器在缓存中保存这个 token，用户请求时需要传递这个 token（不管你是使用 cookie header 还是 query）</p><p>每次请求服务器都在缓存中查找这个 token，并且找到当前会话的相关信息（比如说是哪个用户）</p><p>使用这种方案的优点：</p><ul><li>强控制性：可以手动过期，如果想让某个用户下线就直接在缓存删除对应的键值对就行</li><li>可观察性：可以很清楚地看见当前的在线用户数量</li></ul><p>使用这种方案的缺点：</p><ul><li>性能需求高：因为每次请求都要查缓存，如果用户规模越大的问题越明显</li><li>对分布式不友好：他是有状态的，你必须共用一个缓存空间来存储数据</li></ul><h2 id="原始-JWT">原始 JWT</h2><p>为了克服上面的缺点， JWT 出现了</p><p>JWT (JSON Web Token ) 使用的是一种很巧妙的方法，他本身也是一个 string token，分为三部分</p><p><code>Header.Payload.Signature</code></p><ol><li>Header，标识加密算法</li><li>Payload，你要存储的数据，比如说用户 ID 、权限 Level 与过期时间等，请注意这是外部可读的</li><li>Signature，加密算法签名</li></ol><p>你需要注意的是，Payload 是前后端都可读的，但是可以使用 Signature 保证这个 Payload 是未更改的</p><p>工作流程是这样的：</p><p>用户登陆后服务器通过本地密钥计算并返回 JWT 给用户，用户请求时需要传递这个 JWT（不管你是使用 cookie header 还是 query）</p><p>服务器解析 JWT，通过本地密钥 + Signature 验证是否是当初颁发的 JWT，如果是的话就完全相信 Payload 的内容（你是谁，你的权限是什么等等）</p><p>到这里你应该能看出一些问题了，但暂时按下不表，先谈优点</p><p>使用这种方案的优点：</p><ul><li>性能要求低：不需要查缓存或者查库，如果收到的是有效的 JWT，就直接信赖 Payload 的内容</li><li>无状态&amp;分布式友好：如果你有两个毫不相干的服务 A 和 B，那么只需要你的本地密钥是相同的，那么生成的 JWT 看上去就是从一个服务生成的（也就是说能够相互承认）</li></ul><p>使用这种方案的优点：</p><p>不安全哇！即使你的 JWT 可以过期，那么在过期前用户权限更改或者用户注销了怎么办？它是无法撤销的</p><ul><li><p>如果你选择完全相信 Payload 的内容</p><p>当权限更改时（严重点用户注销时）过期之前 JWT 仍然有效，这时用户仍然可以使用之前的身份活动（严重点你可以看见注销的用户在活动）</p></li><li><p>如果你选择每次查库验证</p><p>你选择每次接收请求时都查一遍用户的权限，或者这个用户存不存在</p><p>但是这样就违背了 JWT 的初衷了，你还是倒退回「每次请求都要查一遍缓存」，JWT 就退化成类似  Session 的模型了</p></li></ul><h2 id="长短令牌的-JWT">长短令牌的 JWT</h2><p>为了缓解这个问题，就有了长短 JWT</p><ul><li><p>短期 JWT（Access Token）：用于日常访问，但是有效期短（比如 10-30min）</p><p>这样，即使权限更改或者用户注销，或者令牌被盗，也只能在短时间能使用</p></li><li><p>长期 JWT（Refresh Token）：用于在短 JWT 过期时查库并生成新的短 JWT，不能用于日常请求，有效期很长</p></li></ul><p>这种策略能很好的缓解上面的问题，比如长 JWT 只有用户 ID，每次刷新都会查库确认用户存在并拿到当前权限</p><p>即使用户身份更改了，旧身份的有效期也只有短 JWT 的长度（实际上前端应该立即销毁旧身份并刷新令牌）</p><p>当然，你可能会说这样还是不够安全哇！如果你问出这个问题的话，那你可以使用 Session 模式，它的确是更加安全可控</p><p>但对于一般项目来说也没什么所谓了，JWT 也够了，毕竟方便</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近&lt;a href=&quot;https://www.v2ex.com/t/979326&quot;&gt;逛 V 站&lt;/a&gt;又看见有人在讨论 JWT，感觉很多人讲的很乱，我想简单记录下我印象中的理解&lt;/p&gt;
&lt;h2 id=&quot;Session&quot;&gt;Session&lt;/h2&gt;
&lt;p&gt;最开始应该是 session 方案，就是用户登陆后服务器返回客户端一个存根（token）来标识当前的会话&lt;/p&gt;
&lt;p&gt;服务器在缓存中保存这个 token，用户请求时需要传递这个 token（不管你是使用 cookie header 还是 query）&lt;/p&gt;
&lt;p&gt;每次请求服务器都在缓存中查找这个 token，并且找到当前会话的相关信息（比如说是哪个用户）&lt;/p&gt;
&lt;p&gt;使用这种方案的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强控制性：可以手动过期，如果想让某个用户下线就直接在缓存删除对应的键值对就行&lt;/li&gt;
&lt;li&gt;可观察性：可以很清楚地看见当前的在线用户数量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用这种方案的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能需求高：因为每次请求都要查缓存，如果用户规模越大的问题越明显&lt;/li&gt;
&lt;li&gt;对分布式不友好：</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>字节二面挂，还是人太菜了</title>
    <link href="https://nickxu.me/post/bytedance-interview-failed-2023-09.html"/>
    <id>https://nickxu.me/post/bytedance-interview-failed-2023-09.html</id>
    <published>2023-09-07T09:19:57.000Z</published>
    <updated>2023-09-07T15:28:21.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字节一面">字节一面</h1><ul><li>自我介绍</li><li>简单介绍字节青训营项目</li><li>是组队的吗</li><li>项目耗时</li><li>项目收获的点</li><li>ELK 是你们搭建的吗</li><li>ELK 的软件安装</li><li>数据流大概是怎样的</li><li>是通过什么写到 Logstash 里的</li><li>Logstash 的功能</li><li>你们用的的 fail2ban 是什么</li><li>traceID 介绍</li><li>微服务框架用的什么</li><li>traceID 在框架中是怎么传递的</li><li>对于异步的请求怎么处理的</li><li>这个项目的挑战和难点</li><li>Golang 的 Panic 关键字</li><li>Panic 怎么恢复</li><li>不加 defer 会怎样</li><li>为什么不能恢复</li><li>go 的方法的传值，传递切片，是怎么传的，在里面改变切片，外部能感受到吗</li><li>你说的副本是什么概念</li><li>在函数中 map 改变 kv，外部能感受吗</li><li>传递结构体，一般传值还是传指针</li><li>GMP 模型</li><li>在一个程序中不断起 goroutine，它的队列最终是个什么状态</li><li>一个 G 在一个 M 上执行的时间过长，会怎样调度</li><li>是通过什么策略控制的呢</li><li>刚才说的太长时间你有个时间上的概念吗，什么时间算太长</li><li>协程和线程的区别</li><li>其他的优势，怎么时候选择协程，什么时候不应该选协程</li><li>线程和协程，IO 密集型和 CPU 密集型哪个更适合</li><li>他节省的时间是怎么体现的</li><li>如果我找其他的线程呢？有什么区别</li><li>你比较擅长什么</li><li>MySQL 为什么使用 B+ 树</li><li>分裂与结合，这个是 B 树与 B+ 树的区别吗</li><li>放在叶子结点上导致了什么呢</li><li>还有其他的吗</li><li>了解过跳表吗</li><li>时间复杂度一样吗，跳表和 B+</li><li>为什么 Redis 的 zest 使用了跳表，为什么不用 B+</li><li>MySQL 和 Redis 这两种的本质区别</li><li>有没有可能这两种分别适用于内存和磁盘</li><li>你有什么想问的</li><li>简单编程题 15min：两个 Version 字符串比较大小</li></ul><h1 id="字节二面">字节二面</h1><ul><li>自我介绍</li><li>个人擅长的领域，未来发展</li><li>能实习多长时间</li><li>什么时候可以开始</li><li>你想在哪些方向上，哪些团队实习</li><li>青训营经历</li><li>团队人数，分工</li><li>队长开发吗</li><li>持续时间</li><li>封闭式的吗</li><li>你对这个抖音后端的设计思路</li><li>微服务你这个怎么拆的</li><li>为什么这么拆</li><li>有没有必要把用户拆出来</li><li>微服务好处，实用角度</li><li>服务观测、日志收集，这个是怎么考虑的</li><li>项目难点</li><li>团队项目管理难点</li><li>怎样让协同的质量更高</li><li>做过的其他项目</li><li>跳表是什么</li><li>对比有序的数组的优点</li><li>平衡树是什么概念</li><li>平衡树有什么实现</li><li>某一种平衡树自平衡的思路</li><li>线程和协程的区别</li><li>协程为什么是 kb 级</li><li>开销更小，具体表现在哪些方面</li><li>还有别的吗</li><li>你学过什么计算机基础方面的课程吗</li><li>http 请求的数据包的传输，发生过程</li><li>四次挥手介绍</li><li>tcp 的拥塞算法</li><li>设计模式</li><li>多久接触 go 语言</li><li>gorm 的理解</li><li>技术的角度，你有没有看过源码，或者使用的角度</li><li>你有看过他的实现吗</li><li>乐观锁和悲观锁</li><li>互斥锁什么时候用</li><li>互斥锁使用的注意点</li><li>为什么设计上是不可重入的</li><li>设计上怎么避免重复上锁</li><li>介绍一下Protocol Buffers</li><li>还有吗</li><li>修改名字，换 key，在序列化上有什么注意点吗</li><li>技术上还有什么擅长的没问到的</li><li>缓存一致性</li><li>删除而不是更新是为什么</li><li>删除不会有这个问题吗</li><li>延迟双删再解释一下</li><li>如果中间有人拉了值那不就拉到旧值了</li><li>算法题 15min：手写 LRU</li></ul><h1 id="自我感受">自我感受</h1><p><img src="https://image.nickxu.me/202309072326888.png" alt="e1e010d400b8c12dce93aecd2ebee860"></p><p><img src="https://image.nickxu.me/202309072325699.png" alt="2f20f8a4ee11d8830852953215d693b0"></p><p>字节二面挂，复盘了一下感觉还是自己太菜了</p><p>感觉问的问题也算合理，我应该能答出来才对</p><p>最近发生了好多事情，真的累，以后再说吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字节一面&quot;&gt;字节一面&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;自我介绍&lt;/li&gt;
&lt;li&gt;简单介绍字节青训营项目&lt;/li&gt;
&lt;li&gt;是组队的吗&lt;/li&gt;
&lt;li&gt;项目耗时&lt;/li&gt;
&lt;li&gt;项目收获的点&lt;/li&gt;
&lt;li&gt;ELK 是你们搭建的吗&lt;/li&gt;
&lt;li&gt;ELK 的软件安装&lt;/li&gt;
&lt;li&gt;数据流大概是怎样的&lt;/li&gt;
&lt;li&gt;是通过什么写到 Logstash 里的&lt;/li&gt;
&lt;li&gt;Logstash 的功能&lt;/li&gt;
&lt;li&gt;你们用的的 fail2ban 是什么&lt;/li&gt;
&lt;li&gt;traceID 介绍&lt;/li&gt;
&lt;li&gt;微服务框架用的什么&lt;/li&gt;
&lt;li&gt;traceID 在框架中是怎么传递的&lt;/li&gt;
&lt;li&gt;对于异步的请求怎么处理的&lt;/li&gt;
&lt;li&gt;这个项目的挑战和难点&lt;/li&gt;
&lt;li&gt;Golang 的 Panic 关键字&lt;/li&gt;
&lt;li&gt;Panic 怎么恢复&lt;/li&gt;
&lt;li&gt;不加 defer 会怎样&lt;/li&gt;
&lt;li&gt;为什么不能恢复&lt;/li&gt;
&lt;li&gt;go 的方法的传值，传递切片，是怎么传的，在里面改变切片，外部能感受到吗&lt;/li&gt;
&lt;li&gt;你说的副本是什</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>🌟 你可能感兴趣的文章｜Posts you might be interested in</title>
    <link href="https://nickxu.me/posts-you-might-be-interested-in.html"/>
    <id>https://nickxu.me/posts-you-might-be-interested-in.html</id>
    <published>2023-08-21T16:18:49.000Z</published>
    <updated>2023-10-19T13:57:19.570Z</updated>
    
    <content type="html"><![CDATA[<details class="toggle" ><summary class="toggle-button" style="">Latest Resume｜最近在找实习哦</summary><div class="toggle-content"><p><img src="https://image.nickxu.me/202310192155894.jpg" alt="'My Resume (2)."></p></div></details><h1 id="Junior｜大三">Junior｜大三</h1><ul><li><a href="https://nickxu.me/post/my-story-with-OSPP-project-experience-sharing.html">『OSPP2023』我与 OSPP 的故事 —— 项目经验分享</a></li><li><a href="https://nickxu.me/post/allow-everything-to-happen.html">你还惦记着你那二面呢｜Allow Everything to Happen</a></li></ul><hr><h1 id="Sophomore｜大二">Sophomore｜大二</h1><ul><li><a href="https://nickxu.me/post/aliyun-oss-brushed-1000rmb-fees.html">阿里云OSS被刷，我交了1000RMB学费</a></li><li><a href="https://nickxu.me/2023/06/my-story-with-OSPP-from-hearing-to-being-selected.html">『OSPP2023』我与 OSPP 的故事 —— 从听闻到中选</a></li><li><a href="https://nickxu.me/posts/274.html">2023五一总结：近况与将来</a></li><li><a href="https://nickxu.me/2023/03/18/%E5%91%8A%E5%88%ABELK%EF%BC%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9FGrafana-Loki%E5%88%9D%E4%B8%8A%E6%89%8B/">告别ELK｜轻量级日志收集系统Grafana Loki初上手</a></li><li><a href="https://nickxu.me/2023/03/13/%E7%AC%AC%E4%BA%94%E5%B1%8A%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%92%E8%AE%AD%E8%90%A5%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">第五届字节跳动青训营项目总结</a></li><li><a href="https://nickxu.me/2023/03/01/%E5%86%99%E5%9C%A8%E5%A4%A7%E4%BA%8C%E5%BC%80%E5%AD%A6%E4%B9%8B%E5%88%9D/">写在大二下开学之初</a></li><li><a href="https://nickxu.me/2022/12/14/%E3%80%8ECI-CD%E3%80%8F%E7%BB%93%E5%90%88GitHub-Actions-Docker%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/">『CI/CD』结合GitHub Actions+Docker实现自动化部署</a></li><li><a href="https://nickxu.me/2022/10/31/%E5%86%99%E5%9C%A810%E6%9C%88%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/">写在10月的最后一天</a></li><li><a href="https://nickxu.me/2022/10/06/%E3%80%8ELinux%E3%80%8F%E5%B0%86-Ubuntu-22-04-%E4%BD%9C%E4%B8%BA%E4%B8%BB%E5%8A%9B%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%84%9F%E6%83%B3/">『Linux』一个多月来将 Ubuntu 22.04 作为主力系统的感想</a></li><li><a href="https://nickxu.me/2022/10/04/%E3%80%8EJWT%E3%80%8F%E5%9C%A8-go-zero-%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8-JWT-%E9%89%B4%E6%9D%83/">『JWT』在 go-zero 框架中使用 JWT 鉴权</a></li><li><a href="https://nickxu.me/2022/09/29/%E3%80%8E%E6%80%BB%E7%BB%93%E3%80%8F2022%20%E5%9B%BD%E5%BA%86%E5%89%8D%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/">『总结』2022 国庆前阶段性总结</a></li><li><a href="https://nickxu.me/2022/10/12/%E3%80%8Ehduhelp%E3%80%8F%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%8E%A5%E5%85%A5%E5%8A%A9%E6%89%8B%20OAuth/">『hduhelp』如何在项目中接入助手 OAuth</a></li><li><a href="https://nickxu.me/2022/09/28/%E3%80%8Ehduhelp%E3%80%8F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8A%A9%E6%89%8B%E7%9A%84%E5%BC%80%E6%94%BE%E6%9C%8D%E5%8A%A1/">『hduhelp』如何使用助手鉴权/使用助手的开放服务</a></li><li><a href="https://nickxu.me/2022/09/18/%E3%80%8E%E9%9A%8F%E7%AC%94%E3%80%8F2022-%E6%9D%AD%E5%8A%A9%E6%8B%9B%E6%96%B0%E9%9D%A2%E8%AF%95%E6%84%9F%E6%83%B3/">『随笔』面试官竟是我自己 —— 2022 杭助秋招面试工作感想</a></li><li><a href="https://nickxu.me/2022/09/30/GORM-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%89%8D%E8%A8%80%E4%B8%8E%E4%BB%8B%E7%BB%8D/">GORM 入门笔记（一）前言与介绍</a></li><li><a href="https://nickxu.me/2022/09/11/%E3%80%8ETwikoo%E3%80%8F%E8%A7%A3%E5%86%B3-Vercel-app-%E5%9C%A8%E5%9B%BD%E5%86%85%E8%A2%AB%E5%A2%99%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/">『Twikoo』解决 Vercel.app 在国内被墙导致无法使用的问题</a></li><li><a href="https://nickxu.me/2022/09/10/%E3%80%8E%E9%9A%8F%E7%AC%94%E3%80%8F%E5%86%99%E5%9C%A8%E6%96%B0%E5%AD%A6%E5%B9%B4%E4%BC%8A%E5%A7%8B/">『随笔』写在新学年伊始</a></li></ul><hr><h1 id="Freshman｜大一">Freshman｜大一</h1><ul><li><a href="https://nickxu.me/2022/06/29/%E3%80%8EGitHub%E3%80%8F%E5%AD%A6%E7%94%9F%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E9%97%AE%E9%A2%98/">『GitHub』学生身份认证问题</a></li><li><a href="https://nickxu.me/2022/06/14/%E3%80%8E%E9%9A%8F%E7%AC%94%E3%80%8F618%E6%A1%8C%E9%9D%A2%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92/">『随笔』618桌面改造计划</a></li><li><a href="https://nickxu.me/2022/06/12/%E3%80%8E%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5%E3%80%8F%E7%BB%93%E8%90%A5%E6%84%9F%E6%83%B3/">『字节青训营-3rd』结营感想（待后续）</a></li><li><a href="https://nickxu.me/2022/05/26/%E3%80%8EGit%E3%80%8F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Git-%E5%8F%82%E4%B8%8E%E6%9D%AD%E5%8A%A9%E7%9A%84%E9%A1%B9%E7%9B%AE/">『Git』如何使用 Git 参与杭助的项目</a></li><li><a href="https://nickxu.me/2022/05/21/%E3%80%8EWSL%E3%80%8F%E5%9C%A8WSL%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%BB%E6%9C%BA%E7%9A%84%E4%BB%A3%E7%90%86/">『WSL』在 WSL 中使用主机的代理（以 Clash 为例）</a></li><li><a href="https://nickxu.me/2022/04/23/%E3%80%8E%E5%AE%9E%E8%AE%B0%E3%80%8F%E2%80%9C%E9%9F%B5%E5%91%B3%E6%9D%AD%E5%B7%9E%E2%80%9D%E6%B5%8B%E8%AF%95%E8%B5%9B%E7%90%83%E7%AB%A5%E5%BF%97%E6%84%BF%E7%BB%8F%E5%8E%86/">『实记』“韵味杭州”测试赛球童志愿经历</a></li><li><a href="https://nickxu.me/2022/04/17/%E3%80%8E%E6%80%BB%E7%BB%93%E3%80%8F%E5%A4%A7%E4%B8%80%E4%B8%8B%E6%9C%9F%E4%B8%AD%E6%80%BB%E7%BB%93/">『总结』大一下期中总结</a></li><li><a href="https://nickxu.me/2022/04/10/%E3%80%8EOthers%E3%80%8F%E7%AC%AC%E4%B8%89%E5%B1%8A%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%92%E8%AE%AD%E8%90%A5-%E5%90%8E%E7%AB%AF%E4%B8%93%E5%9C%BA-%E6%97%A9%E7%9F%A5%E6%99%93%E7%9B%B4%E6%92%AD%E4%BC%9A%E8%AE%AE%E7%BA%AA%E8%A6%81/">『Others』第三届字节跳动青训营 - 后端专场 早知晓直播会议纪要</a></li><li><a href="https://nickxu.me/2022/01/18/gin-ru-men-bi-ji-yi-chu-shi-gin-yu-huan-jing-da-jian/">Gin 入门笔记（一）环境搭建、简单的路由配置</a></li><li><a href="https://nickxu.me/2022/03/21/%E3%80%8EWSL%E3%80%8F%E8%A7%A3%E5%86%B3%E6%AF%8F%E6%AC%A1%E5%90%AF%E5%8A%A8%E5%90%8E%E8%87%AA%E5%8A%A8%E5%88%86%E9%85%8D-IP-%E7%9A%84%E9%97%AE%E9%A2%98/">『WSL』解决每次启动后自动分配 IP 的问题</a></li><li><a href="https://nickxu.me/2022/03/13/%E3%80%8E%E6%9D%82%E6%96%87%E3%80%8F%E5%9C%A8%E8%BF%B7%E8%8C%AB%E4%B8%AD%E5%89%8D%E8%BF%9B/">『杂文』在迷茫中前进</a></li><li><a href="https://nickxu.me/2022/03/02/Python-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/">Python 入门笔记（一）搭建环境</a></li><li><a href="https://nickxu.me/2022/03/01/Java-%E7%89%88-Minecraft-%E5%8A%A0%E6%A8%A1%E7%BB%84%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/">Java 版 Minecraft 加模组开服教程</a></li><li><a href="https://nickxu.me/2022/02/28/%E3%80%8ELinux%E3%80%8FNginx-%E9%85%8D%E7%BD%AE-SSL-%E8%AF%81%E4%B9%A6/">『Linux』Nginx 配置 SSL 证书</a></li><li><a href="https://nickxu.me/2021/12/31/cc-vscode-huan-jing-pei-zhi/">『C/C++』VScode 环境配置</a></li><li><a href="https://nickxu.me/2022/02/13/Hexo%20+%20Butterfly%20%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%EF%BC%88%E3%80%87%EF%BC%89%E5%89%8D%E8%A8%80/">Hexo + Butterfly 建站指南（〇）前言</a></li></ul><hr><h1 id="High-School｜高中">High School｜高中</h1><ul><li><a href="https://nickxu.me/2019/11/14/cc-2019csp-mo-ban/">『C/C++』2019 备战 Noip / CSP</a></li><li><a href="https://nickxu.me/2020/02/20/shu-mei-pai-ru-he-yi-zheng-que-de-zi-shi-zhi-zuo-shu-mei-pai-de-tf-qia-shu-ju-jing-xiang/">『树莓派』如何以正确的姿势制作树莓派的TF卡数据镜像</a></li><li><a href="https://nickxu.me/2020/01/26/shu-mei-pai-minecraft-chao-chang-kai-fu-zhe-teng-ji-lu-javaji-yan-with-hong-shi/">『树莓派』Minecraft超长开服折腾记录（Java+基岩with红石）</a></li><li><a href="https://nickxu.me/2019/07/23/suan-fa-zong-jie-ou-ji-li-de-suan-fa-ji-tuo-zhan/">『算法』总结欧几里得算法及拓展</a></li><li><a href="https://nickxu.me/2019/07/15/suan-fa-zong-jie-kmp-suan-fa/">『算法』总结KMP算法</a></li><li><a href="https://nickxu.me/2019/07/10/shu-mei-pai-da-jian-si-you-yun-fu-wu-qi-nextcloud/">『树莓派』搭建私有云服务器（Nextcloud）</a></li><li><a href="https://nickxu.me/2019/07/06/shu-mei-pai-wifi-xin-hao-zhong-ji/">『树莓派』WiFi信号中继</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;details class=&quot;toggle&quot; &gt;&lt;summary class=&quot;toggle-button&quot; style=&quot;&quot;&gt;Latest Resume｜最近在找实习哦&lt;/summary&gt;&lt;div class=&quot;toggle-content&quot;&gt;&lt;p&gt;&lt;img src=&quot;https://image.nickxu.me/202310192155894.jpg&quot; alt=&quot;&#39;My Resume (2).&quot;&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/details&gt;
&lt;h1 id=&quot;Junior｜大三&quot;&gt;Junior｜大三&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://nickxu.me/post/my-story-with-OSPP-project-experience-sharing.html&quot;&gt;『OSPP2023』我与 OSPP 的故事 —— 项目经验分享&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nickxu.me/post/allow-everything-to-happen.html&quot;&gt;你还惦记着你那二面呢｜Allow Everything to Happen</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>阿里云OSS被刷，我交了1000RMB学费</title>
    <link href="https://nickxu.me/post/aliyun-oss-brushed-1000rmb-fees.html"/>
    <id>https://nickxu.me/post/aliyun-oss-brushed-1000rmb-fees.html</id>
    <published>2023-08-19T02:38:24.000Z</published>
    <updated>2023-10-09T12:14:15.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大致经过">大致经过</h1><h2 id="垂死病中惊坐起😱">垂死病中惊坐起😱</h2><img src="https://image.nickxu.me/202308191506591.png" alt="image-20230819下午30609530" style="zoom:50%;" /><blockquote><p>事情发生在 8 月 8 日凌晨，凌晨三点我突然看见手机上的消息</p></blockquote><p>我一开始是疑惑的，我的 OSS 是用来当做图床的，一个月也用不了几个钱</p><p>账号里记得还有 20 多块钱，怎么会这么快用完</p><p>然后我进阿里云一看，哇，我被人刷了？</p><p><img src="https://image.nickxu.me/202308191512039.png" alt="image-20230819下午31250992"><img src="https://image.nickxu.me/202308191513456.png" alt="image-20230819下午31311428"></p><p><img src="https://image.nickxu.me/202308191514660.png" alt="image-20230819下午31405635"></p><blockquote><p>最后发现被刷了 3.57 TB，请求了 138 万次</p></blockquote><p>哇，我从没想到过这种事情会发生在我的身上</p><p>而且我停机之后他还一直在刷，根本不带停的（</p><img src="https://image.nickxu.me/202308191534994.png" alt="55d88e13ece3787389f2e55c5ca8c71f" style="zoom:50%;" /><p>我想，算了，300 块交学费得了，以后得好好重视</p><p>然后我下午就看见了——</p><h2 id="1000-软妹币的账单😭">1000 软妹币的账单😭</h2><p><img src="https://image.nickxu.me/202308191544460.png" alt="897cdaf323ff4619efb6bd2975ef2716"></p><blockquote><p>1000 RMB！这下真的被上课了😱</p></blockquote><p><img src="https://image.nickxu.me/202308191544007.png" alt="f565bb21f42f5915ba0f99219b92dd27"></p><p>由于账单会有几小时的延迟，很多人说为什么欠费了不自动停，其实等你欠费的时候，人家已经刷完了</p><p>这次在我发现的时候，就已经结束了</p><img src="https://image.nickxu.me/202308191550486.png" alt="9ae17dca6a3b4610815e748cccf27cd0" style="zoom: 25%;" /><p>真的太可怕了，直接大出血</p><p>花了好久才缓过来劲</p><h2 id="可能的原因">可能的原因</h2><p>我感觉最可能的原因，是我前段时间我写的一个玩具被人发到 Twitter 上了（<a href="https://twitter.com/ProbiusOfficial/status/1687339560144093184?s=20">属于是间接出圈</a></p><img src="https://image.nickxu.me/202308191600438.png" alt="412e8c4d11403878c10ddb6629e71825" style="zoom:33%;" /><p>然后就别人盯上了🥹</p><p><s>当时还挺高兴的，这属于是出名的代价吗</s></p><h2 id="寻求客服">寻求客服</h2><p>最后我想看看找一手客服，其实我是不报希望的，看了一堆案例都是自己承担的</p><img src="https://image.nickxu.me/202308191552445.png" alt="image-20230819下午35242417" style="zoom:50%;" /><blockquote><p>结果的确如此，真的是交了 1000 RMB 学费了</p></blockquote><hr><h1 id="解决方案">解决方案</h1><p>事已至此，接下来的事情就是寻找解决方案了</p><p>在与群友交流和不断 Google 后，我总结了几种比较好的图床解决方案：</p><ol><li>国内云 OSS + 国内云 CDN（如果你很在意国内的访问速度）</li><li>国内云 OSS + Cloudflare（比较推荐的方案，但是国内访问不会很快）</li><li>Cloudflare R2（如果你有信用卡）</li><li>某些奇技淫巧</li></ol><h2 id="国内云-OSS-国内云-CDN">国内云 OSS + 国内云 CDN</h2><p>主要思路：关闭 OSS 的直接访问，只能通过 CDN 进行访问，并使用 CDN 的流量防护措施</p><p>一方面， CDN 的流量更加便宜</p><p>另一方面，你可以通过 CDN 对流量进行限制，例如限制总流量，限制最大带宽自动停机，限制 IP qps 等等</p><p>当然你也可以说我能在 OSS 上进行防护，比如说防盗链之类的</p><p>但这其实防不胜防，真要有人想搞你换个 header 就行，只能限额，而且 OSS 防火墙规则好少</p><p>总结：</p><ul><li>优点：国内访问快</li><li>缺点：需要你同时操心 OSS 和 CDN，而且国内 CDN 域名应该需要备案</li></ul><p>教程：这种教程很多，我就贴一个阿里云的吧 <a href="https://www.alibabacloud.com/help/zh/oss/user-guide/use-cdn-to-accelerate-access-to-oss">使用CDN加速OSS访问</a></p><h2 id="国内云-OSS-Cloudflare">国内云 OSS + Cloudflare</h2><p>如果你还不了解 Cloudflare，你可以先去了解一下</p><p>主要思路：由于阿里云加入了 Cloudflare 带宽联盟，你可以通过 Cloudflare 访问 OSS 中的图片，而无需支付流量费用</p><p>我没有实操过这个方案，但是下面是我感觉需要注意的事项：</p><ol><li>必须是非大陆的 OSS 才能走  CF ，比如香港（有人说必须国际站，这个不清楚）</li><li>经历不要让他人发现源 OSS</li></ol><p>总结：</p><ul><li>优点：只需支付 OSS 的存储费用</li><li>缺点：国内访问不会很快</li></ul><p>相关链接：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/605406893">阿里云OSS套CloudFlare储存WordPress博客网站图片并达到免费加速效果</a></li><li><a href="https://luotianyi.vc/6044.html">【对象存储】搭配CF带宽联盟实现流量免费</a></li><li><a href="https://fmk.im/p/cloudflare-oss/">Cloudflare与阿里云OSS配合使用的一点小问题</a></li><li><a href="https://www.v2ex.com/t/923655">想咨询下 跨境电商商品图片 如何存储和展示, cloudflare 家</a></li></ul><h2 id="Cloudflare-R2">Cloudflare R2</h2><p>主要思路：使用 Cloudflare R2 代替阿里云 OSS，这也是我最后采取的方案</p><p>R2 是 Cloudflare 推出的 S3 兼容的对象存储，最大的特点是就是便宜，量大管饱</p><p><img src="https://image.nickxu.me/202308191434581.png" alt="e81872a0f282add5b8058c27e41cefd4"></p><p>他的不是用流量计费的，而是用访问次数计费的，而且每月有免费额度</p><p>感觉这个每月 1000 万的读操作额度已经远远超过使用需求（我本次遭受的攻击也就 100万次访问）</p><p>并且 10G/月 的免费存储用作图床也是足够的</p><p>最大的缺点就是需要绑信用卡，即使你仅仅想使用免费额度也是如此</p><p><img src="https://image.nickxu.me/202308191454808.png" alt=""></p><p>于是我让群友转了点 USDT，去整了个 <a href="https://card.onekey.so/?i=YQOVM1">OneKey</a> 的卡</p><p><img src="https://image.nickxu.me/202308191459910.png" alt="image-20230819下午25900887"></p><p>下面是我当时看的两个教程</p><ul><li><a href="https://youtu.be/U0aTo71ZmvM">Depay全新升级：Dupay Visa卡来了！如何开卡充值USDT？与Master卡有何不同？</a></li><li><a href="https://youtu.be/UXHzP9g-mus">虚拟信用卡哪家强？Onekey vs Dupay，充值USDC/USDT实际损耗测算，答案和你想的一样吗？</a></li></ul><p>关于 R2 的安全性，我感觉是可以放心的，毕竟被刷 cf 肯定不会坐视不管，而且我也配置了一些规则</p><p>总结：</p><ul><li>优点：理论上不会有任何费用</li><li>缺点：国内访问不会很快（你现在看的图片都是 R2 上的，你感觉怎么样👀</li></ul><h2 id="其他方案">其他方案</h2><p>其他方案，你可以去用一些图床服务，但是我感觉不是很心动</p><p>你可能话说放 GitHub 上，但是 GitHub 单仓库 2G，我目前的图片就已经 1G 多了</p><p>又或者，还有一些奇技淫巧哈哈哈😂</p><p>比如说这个 <a href="https://github.com/cf-pages/Telegraph-Image">https://github.com/cf-pages/Telegraph-Image</a></p><h1 id="总结">总结</h1><h2 id="做好安全防护">做好安全防护</h2><p>一定要做好安全防护哇！</p><p>一定一定一定！</p><p>就当是我为大家交了学费了，你也保证一下以后不会被交学费了好不好😭</p><h2 id="缩减照片大小">缩减照片大小</h2><p>群友问的另一个问题就是为什么我的图片这么大</p><p>其实也是，我没有压缩处理一下</p><p>于是我在 PicGo 里找了一番插件，以后就上传压缩后的图片了</p><img src="https://image.nickxu.me/202308191444053.png" alt="image-20230819下午24432015" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大致经过&quot;&gt;大致经过&lt;/h1&gt;
&lt;h2 id=&quot;垂死病中惊坐起😱&quot;&gt;垂死病中惊坐起😱&lt;/h2&gt;
&lt;img src=&quot;https://image.nickxu.me/202308191506591.png&quot; alt=&quot;image-20230819下午30609530&quot; style=&quot;zoom:50%;&quot; /&gt;
&lt;blockquote&gt;
&lt;p&gt;事情发生在 8 月 8 日凌晨，凌晨三点我突然看见手机上的消息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我一开始是疑惑的，我的 OSS 是用来当做图床的，一个月也用不了几个钱&lt;/p&gt;
&lt;p&gt;账号里记得还有 20 多块钱，怎么会这么快用完&lt;/p&gt;
&lt;p&gt;然后我进阿里云一看，哇，我被人刷了？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.nickxu.me/202308191512039.png&quot; alt=&quot;image-20230819下午31250992&quot;&gt;&lt;img src=&quot;https://image.nickxu.me/202308191513456.png&quot; alt=&quot;image-20230819下午3131</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>『Golang』并发编程之通道（Channel）</title>
    <link href="https://nickxu.me/post/golang-concurrent-programming-channel.html"/>
    <id>https://nickxu.me/post/golang-concurrent-programming-channel.html</id>
    <published>2023-08-17T14:08:01.000Z</published>
    <updated>2023-08-18T12:17:08.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通道（Channel）">通道（Channel）</h1><blockquote><p>通道是什么，为什么使用通道</p></blockquote><p>「不要通过共享内存来通信，而应该通过通信来共享内存」</p><p>通道可以在多个 goroutine 之间传递数据</p><p>一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符 <code>&lt;-</code>。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向</p><blockquote><p>如何初始化通道</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">    ch1 &lt;- <span class="number">2</span></span><br><span class="line">    ch1 &lt;- <span class="number">1</span></span><br><span class="line">    ch1 &lt;- <span class="number">3</span></span><br><span class="line">    elem1 := &lt;-ch1</span><br><span class="line">    fmt.Printf(<span class="string">&quot;The first element received from channel ch1: %v\n&quot;</span>,elem1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 <code>make</code> 函数声明并初始化通道</li><li>通道的容量是 <code>int</code> 类型，但是不能小于 0 （缓冲通道和非缓冲通道）</li></ol><blockquote><p>通道的发送和接收操作都有哪些基本的特性</p></blockquote><ol><li>对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的</li><li>发送操作和接收操作中，对元素值的处理都是不可分割的</li><li>发送操作在完全完成之前会被阻塞，接收操作也是如此</li><li>元素值从外界进入通道时会被复制<ul><li>非缓冲通道的数据是直接从发送方复制到接收方</li><li>大多数情况下缓冲通道都会中转数据，如果发送时正好有人在等着接收，则会直接复制过去</li></ul></li></ol><blockquote><p>什么时候会阻塞</p></blockquote><p>正常情况下</p><ul><li>缓冲通道：如果通道已满，所有的发送操作会被依次阻塞</li><li>非缓冲通道：无论是发送操作还是接收操作，一开始执行的时候都会被阻塞，直到配对的操作也开始执行</li></ul><p>不正常情况</p><ul><li>值为 <code>nil</code> （没有使用 <code>make</code> 初始化）时，两种操作都会被永久阻塞</li></ul><blockquote><p>什么时候会 panic</p></blockquote><ul><li>对关闭的通道发送数据</li><li>对关闭的通道再次关闭</li></ul><blockquote><p>关闭的通道有什么性质</p></blockquote><p>关闭通道是指关闭通道的入口，通道关闭后仍可以从中取出数据</p><p>如果接收两个值，第二个值是 <code>bool</code> ，表示还能不能取出元素</p><p>如果值为 <code>false</code> ，表示通道已经关闭并且没有元素了，此时第一个元素会是零值</p><p>如果值为 <code>true</code> ，表示成功地取出了元素，注意你此时无法判断通道是否关闭</p><p>因此使用这个 <code>bool</code> 值判断通道是否关闭是有延迟的</p><p>永远在发送方关闭通道，不能在接收方关闭通道</p><blockquote><p>什么是单向通道，有什么用</p></blockquote><p>如果声明时包含接收操作符（<code>&lt;-</code>），就是单向通道</p><ul><li>发送通道：<code>chan&lt;-</code> ，只能发不能收</li><li>接收通道：<code>&lt;-chan</code> ，只能收不能发</li></ul><p>单向通道可以限制其他代码的行为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendInt</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    ch &lt;- rand.Intn(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里限制了函数内只能向通道内发送元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">    SendInt(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，还有可以用在接口里</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntChan</span><span class="params">()</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">    num := <span class="number">5</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, num)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">      ch &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里限制了得到返回值的程序，只能从通道中接收元素</p><blockquote><p>怎么用 <code>for range</code> 从通道中取出元素</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intChan2 := getIntChan()</span><br><span class="line"><span class="keyword">for</span> elem := <span class="keyword">range</span> intChan2 &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;The element in intChan2: %v\n&quot;</span>, elem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性质与正常操作时相同</p><blockquote><p><code>select</code> 如何与通道连用</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg1 := &lt;-ch1:</span><br><span class="line">        fmt.Println(msg1)</span><br><span class="line">    <span class="keyword">case</span> msg2 := &lt;-ch2:</span><br><span class="line">        fmt.Println(msg2)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;没有收到任何消息&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>select</code> 语句只能与通道联用，是一种多路通信选择的控制结构，允许一个 goroutine 等待多个通信操作</p><p>它由若干个分支组成。每次执行这种语句的时候，只有一个分支中的接收/发送代码会被运行</p><blockquote><p>select` 语句的分支选择规则有哪些</p></blockquote><ul><li><p>如果所有分支都阻塞，则会运行 <code>defult</code> 分支</p><p>（也就是说含有默认分支的 <code>select</code> 永远不会阻塞）</p></li><li><p>如果所有分支都阻塞，又没有 <code>defult</code> 分支，则会一直阻塞，直到有分支可以执行</p></li><li><p>如果同时有多个分支可以执行，则会随机选择一个</p></li></ul><blockquote><p>使用 <code>select</code> 的注意事项</p></blockquote><ul><li><p>如果通道关闭了，接收并不会阻塞，而同时获得零值与 <code>false</code></p><p>所以如果发现通道关闭了，应当及时屏蔽对应的分支或者采取其他措施</p><p>（将通道赋值为 <code>nil</code> 可以屏蔽改对应的分支了，因为 <code>nil</code> 的通道是一直阻塞的）</p></li><li><p><code>select</code> 语句只会将某分支的通道操作运行一次，所以如果你想连续操作的话，可以在 <code>for</code> 中使用 <code>select</code></p><p>但是如果你在 <code>select</code> 中使用 <code>break</code> 的话，只会跳出当前 <code>select</code>，而 <code>for</code> 并不会跳出</p><p>（如果想将 <code>for</code> 也跳出，可以在 <code>for</code> 前面放一个 <code>label</code>，再将 <code>label</code> 与 <code>break</code> 一起使用）</p></li><li><p>尽管 <code>select</code> 本身是并发安全的，但是不代表你的 <code>case</code> 表达式和分支中的代码也是并发安全的</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通道（Channel）&quot;&gt;通道（Channel）&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;通道是什么，为什么使用通道&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;「不要通过共享内存来通信，而应该通过通信来共享内存」&lt;/p&gt;
&lt;p&gt;通道可以在多个 goroutine 之间传递数据&lt;/p&gt;
&lt;p&gt;一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符 &lt;code&gt;&amp;lt;-&lt;/code&gt;。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何初始化通道&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/sp</summary>
      
    
    
    
    <category term="Golang" scheme="https://nickxu.me/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>『OSPP2023』我与 OSPP 的故事 —— 从听闻到中选</title>
    <link href="https://nickxu.me/2023/06/my-story-with-OSPP-from-hearing-to-being-selected.html"/>
    <id>https://nickxu.me/2023/06/my-story-with-OSPP-from-hearing-to-being-selected.html</id>
    <published>2023-06-30T06:41:59.000Z</published>
    <updated>2023-10-15T12:23:50.816Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://image.nickxu.me/202306301521080.jpeg" alt=""></p><blockquote><p>6月26日下午3点，OSPP2023 中选结果正式发布，<a href="https://summer-ospp.ac.cn/news/data">全球共有 1486 人成功申请，最终中选人数为 504 人</a></p><p>鄙人非常荣幸地成为了这 504 个幸运儿的一份子，特撰此文，记录 <code>我与 OSPP 的故事 —— 从听闻到中选</code></p><p>当然，我也希望这篇博客能够吸引更多人参与开源，为开源项目做出自己的贡献</p></blockquote><details class="toggle" ><summary class="toggle-button" style="">给「杭电助手」打点小广告</summary><div class="toggle-content"><p><img src="https://image.nickxu.me/202306301616858.jpeg" alt="IMG_0166"></p><p>本次开源之夏活动，杭州电子科技大学共中选 13 人，其中 8 人来自杭电助手</p><p>杭助本次共参与 11 人，中选率高达 8/11</p><p>（另外今年另有 1 人中选 GSoC，1 人 LFX Mentorship ）</p><p><img src="https://image.nickxu.me/202306301625148.png" alt="img"></p><blockquote><p>欢迎热爱技术的同学们填报杭州电子科技大学，欢迎同学们选择杭电助手技术部！ <a href="https://mp.weixin.qq.com/s/4hU4m2Y1eH3VfbTU267e1w">查看推文</a></p></blockquote></div></details><hr><h1 id="写在前面">写在前面</h1><p>这里是对不了解开源活动的同学进行一点飞速的补充，简短地谈一下我的理解</p><p>其实已经有很多文章讲的很好了，这里我推荐一篇杭助成员「爱飞的鸟」的 <a href="https://blog.aflybird.cn/2023/01/before-good-first-issue/">Before Good First Issue</a></p><h2 id="开源活动是什么">开源活动是什么</h2><p>开源活动通常是由开源社区、组织或公司组织的活动，目的在于吸引更多的人（特别是学生）参与开源，帮助构建开源项目，增加开源社区热度，推广开源文化与价值观，为开源事业作出贡献</p><p>比较有名的比如 LFX Mentorship、谷歌的 GSoC、国内的 OSPP、GLCC 等</p><p>一般的形式是这样的：由活动主办方提供平台与资金，吸引各路开源社区/组织入驻，社区挑选目前要做的一些活作为若干子项目（写清楚具体要做什么事情，最终达成什么目的），并且分配至少一个导师专门负责这个项目（大多数是一个）</p><p>学生呢需要给导师写 Proposal（申请书），阐述自己对这个项目的想法（如何实现），并努力让导师相信自己能够很好地完成这个项目</p><p>最终每个项目的导师会在所有申请的学生中挑选一个来做这个项目，并进行一对一的指导，帮助学生最终完成任务</p><p>这时候你就会发现，这里是存在竞争的，并且是零和博弈，赢者通吃，不过你也可以同时尝试多个项目，这样最终中选的可能就大一些</p><h2 id="为什么要参加开源活动">为什么要参加开源活动</h2><p>TL;DR，主要有下面几个吸引你的理由</p><ol><li><p>钱</p><img src="https://image.nickxu.me/202306302249043.png" alt="image-20230630下午104907011" style="zoom:50%;" /><blockquote><p>OSPP 文档中关于奖金的说明</p></blockquote><p>哈哈哈谁会和钱过不去呢？吸引别人参与活动最直接的方法就是物质奖励</p><p>一般来说是 6000 起步（GLCC），OSPP 是 8000 和 12000 两档，而 GSoC 则是 3000 刀起步（国内学生，不同地区奖金不同）</p><p><s>开源之夏也被叫做 mac 之夏，因为很多人都会去拿钱买 mac</s></p><p>当然，钱可能是最开始吸引你地方，但是你日后会发现下面的理由是更加吸引你的地方</p><p>甚至会觉得让你觉得倒贴钱你也愿意</p></li><li><p>接触顶级项目</p><img src="https://image.nickxu.me/202306302242256.png" alt="image-20230630下午104203209" style="zoom: 50%;" /><blockquote><p>杭助今年中了 GSoC 的 daidr，参加的是 chromium，他被邀请旁听内部会议</p></blockquote><p>参加开源活动的不乏一些顶级的开源项目，比如说 git，又比如说 chromium，你将有机会给它们贡献自己的代码</p><p>以后，你就可以自豪地和别人说</p><ul><li>不会用 git？我可以教你，我也是开发者之一哦</li><li>你知道吗，你用的浏览器里面有我的代码哦</li></ul><p>是不是非常的让人刮目相看？</p></li><li><p>结交朋友，积累人脉</p><img src="https://image.nickxu.me/202306302246602.png" alt="image-20230630下午104639571" style="zoom:50%;" /><blockquote><p>我的导师说他看了我的博客，居然主动问我最近是不是对找实习有些焦虑（</p><p>然后给我的简历提意见，跟我聊了很多求职就业的内容</p></blockquote><p>在社区中参与项目能让你积累很多大牛的人脉，并且参与社区内部事务</p><p>而且甚至导师们可能会主动和你交朋友</p><p>我前天也和 MOSN 里的大佬一起连麦开会，主要内容开完后和我一起聊天，有机会和阿里、蚂蚁、京东的大牛一起聊天，这真的是非常宝贵的经历</p></li><li><p>提升个人能力</p><p>正如前文所说，开源活动的目的是吸引更多的人来参与开源</p><p>所以这个活动并不是一个「我给你钱，你给我干活」的雇佣关系，而是「欢迎你来，我培养你」的关系</p><p>导师会为你的开发提供指导，你可以围绕项目向导师与社区提出自己的问题</p><p>在开发过程中，你可以学到很多知识，丰富个人经验，提升个人能力</p><p>（当然，也不是所有的导师和社区都有这么好，这也是我后文会讲的内容）</p></li><li><p>丰富简历</p><p>能参与到开源活动中肯定是能写进简历的，以后肯定也能作为与他人的谈资</p></li></ol><h2 id="关于开源之夏（OSPP）">关于开源之夏（OSPP）</h2><p><img src="https://image.nickxu.me/202307012225862.png" alt="image-20230701下午102543373"></p><blockquote><p>今年是 OSPP 的第四个年头，不知道明年会有多少人</p></blockquote><p><a href="https://summer-ospp.ac.cn/">OSPP (Open Source Promotion Plan)</a> 应该是中科院对标谷歌的 GSoC 举办的活动，在国内算是含金量最高的了</p><p>贴几段比较正式的介绍：</p><ul><li>“开源之夏（英文简称 OSPP）”是中科院软件所“开源软件供应链点亮计划”指导下的系列暑期活动，由软件所与 openEuler 社区共同主办、中科南京软件技术研究院承办，旨在鼓励在校学生积极参与开源软件的开发维护，培养和发掘更多优秀的开发者，促进优秀开源软件社区的蓬勃发展，助力开源软件供应链建设</li><li>活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。学生可自主选择感兴趣的项目进行申请，中选后在项目资深开发者（社区导师）的指导下进行开发。根据项目的难易程度和完成情况，结项者将获取开源之夏活动奖金和结项证书</li><li>开源之夏活动已迈入第四个年头。在过去的三年中，开源之夏与众多蓬勃发展的开源社区携手并进，不断推动开源技术在高校学生中的普及和推广，使得越来越多的学生参与到开源项目中来，更多优秀的开源贡献者和开源项目应运而生，为推动开源生态发展提供了有力的支持</li></ul><p>整体活动流程同 GSoC，社区报名-官方发布社区入选名单-社区发布项目-学生开始申请-社区发布学生名单-学生开始贡献，每个人可以提交三份申请，只能中选一个项目</p><p>难度上感觉比 GSoC 简单不少，GSoC 阿三的确是真的多</p><img src="https://image.nickxu.me/202307012239237.png" alt="image-20230701下午103928213" style="zoom: 67%;" /><blockquote><p>iyear 对于 OSPP 难度的评价，我感觉挺中肯的</p></blockquote><hr><h1 id="个人经历">个人经历</h1><h2 id="开始的开始">开始的开始</h2><p>在我的印象中，应该是「iyear」和「鸟」最开始在社团里说 OSPP 和 GSoC 这些事情</p><p>于是去年我就开始慢慢关注了，但当时 2022 年的都已经快结束了，所以我开始搜集信息，为明年准备</p><p>我要找哪些东西呢？</p><ul><li>第一个，我要看看过去都是些什么项目</li><li>第二个，我要去看 timeline ，熟悉里面几个比较重要的时间节点</li><li>最重要的是，我要知道竞争的激烈程度，中选率大概是个什么情况</li></ul><p>首先我去了 <a href="https://summerofcode.withgoogle.com/">GSoC 的官网</a>，然后开始翻，然后发现怎么这么多出名的项目哇，什么 VLC，什么 Electron，还有 Chromium，还有 git 、GUN，我怎么配的上这些项目哇（</p><p>然后我去翻了翻申请人和中选人数，大概有四分之一的概率中选</p><p>感觉还行吧，说不定可以试试，虽然我知道从 22 年开始，GSoC 的申请不再局限学生，人肯定一年比一年多</p><p><img src="https://image.nickxu.me/202307012352421.png" alt=""></p><blockquote><p>现在又翻了翻今年的，真的吓人，我只能说今年能中 GSoC 的都是神仙</p><p>而且今年的申请人数是什么鬼哇（</p></blockquote><p>然后我去看了 <a href="https://developers.google.com/open-source/gsoc/timeline?hl=zh-cn">timeline</a> ，关注了几个时间点</p><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>GSoC 2023</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2 月 22 日</p></div></div><div class='timeline-item-content'><p>社区、项目名单公布</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>3 月 20 日</p></div></div><div class='timeline-item-content'><p>开始接受申请</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>4 月 4 日</p></div></div><div class='timeline-item-content'><p>截止申请</p></div></div></div><p>看完了 GSoC，我接着去看 OSPP 的项目</p><p>虽然项目感觉也都很高大上，但是竞争压力看上去更小</p><p><img src="https://image.nickxu.me/202307022303147.png" alt="image-20230702下午110331878"></p><blockquote><p>OSPP2022，只能说从申请与中选的比率来看，其实还行</p></blockquote><p>然后是 2023 的 timeline</p><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>OSPP 2023</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>4 月 4 日</p></div></div><div class='timeline-item-content'><p>社区开始上线项目</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>4 月 29 日</p></div></div><div class='timeline-item-content'><p>开始接受申请</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>6 月 4 日</p></div></div><div class='timeline-item-content'><p>截止申请</p></div></div></div><p>最后，我去翻了翻 iyear 2022 年的项目，真的强哇，我大一在干什么，别人大一在干什么</p><p><s>大一参加 OSPP 进阶，我只能说人与人的差距真的比人与狗的差距还大（</s></p><p>我只能说接下来走一步看一步吧</p><h2 id="没下手的-GSoC">没下手的 GSoC</h2><p>转眼间到了 GSoC 项目公布的日子，iyear 在群里也提了一嘴</p><img src="https://image.nickxu.me/202307030014383.png" alt="image-20230703上午121444324"  /><blockquote><p>群友消息太多了，我就截了几个 iyear 的</p></blockquote><p>然后我就去看有什么项目</p><p>看的第一感觉就是：<code>我不配啊！</code></p><p>我去我怎么参加的了这些项目，我真的配不上</p><p>更关键的是，Golang 是真的不多</p><p>我在 Golang 的项目里兜兜转转，看见了一个 Keploy  ，是做 API 测试工具的</p><p><img src="https://image.nickxu.me/202307022329223.png" alt="image-20230702下午112950192"></p><p>看了看项目，只感觉这个重构命令行工具的我可能会做</p><p>当然，我肯定知道这东西肯定一堆人来抢，我只能说先看看，先研究一下</p><img src="https://image.nickxu.me/202307022334237.png" alt="image-20230702下午113446200" style="zoom:50%;" /><blockquote><p>哈哈，你可以看看现在有几个 star，人真的多</p></blockquote><p><img src="https://image.nickxu.me/202307030010605.png" alt="image-20230703上午121003545"></p><p>然后，很快啊，这东西已经寄了</p><p>我只能说阿三真的 nb，GSoC 怎么这么多阿三</p><p>之后我就真的找不到我有能力参加的项目了~~，游戏也不能一上来就是最终 BOSS 吧，我想（~~</p><p>最终的结果是可以预见的，GSoC 2023 我还是没下得去手</p><h2 id="克服恐惧">克服恐惧</h2><p>后面很长一段时间，我都是不相信自己的</p><p>我真的不见得能有能力参加这种活动，真的这样</p><p>即使后面 iyear 专门讲了一节例会，举了好几个例子，我心里也没什么信心</p><p><img src="https://image.nickxu.me/202307030018312.png" alt="image-20230703上午121828262"></p><blockquote><p>例会上的 md，iyear 讲了一个多小时，后面的内容有点隐私就不放出来了</p></blockquote><p>直到那句话，让我振聋发聩</p><p><img src="https://image.nickxu.me/202307022356272.png" alt="image-20230702下午115636218"></p><blockquote><p>要有阿三的自信😎</p></blockquote><p>对哇，为什么印度阿三都能在 GSoC 上主动出击，我一个中国人怎么能一点信心都没有</p><p>印度老哥技术上应该也会太强，但是他们自信哇，你至少要相信自己能做到，这样才有希望</p><p>然后 OSPP 毕竟我们有主场优势，基本都是国人，我下定决心，不管中没中，至少至少，我要投个项目吧</p><h2 id="OSPP-开始">OSPP 开始</h2><p>很快 OSPP 就要开始了，已经到了社区开始上线的日子</p><p>但是我记得前几天是没什么动静的，后面开始慢慢放出社区，是一点一点放的</p><p>所以我每天起来第一件事就是去 <a href="https://summer-ospp.ac.cn/org/orglist">https://summer-ospp.ac.cn/org/orglist</a> 上看今天又多了什么社区，有什么项目</p><p>当然了，我很早也把去年的项目都看了一遍</p><p>讲真每天都去看看是很有效的，就像高中的时候背文言文一样，看上去很长很恐怖，但是同学告诉我，只要每节课一下课就飞快地读一遍，很快就熟了</p><p>的确如此，过去我看着这些项目都很不自信</p><p>但是现在，我能很平静地说：</p><p>“也没什么，这里的每个项目我都看过”</p><h2 id="感谢-yeebing-！">感谢 yeebing ！</h2><p>看了很久的项目，但是感觉还是没找到比较适合我的</p><p>其他领域就不说了，我目前比较能拿得出手感觉只有 Golang 后端</p><p>而逛了一圈，感觉对前端真的很友好，在看去年项目的时候居然有不少官网设计和文档优化的</p><div class="gallery">    <div class="fj-gallery  data" data-rowHeight="220" data-limit="10">    <span class="gallery-data">[{"url":"https://image.nickxu.me/202307041603566.png","alt":"1c508ec5077eff3f9b366938e43a1cba"},{"url":"https://image.nickxu.me/202307041607998.png","alt":"334dcddce604b196fea8bd4be4126ac1"},{"url":"https://image.nickxu.me/202307041603661.png","alt":"6f4f10146ff20cb15aa25bc522584e3e"}]</span>    </div>    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>    </div><p>相比之下，Golang 的低难度项目很稀缺， 我看着基本都是云原生的，毕竟 Golang 目前最大的用途基本也就是写云原生的基础设施</p><p>但是云原生我是真的不会哇，kubernetes 我都不是很熟，那些项目我也看不太懂</p><p>只能说再看看会有什么项目了</p><p>然后突然有一天，yeebing 突然找到我</p><img src="https://image.nickxu.me/202307041617977.png" alt="image-20230704下午41722930" style="zoom:50%;" /><blockquote><p>还得是杭助的人脉哈哈哈</p></blockquote><p>看了一眼，后端我的确没问题，但是有个问题就是我不会前端哇</p><p>但是转念一想，来 OSPP 就是要学新东西的，而且杭助这么多前端的佬，我速成一波前端应该也不是不可以</p><p>毕竟我目前也找不到比这个更好的项目了，于是我开始冲这个项目</p><h2 id="开始迭代">开始迭代</h2><p>yeebing 帮我占了个沙发，我翻了翻文档，大概知道是个什么东西之后，我就开始冲了</p><p><img src="https://image.nickxu.me/202307041637634.png" alt="image-20230704下午43727576"></p><p>前期是很关键的，只要你能在 issue 里跟导师来回说一堆话，那别人也就能知道这个项目已经有人了，至少能让一部分人知难而退</p><p>之后就开始迭代了，我们在 issue 下交流，之后是深入的思考，感觉差不多了就开始搓 Proposal 发邮件</p><p>导师给我纠正了一些方向上的问题，于是我调研后重新思考设计</p><p>没想到出到第二版跟我说可以去提交了（</p><p><img src="https://image.nickxu.me/202307041645144.png" alt="image-20230704下午44538074"></p><p>然后突然有一天晚上，导师突然来加我好友</p><p><img src="https://image.nickxu.me/202307041708059.png" alt="d1a99451107484673017aae5d322e672_0"></p><p>才想起来我之前翻文档的时候顺手加了个用户群（感觉有点猝不及防</p><p>然后我们后面就开始聊，根据我的简历给我提了好多建议</p><p><img src="https://image.nickxu.me/202307041704047.png" alt="image-20230704下午50425978"></p><blockquote><p>对比其他群友，我感觉我这真的是个神仙导师（</p></blockquote><h2 id="OSPP-线下会">OSPP 线下会</h2><p><img src="https://image.nickxu.me/202307041719852.webp" alt="图片"></p><blockquote><p>线下会杭州站，可以看 <a href="https://www.bilibili.com/read/cv23843608">cv23843608</a> ，三咲智子居然也去了</p></blockquote><p>OSPP 当时也在全国各地开线下会，在杭州也有</p><p>我的确报名了，也进了群，杭助也有不少人去了</p><p>但可惜的是我那天阳了在隔离，想着阳了就别出去祸害别人了，而且精力也不是很好，就没去</p><img src="https://image.nickxu.me/202307041723785.png" alt="image-20230704下午52338719" style="zoom:50%;" /><p>再贴点找到的当时的照片吧哈哈哈</p><div class="gallery">    <div class="fj-gallery  data" data-rowHeight="220" data-limit="10">    <span class="gallery-data">[{"url":"https://image.nickxu.me/202307041731134.png","alt":"image-20230704下午53115061"},{"url":"https://image.nickxu.me/202307041733694.png","alt":"image-20230704下午53327596"},{"url":"https://image.nickxu.me/202307041733568.png","alt":"image-20230704下午53305500"},{"url":"https://image.nickxu.me/202307041731500.png","alt":"image-20230704下午53132438"},{"url":"https://image.nickxu.me/202307041731435.png","alt":"image-20230704下午53150368"},{"url":"https://image.nickxu.me/202307041732513.png","alt":"image-20230704下午53245428"}]</span>    </div>    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>    </div><h2 id="大受震撼">大受震撼</h2><p>日子一天天地过去，我还在为好像还没有人和我抢项目而沾沾自喜</p><p>突然有一天收到了 GitHub 的邮件，一开始我以为是哪个社团项目谁 PR 了，结果一看居然有人来抢我的 OSPP 项目了 ？！</p><p><img src="https://image.nickxu.me/202307041750442.png" alt="image-20230704下午55052373"></p><blockquote><p>卧槽我直接大受震撼</p></blockquote><p>然后我一看，卧槽，酒吧舞✌️，ACM✌️，然后一看博客，大一华为实习</p><p>卧槽这是什么神仙</p><p><s>真的是人与人的差距比人与狗的差距都大（</s></p><p>然后 iyear 就来安慰我，还得是 iyear 够自信</p><p><img src="https://image.nickxu.me/202307041823065.png" alt="image-20230704下午62305997"></p><p>其实还不算太慌，毕竟都最后几天了，导师应该也不会再换人了</p><h2 id="预知结果">预知结果</h2><p>提交截止了，后面的就是等结果</p><p>之后突然有一天</p><p><img src="https://image.nickxu.me/202307041831306.png" alt="image-20230704下午63127228"></p><p>于是我就去看</p><p><img src="https://image.nickxu.me/202307041853830.png" alt="6b3cc9b5bf5949f6cba2901034ba9cda"></p><blockquote><p>还是羡慕 daidr 的 GSoC 哈哈哈</p></blockquote><p>我感觉基本算是稳了，反正期末考了也干不了什么了，那就等通知吧</p><h2 id="正式通知-杭助喜报">正式通知 &amp; 杭助喜报</h2><p>6 月 26 日，结果下来了，我也收到了邮件</p><p><img src="https://image.nickxu.me/202307042134321.png" alt="86e87455433bb7b1b9f5e14e3f38f591_0"></p><blockquote><p>终于等到你！</p></blockquote><p>然后在杭助里统计了一下，感觉真的挺开心的，杭助的技术氛围真的不错</p><img src="https://image.nickxu.me/202307042135884.png" alt="image-20230704下午93502834" style="zoom: 50%;" /><blockquote><p>也希望能吸引更多人加入杭电助手技术部的大家庭</p></blockquote><h2 id="继续开发">继续开发</h2><p><img src="https://image.nickxu.me/202307042152919.png" alt="image-20230704下午95240872"></p><p>中选之后，导师拉着我参加了内部的会议，对一部分内容提出了修改意见</p><p>毕竟我对这个插件市场的定位没有 MOSN 的 maintainers 那么深入，而且我感觉真的挺合理的，想的问题都考虑的非常周到</p><p>主要内容讨论完之后，说开的这么好居然没有录下来（</p><p>然后又聊到我多大了，我说我 03 年的，就感觉挺年轻吧，一旁有人说现在连研究生都是 00 后了，哈哈哈</p><p>我就感觉，哇，我感觉我就是开源的新鲜血液，我的确能「为其他人做一些，有意义的事情」</p><hr><h1 id="经验总结">经验总结</h1><p>一直拖拖拖，感觉写的有点虎头蛇尾了，下面就分享几点中选的经验吧</p><h2 id="滚雪球-现在就开始">滚雪球 现在就开始</h2><p>别一开始就说做不到，没有人是一口吃成胖子的，都是一个成长的过程</p><p>其实很多事情都是「你之前做了一个什么事」，一步步进步的，就像滚一个雪球的过程</p><p>比如说我</p><ul><li>如果不是初中对计算机感兴趣，开始折腾计算机，高中也不会去 Noip，也不会去玩树莓派</li><li>如果高中没有一定的积累，大一也没那么容易进杭电助手，也不会在杭助融入的那么快</li><li>如果没进杭电助手， 也就没有后面的事情了，我也没法在字节青训营取得那样的成绩，更不会听说 OSPP 这种东西</li></ul><p>所以说不管那么多，先让自己滚起来再说，等于说是有一个正向的循环，能让你不断的进步</p><p>而且是越早越好，别明天，现在就开始，像 iyear，初中就在打 oi，比我早了一个阶段，所以大一就参加了 OSPP，今年更是去了 LFX Mentorship</p><h2 id="要有阿三的自信">要有阿三的自信</h2><img src="https://image.nickxu.me/202307042244857.png" alt="image-20230704下午104441787" style="zoom:67%;" /><blockquote><p>另外一个就是要记住 iyear 的话：「要有阿三的自信」</p></blockquote><p>讲的就是一个自信好吧，<strong>你不自信，你就已经输了</strong></p><h2 id="双向选择">双向选择</h2><p>讲真现在有些开源社区也挺离谱的，下面的开源乱象也会说</p><p>简单的说就是要记住双向选择，就像面试企业一样，不仅是社区选择你，也是你选择社区</p><p>不能白白被别人 PUA，不能被白白养鱼</p><h2 id="主动出击-快速占领-前期很重要">主动出击 快速占领 前期很重要</h2><p>如果你已经确定看中了一个项目，那就尽快出击，去交流讨论，同时最好让别人也看见</p><p>一般来说，前期是最重要的，如果别人已经先你一步和导师聊了很多，那你中选的几率也不会太高</p><p>也就是说别想着自己一直闭门造车，然后在提交截止那天交上去就完了，如果导师有另一个跟他讨论很久的学生，你觉得他会选哪个</p><h2 id="让别人能了解自己">让别人能了解自己</h2><p>要维护自己的个人形象，像 GitHub 头像都没换的，主页一点进去啥都没有的，怎么让别人相信你有能力参与开发</p><p>要给导师一些渠道来了解自己，比如能让导师知道你之前有什么什么项目经历，能力强的话之前在哪些开源社区混过</p><p>又或者是和我一样有个博客可以让别人看，这也是让导师了解你的很好的方法</p><p>总之一句话，你已经看上了别人，那也要让别人看的上你，为此你就需要做一些事情让自己显得专业</p><p>就像我这次还特地折腾了个自定义域名的邮箱，以后面试工作也是一样的，别人用个谷歌邮箱去面试，你简历上写个 QQ 邮箱，你觉得呢？</p><p>即使你说 gmail 没 QQ 方便，还要翻墙，其实你可以设置自动转发，我就是这么弄的</p><h2 id="统一命名空间-别撞车">统一命名空间 别撞车</h2><p>和社团的其他伙伴一起的时候要注意别撞车了，不然就会是很尴尬的局面🥲</p><p><img src="https://image.nickxu.me/202307050022196.png" alt="image-20230705上午122240143"></p><p>像这次就碰见了不少撞车的情况</p><p><img src="https://image.nickxu.me/202307050030677.png" alt="image-20230705上午123051615"></p><h2 id="不利形势-及时放弃">不利形势 及时放弃</h2><p>如果发现自己希望不大（比如导师好像根本不想理你、委婉拒绝，或者已经有谈的很好的人了），就应该及时放弃，转移阵地</p><p>如果你精力够的话还可以尝试多开，叶师傅这次就是这么干的</p><h2 id="一点点运气">一点点运气</h2><p>导师真的得看运气我感觉</p><p>讲真我这真的是神仙导师，每次发信息基本都是秒回，我真的太感动了（</p><p><img src="https://image.nickxu.me/202307050024196.png" alt="image-20230705上午122453142"></p><h2 id="其他因素">其他因素</h2><p>还要很多其他因素，下面的图你就可以看得出来</p><p><img src="https://image.nickxu.me/202307052132207.png" alt="image-20230705下午93257160"></p><blockquote><p>一个是被骑士，另一个是社区排名不够，骑士就不说了，下面说一下社区排名</p></blockquote><p>GSoC 和 OSPP 不同，GSoC 还有一个社区的排名</p><p>也就是导师选中你之后，还没有完全结束</p><p>一般来说 GSoC 会给每个社区分配项目名额，当你和导师结对之后，要一起参与社区内的排名，只有在名额内的才能算真正的中选</p><p>举个例子，你在 GSoC 上看中了一个社区，里面有 10 个项目，你申请了一个，并且导师也选你了</p><p>但是 GSoC 给你的社区只有 5 个名额，之后 10 个项目一起参与排名，但是你的项目不幸排在了第 6 名，于是很可惜还是寄了</p><p>社区排名会看项目对社区短期内效益大不大，还有你和社区的关系，关系好的直接安排了</p><p>还有看导师好不好，导师可能会跟你明说排名估计难，让你换项目，不会浪费你太多时间</p><p>这方面还是有些主观能动性的</p><p>今年的 OSPP 也出现了类似的情况</p><img src="https://image.nickxu.me/202307052109365.jpeg" alt="8e7fea2cafb89ce17eba2af1296378e5" style="zoom:50%;" /><p>具体来说就是之前都是社区报几个主办方都出资支持，但是这一届会给社区名额，超出名额的项目资金必须社区自己解决</p><p>然后就出现了一些尴尬的情况，iyear 今年就是这么寄的</p><p><img src="https://image.nickxu.me/202307052119319.png" alt="9d385ce046b1665e3fb931dd5bd35801"></p><blockquote><p>导师直接改名有点草（</p></blockquote><p>就是社区一开始不清楚这个规则，报了很多项目，然后后来突然发现只给了两个名额，其他的要自己花钱</p><p>于是很多项目就被砍了，你可以看见这个社区只有两个学生最终中选</p><hr><h1 id="未来展望">未来展望</h1><p><s>明天早八，好困，明天写</s></p><p>简单写一下吧</p><h2 id="开源乱象">开源乱象</h2><p>有人一直认为国内的开源是个笑话，我感觉也不是完全没有道理</p><p>这届 OSPP 出现了一些抽象事件，我在官方群里也感受到了</p><p>具体可以看「鸟」写的博客，<a href="https://blog.aflybird.cn/2023/06/please-stop-fucking-open-source-activities-in-china/">请还国内开源活动一片净土</a> （注意看评论区，有事情不好明话说</p><p>鉴于目前国内学术圈的某些操作，我感觉未来出现「开源刘禅」也不是不可能</p><p>另外可以看看另一位杭助成员的博客：<a href="https://marlene.top/index.php/develop/85.html">开源之旅——OSPP</a></p><h2 id="要把人留下来">要把人留下来</h2><p>还记得我开头说的，开源活动的目的是吸引更多的人（特别是学生）参与开源</p><p>但是现在就感觉，很多人都把利益看的太重了</p><p>结果就是，我来了，我完成了项目，我走了，人没留下来</p><p>讲真这最后还是没把社区做起来，我只能说，我这次做的这个项目，我以后肯定会一直维护迭代的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.nickxu.me/202306301521080.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;6月26日下午3点，OSPP2023 中选结果正式发布，&lt;a href=&quot;https://summer-ospp.ac.cn/news/data&quot;&gt;全球共有 1486 人成功申请，最终中选人数为 504 人&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;鄙人非常荣幸地成为了这 504 个幸运儿的一份子，特撰此文，记录 &lt;code&gt;我与 OSPP 的故事 —— 从听闻到中选&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当然，我也希望这篇博客能够吸引更多人参与开源，为开源项目做出自己的贡献&lt;/p&gt;
&lt;/blockquote&gt;
&lt;details class=&quot;toggle&quot; &gt;&lt;summary class=&quot;toggle-button&quot; style=&quot;&quot;&gt;给「杭电助手」打点小广告&lt;/summary&gt;&lt;div class=&quot;toggle-content&quot;&gt;&lt;p&gt;&lt;img src=&quot;https://image.nickxu.me/202306301616858.j</summary>
      
    
    
    
    <category term="OSPP" scheme="https://nickxu.me/categories/OSPP/"/>
    
    
    <category term="OSPP" scheme="https://nickxu.me/tags/OSPP/"/>
    
  </entry>
  
  <entry>
    <title>『算法拾遗』重学主流排序算法</title>
    <link href="https://nickxu.me/posts/sorting-algorithm.html"/>
    <id>https://nickxu.me/posts/sorting-algorithm.html</id>
    <published>2023-06-13T04:21:54.000Z</published>
    <updated>2023-10-08T02:28:14.901Z</updated>
    
    <content type="html"><![CDATA[<details class="toggle" ><summary class="toggle-button" style="">衡量排序算法的好坏</summary><div class="toggle-content"><p>时间复杂度</p><ul><li>包含最好情况、最坏情况和平均情况</li><li>数据有序度不同的影响</li></ul><p>空间复杂度</p><ul><li>是否是原地排序</li></ul><p>稳定性</p><ul><li>排序后，相同元素之间的顺序是否会改变</li></ul></div></details><h1 id="O-n-2">O( n^2 )</h1><h2 id="冒泡排序（Bubble-Sort）">冒泡排序（Bubble Sort）</h2><blockquote><p>依次比较相邻的元素，如果顺序错误，则交换它们。每轮排序将最大（或最小）的元素“冒泡”到正确的位置</p><p>简单易懂，但效率较低，不适用于大规模数据排序</p></blockquote><ul><li><p>过程</p><ol><li>初始化待排序数组，设为 <code>arr</code> ，数组长度为 <code>n</code></li><li>外层循环：重复 <code>n-1</code> 次（即 <code>i</code> 从 <code>0</code> 到 <code>n-2</code> ） <mark class="hl-label green">思考：为什么外层是n-1次</mark> <ol><li>内层循环：重复 <code>n-i-1</code> 次（即 <code>j</code> 从 <code>0</code> 到 <code>n-i-2</code> ）  <mark class="hl-label green">思考：为什么内层是n-i-1次</mark> <ol><li>比较 <code>arr[j]</code> 和 <code>arr[j+1]</code> ，如果 <code>arr[j]</code> 大于 <code>arr[j+1]</code> ，执行下一步，否则继续内层循环</li><li>交换 <code>arr[j]</code> 和 <code>arr[j+1]</code> 的位置</li></ol></li><li>判断是否在本轮内层循环中进行了交换操作：<ul><li>如果没有进行交换，说明数组已经有序，提前结束排序</li></ul></li></ol></li><li>冒泡排序结束，数组 <code>arr</code> 已经按升序排列</li></ol></li><li><p>性质</p><ol><li>在排序没有完成之前，小的数会逐步往前移，大的数会逐步往后移动</li><li>每轮排序至少会让一个最大元素放置在正确位置，重复 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 次，就完成了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个元素的排序</li><li>是稳定的排序算法</li><li>空间复杂度：冒泡排序的空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，它在原地进行排序，不需要额外的内存空间。</li><li>最优情况：冒泡排序的最优情况是输入数组已经有序。在这种情况下，只需要进行一次遍历，没有元素交换，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>最坏情况：冒泡排序的最坏情况是输入数组完全逆序。在这种情况下，需要进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 轮遍历，每轮遍历需要进行元素比较和交换，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>平均情况：冒泡排序的平均时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。因为每一对元素在排序过程中都有可能发生交换，所以平均时间复杂度较高</li></ol></li><li><p>代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ &#123; <span class="comment">// 一共要排序 n-1 轮（因为每 1 轮至少能让 1 个元素放在正确的位置）</span></span><br><span class="line">        <span class="comment">// 标记是否进行了交换，如果在某轮遍历中没有发生交换，则说明数组已经有序，可以提前结束排序。</span></span><br><span class="line">        swapped := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++ &#123; <span class="comment">// 每轮比较 n-i-1 次（因为前面 i 轮已经让 i 个元素有序了）</span></span><br><span class="line">            <span class="comment">// 比较相邻的元素，如果顺序错误则交换它们</span></span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">                swapped = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果在某轮遍历中没有发生交换，则说明数组已经有序，可以提前结束排序。</span></span><br><span class="line">        <span class="keyword">if</span> !swapped &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><details class="toggle" ><summary class="toggle-button" style="">冒泡排序的例子（GPT）</summary><div class="toggle-content"><p>好的，让我们来看一个冒泡排序的例子。假设我们要对一个整数数组进行升序排序，下面是冒泡排序的步骤：</p><p>初始数组：[5, 2, 9, 1, 5, 6]</p><p>第一轮冒泡：</p><ul><li>比较 5 和 2：需要交换位置，数组变为 [2, 5, 9, 1, 5, 6]</li><li>比较 5 和 9：位置正确，不需要交换，数组保持不变 [2, 5, 9, 1, 5, 6]</li><li>比较 9 和 1：需要交换位置，数组变为 [2, 5, 1, 9, 5, 6]</li><li>比较 9 和 5：需要交换位置，数组变为 [2, 5, 1, 5, 9, 6]</li><li>比较 9 和 6：需要交换位置，数组变为 [2, 5, 1, 5, 6, 9]</li></ul><p>第一轮冒泡结束后，最大的元素 9 已经被“冒泡”到正确的位置末尾。</p><p>第二轮冒泡：</p><ul><li>比较 2 和 5：位置正确，不需要交换，数组保持不变 [2, 5, 1, 5, 6, 9]</li><li>比较 5 和 1：需要交换位置，数组变为 [2, 1, 5, 5, 6, 9]</li><li>比较 5 和 5：位置正确，不需要交换，数组保持不变 [2, 1, 5, 5, 6, 9]</li><li>比较 5 和 6：位置正确，不需要交换，数组保持不变 [2, 1, 5, 5, 6, 9]</li></ul><p>第二轮冒泡结束后，第二大的元素 5 也已经被“冒泡”到正确的位置。</p><p>第三轮冒泡：</p><ul><li>比较 2 和 1：需要交换位置，数组变为 [1, 2, 5, 5, 6, 9]</li><li>比较 2 和 5：位置正确，不需要交换，数组保持不变 [1, 2, 5, 5, 6, 9]</li><li>比较 5 和 5：位置正确，不需要交换，数组保持不变 [1, 2, 5, 5, 6, 9]</li></ul><p>第三轮冒泡结束后，第三大的元素 2 也已经被“冒泡”到正确的位置。</p><p>第四轮冒泡：</p><ul><li>比较 1 和 2：位置正确，不需要交换，数组保持不变 [1, 2, 5, 5, 6, 9]</li><li>比较 2 和 5：位置正确，不需要交换，数组保持不变 [1, 2, 5, 5, 6, 9]</li></ul><p>第四轮冒泡结束后，第四大的元素 1 也已经被“冒泡”到正确的位置。</p><p>最后一轮冒泡：</p><ul><li>比较 1 和 2：位置正确，不需要交换，数组保持不变 [1, 2, 5, 5, 6, 9]</li></ul><p>最后一轮冒泡结束后，第五大的元素 1 也已经被“冒泡”到正确的位置。</p><p>现在数组已经完全有序：[1, 2, 5, 5, 6, 9]。整个冒泡排序过程完成。</p><p>冒泡排序的基本思想是通过相邻元素的比较和交换来逐步“冒泡”最大元素至正确位置。这个过程持续执行直至所有元素都排好序。请注意，冒泡排序可能需要多次遍历数组来确保所有元素都在正确的位置。虽然冒泡排序简单易懂，但它的效率较低，不适用于大规模数据的排序。</p></div></details></li><li><details class="toggle" ><summary class="toggle-button" style="">可能会问的问题（GPT）</summary><div class="toggle-content"><p>在面试中，关于冒泡排序，面试官可能会问您以下几类问题：</p><ol><li><p>冒泡排序的原理和思想是什么？</p><ul><li>回答要点：冒泡排序是一种简单的排序算法，它通过相邻元素的比较和交换来逐步“冒泡”最大元素至正确的位置。它的核心思想是重复遍历数组，每次遍历将当前最大元素放到未排序部分的末尾。</li></ul></li><li><p>冒泡排序的时间复杂度是多少？</p><ul><li>回答要点：冒泡排序的平均时间复杂度为O(n^2)，最好情况下（数组已经有序）为O(n)，最坏情况下（数组完全逆序）为O(n^2)。平均情况下，需要进行n-1轮外层循环，每轮循环需要比较n-i-1次，共进行(n-1) + (n-2) + … + 1 = n*(n-1)/2次比较。</li></ul></li><li><p>冒泡排序是稳定排序算法吗？</p><ul><li>回答要点：是的，冒泡排序是一种稳定的排序算法。在冒泡排序的过程中，只有在相邻元素需要交换时才改变相等元素的顺序，所以相等元素的相对位置在排序前后保持不变。</li></ul></li><li><p>如何优化冒泡排序的时间复杂度？</p><ul><li>回答要点：可以使用一个标志位来判断在某一轮外层循环中是否进行了交换操作，如果没有交换，说明数组已经有序，可以提前结束排序，从而优化最好情况下的时间复杂度为O(n)。</li></ul></li><li><p>冒泡排序和其他排序算法的比较？</p><ul><li>回答要点：冒泡排序是一种简单易懂的排序算法，但其时间复杂度较高，不适合大规模数据的排序。相比之下，快速排序、归并排序和堆排序等排序算法在平均情况下有更高效的时间复杂度，并且更常用于实际应用。</li></ul></li><li><p>你能实现冒泡排序的代码吗？</p><ul><li>回答要点：您需要在面试中展示您对冒泡排序的理解，然后根据编程语言要求编写冒泡排序的代码实现。</li></ul></li></ol><p>在面试过程中，除了理解冒泡排序的原理和性质外，您还应该能够清晰地表达答案，展示您对算法的理解和编程能力。如果需要，可以使用示例或画图来帮助说明。同时，与面试官保持良好的沟通，如果有任何不清楚的地方，随时请教面试官。</p></div></details></li></ul><h2 id="插入排序（Insertion-Sort）">插入排序（Insertion Sort）</h2><blockquote><p>分区左右分为已排序和未排序两个部分，每次选取一个元素插入到已排序的部分中</p><p>适用于小型数据集和基本有序的数据，效率较冒泡排序稍高。<mark class="hl-label green">思考：时间复杂度相同，为什么说插入比冒泡效率高</mark> </p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">key := arr[i]</span><br><span class="line">j := i - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 arr[0..i-1] 中大于 key 的元素向后移动一格</span></span><br><span class="line"><span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key &#123;</span><br><span class="line">arr[j+<span class="number">1</span>] = arr[j]</span><br><span class="line">j = j - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">arr[j+<span class="number">1</span>] = key</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性质</p><ul><li>移动的次数等于逆序度</li><li>是原地排序</li><li>是稳定的排序算法</li><li>最好时间复杂度（完全有序）： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>最坏时间复杂度（完全倒序）： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>平均时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul><h2 id="选择排序（Selection-Sort）">选择排序（Selection Sort）</h2><blockquote><p>分区同样左右分为已排序和未排序两个部分，每次扫描未排序部分，找到最大（小）值，交换附加到已排序部分的末尾</p><p>一般不会使用</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectionSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">minIndex := i</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> arr[j] &lt; arr[minIndex] &#123;</span><br><span class="line">minIndex = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换最小值和当前值</span></span><br><span class="line">arr[i], arr[minIndex] = arr[minIndex], arr[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性质</p><ul><li>是原地排序算法</li><li>最好、最坏、平均都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>不稳定的排序算法</li></ul><h1 id="O-n-logn">O( n*logn )</h1><h2 id="归并排序（Merge-Sort）">归并排序（Merge Sort）</h2><blockquote><p>先将左右两边分别排序，再合并到一起（自底向上）</p><p>递推公式：<code>merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))</code></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line">mid := <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> merge(mergeSort(nums[:mid]), mergeSort(nums[mid:]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(left)+<span class="built_in">len</span>(right))</span><br><span class="line">i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(left) &amp;&amp; j &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line"><span class="keyword">if</span> left[i] &lt;= right[j] &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, left[i])</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, right[j])</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(left); i++ &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, left[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ; j &lt; <span class="built_in">len</span>(right); j++ &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, right[j])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性质</p><ul><li><p>是稳定的排序算法</p></li><li><p>时间复杂度永远是 <code>O(nlogn)</code></p></li><li><p>致命的弱点是需要 <code>O(n)</code> 的临时空间</p></li><li><p>可以统计逆序对</p><p>在合并的时候如果 <code>left[i] &gt; right[j]</code> ，那么 <code>left</code> 之中包括 <code>left[i]</code> 在内后面的元素都比 <code>right[j]</code> 大，都能构成逆序对，所以可以 <code>ans += len(left) - i</code></p></li></ul><h2 id="快速排序（Quicksort）">快速排序（Quicksort）</h2><blockquote><p>选择一个基准分成左中右三部分（通常是中间或者末尾元素），然后使左部分都比基准小，右部分都比基准大（自顶向下）</p><p>递推公式：<code>quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)</code></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pivot := arr[<span class="built_in">len</span>(arr)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">var</span> left, right []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> arr[:<span class="built_in">len</span>(arr)<span class="number">-1</span>] &#123;</span><br><span class="line"><span class="keyword">if</span> num &lt;= pivot &#123;</span><br><span class="line">left = <span class="built_in">append</span>(left, num)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">right = <span class="built_in">append</span>(right, num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sortedLeft := quickSort(left)</span><br><span class="line">sortedRight := quickSort(right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">append</span>(<span class="built_in">append</span>(sortedLeft, pivot), sortedRight...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看见这不是原地排序的，优化后可以做到原地排序（类似选择排序，使用交换法在末尾放入元素）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// partition 函数负责将数组 nums 的子数组 [low, high] 分区。</span></span><br><span class="line"><span class="comment">// 函数选择一个枢轴元素，然后重新排列子数组，</span></span><br><span class="line"><span class="comment">// 使得所有小于枢轴的元素位于其左侧，</span></span><br><span class="line"><span class="comment">// 所有大于枢轴的元素位于其右侧。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums []<span class="type">int</span>, low, high <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">pivot := nums[low] <span class="comment">// 基准随便选，这里选首元素</span></span><br><span class="line">i, j := low, high</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line"><span class="comment">// 从右往左找到一个小于枢轴的元素</span></span><br><span class="line"><span class="keyword">for</span> i &lt; j &amp;&amp; nums[j] &gt;= pivot &#123;</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line">nums[i] = nums[j]</span><br><span class="line"><span class="comment">// 从左往右找到一个大于枢轴的元素</span></span><br><span class="line"><span class="keyword">for</span> i &lt; j &amp;&amp; nums[i] &lt;= pivot &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">nums[j] = nums[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将枢轴元素放回正确的位置（i 和 j 相遇的地方）</span></span><br><span class="line">nums[i] = pivot</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// quickSort 函数负责对数组 nums 的子数组 [low, high] 进行快速排序。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="type">int</span>, low, high <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> low &lt; high &#123;</span><br><span class="line"><span class="comment">// 对数组进行分区，并获得枢轴元素的索引</span></span><br><span class="line">pivotIndex := partition(nums, low, high)</span><br><span class="line"><span class="comment">// 对左右两部分进行递归排序</span></span><br><span class="line">quickSort(nums, low, pivotIndex<span class="number">-1</span>)</span><br><span class="line">quickSort(nums, pivotIndex+<span class="number">1</span>, high)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种短小精悍的写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你想随机选择一个索引作为基准值</span></span><br><span class="line">    pivotIndex := rand.Intn(n)</span><br><span class="line">    nums[<span class="number">0</span>], nums[pivotIndex] = nums[pivotIndex], nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    pivot := nums[<span class="number">0</span>]</span><br><span class="line">    i, j := <span class="number">-1</span>, n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">        <span class="keyword">for</span> i++; nums[i] &lt; pivot; i++ &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j--; nums[j] &gt; pivot; j-- &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> i &lt; j &#123;</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quickSort(nums[:j+<span class="number">1</span>])</span><br><span class="line">    quickSort(nums[j+<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性质</p><ul><li></li></ul><h2 id="堆排序">堆排序</h2><h1 id="O-n">O( n )</h1><h2 id="计数排序">计数排序</h2><h2 id="基数排序">基数排序</h2><h2 id="桶排序">桶排序</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;details class=&quot;toggle&quot; &gt;&lt;summary class=&quot;toggle-button&quot; style=&quot;&quot;&gt;衡量排序算法的好坏&lt;/summary&gt;&lt;div class=&quot;toggle-content&quot;&gt;&lt;p&gt;时间复杂度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包含最好情况、最坏情况和平均情况&lt;/li&gt;
&lt;li&gt;数据有序度不同的影响&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;空间复杂度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否是原地排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;稳定性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排序后，相同元素之间的顺序是否会改变&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/details&gt;
&lt;h1 id=&quot;O-n-2&quot;&gt;O( n^2 )&lt;/h1&gt;
&lt;h2 id=&quot;冒泡排序（Bubble-Sort）&quot;&gt;冒泡排序（Bubble Sort）&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;依次比较相邻的元素，如果顺序错误，则交换它们。每轮排序将最大（或最小）的元素“冒泡”到正确的位置&lt;/p&gt;
&lt;p&gt;简单易懂，但效率较低，不适用于大规模数据排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;过程&lt;/p</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://nickxu.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法拾遗" scheme="https://nickxu.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97/"/>
    
    <category term="排序" scheme="https://nickxu.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%8B%BE%E9%81%97/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
</feed>
